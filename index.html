<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas - Fairy Tale Town</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020203; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.9); 
            pointer-events: none; z-index: 10; font-size: 14px;
            background: linear-gradient(90deg, rgba(0,0,0,0.7) 0%, transparent 100%);
            padding: 20px; border-radius: 8px; border-left: 4px solid #ffcc00;
        }
        h1 { margin: 0 0 5px 0; font-size: 26px; color: #ffcc00; text-shadow: 0 2px 10px rgba(255,200,0,0.3); }
        p { margin: 4px 0; font-size: 13px; color: #ddd; }
        .highlight { color: #4fc3f7; font-weight: bold; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.85); padding: 25px 50px; border-radius: 12px;
            border: 1px solid #444; font-size: 16px; letter-spacing: 2px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>ğŸ„ åœ£è¯ç«¥è¯é•‡ (å…¨åœºæ™¯å‡çº§ç‰ˆ)</h1>
        <p>âœ¨ æ–°å¢: <span class="highlight">è¿·é›¾æ£®æ— / ç»´å¤šåˆ©äºšè·¯ç¯ / é›ªäººå®¶æ—</span></p>
        <p>ğŸŒŒ ç¯å¢ƒ: <span class="highlight">ç’€ç’¨æ˜Ÿç©º + åœ°å½¢èµ·ä¼</span></p>
        <p>ğŸš‚ äº’åŠ¨: <span class="highlight">ç‚¹å‡»ç«è½¦å¯åœ / ç‚¹å‡»å¤œç©ºæ”¾çƒŸèŠ±</span></p>
    </div>
    
    <div id="loading">æ­£åœ¨ç§æ¤æ£®æ—...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- æ ¸å¿ƒå‚æ•° ---
        const PARAMS = {
            // ç¯å¢ƒ
            moonIntensity: 0.8,
            ambientIntensity: 0.15,
            groundColor: 0x8899aa,
            
            // ç¯å…‰
            bulbBrightness: 10.0,
            starBrightness: 20.0,
            trainLightPower: 25.0,
            lampBrightness: 12.0, // è·¯ç¯äº®åº¦
            
            // ç‰¹æ•ˆ
            bloomThreshold: 1.1,
            bloomStrength: 1.2,
            bloomRadius: 0.7,
            
            // ç‰©ç†
            trainSpeed: 0.45,
            autoRotate: true,
        };

        let scene, camera, renderer, composer, controls;
        let raycaster, mouse;
        let train, fireworkMgr, snowSystem;
        let lights = {}; 
        let groundMesh;
        let bloomPass;
        let emissiveObjects = []; // ç»Ÿä¸€ç®¡ç†æ‰€æœ‰å‘å…‰ç‰©ä½“
        const clock = new THREE.Clock();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020305); // æ·±é‚ƒå¤œç©º
            scene.fog = new THREE.FogExp2(0x020305, 0.0025); // è¿œå¤„è¿·é›¾

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 50, 140);

            // HDR æ¸²æŸ“å™¨è®¾ç½®
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // å…‰ç…§
            setupEnvironment();

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = PARAMS.bloomThreshold;
            bloomPass.strength = PARAMS.bloomStrength;
            bloomPass.radius = PARAMS.bloomRadius;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- åœºæ™¯æ„å»º (å‡çº§ç‰ˆ) ---
            createRealisticTree();   // ä¸»æ ‘
            createTrainSystem();     // ç«è½¦
            createSurroundings();    // ã€æ–°å¢ã€‘æ£®æ—ã€è·¯ç¯ã€é›ªäººã€æ˜Ÿæ˜Ÿ
            createGifts();           // ç¤¼ç‰©
            
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupInteraction();
            setupGUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupEnvironment() {
            // æœˆå…‰ (å†·è‰²)
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-80, 150, -80);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(2048, 2048);
            lights.moon.shadow.camera.left = -150; lights.moon.shadow.camera.right = 150;
            lights.moon.shadow.camera.top = 150; lights.moon.shadow.camera.bottom = -150;
            scene.add(lights.moon);

            // ç¯å¢ƒå…‰ (æš—æ·¡)
            lights.ambient = new THREE.AmbientLight(0x404060, PARAMS.ambientIntensity);
            scene.add(lights.ambient);

            // åœ°é¢ (ä¸å‘å…‰æ¼«åå°„)
            const groundGeo = new THREE.CircleGeometry(500, 128);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: PARAMS.groundColor, roughness: 1.0, metalness: 0.0
            });
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2; 
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // é“è½¨
            const track = new THREE.Mesh(
                new THREE.TorusGeometry(40, 0.6, 8, 120),
                new THREE.MeshStandardMaterial({color:0x1a1a1a, roughness:0.8})
            );
            track.rotation.x = Math.PI/2; track.position.y=0.1;
            scene.add(track);
        }

        // ============================
        // ğŸŒ² åœºæ™¯ä¸°å¯ŒåŒ– (Surroundings)
        // ============================
        function createSurroundings() {
            // 1. ç’€ç’¨æ˜Ÿç©º
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) {
                const x = (Math.random()-0.5) * 1000;
                const y = Math.random() * 500 + 50;
                const z = (Math.random()-0.5) * 1000;
                starPos.push(x, y, z);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 1.5, transparent: true, opacity: 0.8});
            const starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);

            // 2. è¿·é›¾æ£®æ— (Forest)
            const treeColors = [0x0a3a0a, 0x0f4d0f, 0x145214]; // ä¸åŒæ·±æµ…çš„ç»¿
            for(let i=0; i<80; i++) {
                // éšæœºåˆ†å¸ƒåœ¨åŠå¾„ 60~200 çš„åœ†ç¯åŒºåŸŸ
                const angle = Math.random() * Math.PI * 2;
                const r = 60 + Math.random() * 140; 
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                // ç®€å•çš„èƒŒæ™¯æ ‘
                const g = new THREE.Group();
                g.position.set(x, 0, z);
                // éšæœºå¤§å°
                const scale = 0.8 + Math.random() * 1.5;
                g.scale.set(scale, scale, scale);
                g.rotation.y = Math.random() * Math.PI;

                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 4), new THREE.MeshStandardMaterial({color:0x3e2723}));
                trunk.position.y = 2; g.add(trunk);
                
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(4, 12, 8), new THREE.MeshStandardMaterial({
                    color: treeColors[Math.floor(Math.random()*3)], roughness: 0.9
                }));
                leaves.position.y = 8; 
                if(r < 120) leaves.castShadow = true; // åªæœ‰è¿‘å¤„çš„æ ‘æŠ•å°„é˜´å½±ï¼Œä¼˜åŒ–æ€§èƒ½
                g.add(leaves);
                
                // æ ‘é¡¶ç§¯é›ª
                const snowTop = new THREE.Mesh(new THREE.ConeGeometry(3.5, 4, 8), new THREE.MeshStandardMaterial({color:0xeeeeee}));
                snowTop.position.y = 10;
                g.add(snowTop);

                scene.add(g);
            }

            // 3. ç»´å¤šåˆ©äºšè·¯ç¯ (Street Lamps)
            const lampPos = [
                {x: 45, z: 20}, {x: -45, z: 20}, {x: 0, z: -55}, {x: 35, z: -35}, {x: -20, z: 50}
            ];
            lampPos.forEach(p => createStreetLamp(p.x, p.z));

            // 4. é›ªäººå®¶æ— (Snowmen)
            for(let i=0; i<5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 20 + Math.random() * 25; // åœ¨è½¨é“å†…éƒ¨æˆ–é™„è¿‘
                createSnowman(Math.cos(angle)*r, Math.sin(angle)*r);
            }

            // 5. åœ°å½¢ç»†èŠ‚ (å²©çŸ³/é›ªå †)
            for(let i=0; i<20; i++) {
                const sz = 1 + Math.random()*2;
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(sz, 0),
                    new THREE.MeshStandardMaterial({color:0xffffff, roughness:1}) // çº¯ç™½é›ªå †
                );
                // éšæœºæ•£å¸ƒ
                const a = Math.random()*6.28; const d = 15 + Math.random()*60;
                rock.position.set(Math.cos(a)*d, sz*0.3, Math.sin(a)*d);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.receiveShadow = true;
                scene.add(rock);
            }

            // 6. æˆ¿å­ (å¤ç”¨ä¹‹å‰çš„)
            createHouse(55, -20, -0.5);
            createHouse(-55, 30, 1.2);
        }

        function createStreetLamp(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z);

            // ç¯æ†
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 12), new THREE.MeshStandardMaterial({color:0x1a1a1a}));
            pole.position.y = 6; g.add(pole);
            
            // ç¯ç½©æ¡†æ¶
            const head = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1, 3, 4), new THREE.MeshStandardMaterial({color:0x1a1a1a}));
            head.position.y = 12.5; g.add(head);

            // å‘å…‰ç¯èŠ¯
            const bulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.8), 
                new THREE.MeshStandardMaterial({
                    color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: PARAMS.lampBrightness
                })
            );
            bulb.position.y = 12.5;
            bulb.userData = { type: 'lamp' }; // ç”¨äºGUIæ›´æ–°
            emissiveObjects.push(bulb);
            g.add(bulb);

            // çœŸå®å…‰æº (PointLight)
            const light = new THREE.PointLight(0xffaa00, 5, 30);
            light.position.y = 11;
            light.castShadow = true;
            g.add(light);

            scene.add(g);
        }

        function createSnowman(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            g.rotation.y = Math.random() * Math.PI * 2;
            // èº«ä½“
            const mat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.5});
            const b1 = new THREE.Mesh(new THREE.SphereGeometry(2), mat); b1.position.y=1.5; b1.castShadow=true;
            const b2 = new THREE.Mesh(new THREE.SphereGeometry(1.4), mat); b2.position.y=4.2; b2.castShadow=true;
            g.add(b1); g.add(b2);
            // çœ¼ç›
            const eyeMat = new THREE.MeshBasicMaterial({color:0x111});
            const e1 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat); e1.position.set(0.6, 4.5, 1.1);
            const e2 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat); e2.position.set(-0.6, 4.5, 1.1);
            g.add(e1); g.add(e2);
            // é¼»å­
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1.5, 8), new THREE.MeshStandardMaterial({color:0xff6600}));
            nose.rotation.x=Math.PI/2; nose.position.set(0, 4.3, 1.8);
            g.add(nose);
            // å¸½å­ (éšæœºè‰²)
            const hatColor = Math.random()>0.5 ? 0xd32f2f : 0x1976d2;
            const hat = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2), new THREE.MeshStandardMaterial({color:hatColor}));
            hat.position.set(0, 5.8, 0);
            g.add(hat);
            
            scene.add(g);
        }

        function createHouse(x, z, r) {
            const g = new THREE.Group();
            g.position.set(x, 0, z); g.rotation.y = r;
            const wall = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 8), new THREE.MeshStandardMaterial({color:0x5d4037}));
            wall.position.y = 4; g.add(wall);
            // å±‹é¡¶åŠ åšç§¯é›ª
            const roof = new THREE.Mesh(new THREE.ConeGeometry(9.5, 6, 4), new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 1.0}));
            roof.position.y = 11; roof.rotation.y = Math.PI/4; g.add(roof);
            // çª—æˆ·é€å…‰
            const win = new THREE.Mesh(new THREE.PlaneGeometry(2.5,2.5), new THREE.MeshBasicMaterial({color:0xffcc00}));
            win.position.set(0, 4, 4.1); g.add(win);
            scene.add(g);
        }

        // ============================
        // ğŸ„ ä¸»æ ‘ä¸è£…é¥°
        // ============================
        function createRealisticTree() {
            const grp = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 3, 8, 8), new THREE.MeshStandardMaterial({color:0x3e2723}));
            trunk.position.y = 4; grp.add(trunk);

            const leafMat = new THREE.MeshStandardMaterial({ color: 0x0a4a0a, roughness: 0.8 });
            for(let i=0; i<6; i++) {
                const y = 6 + i*3.5;
                const r = 16 * (1 - i/7) + 1;
                const cone = new THREE.Mesh(new THREE.ConeGeometry(r, 7, 16), leafMat);
                cone.position.y = y; cone.castShadow = true; grp.add(cone);

                const bulbCount = 8 + Math.floor(r);
                for(let j=0; j<bulbCount; j++) {
                    const angle = (j/bulbCount)*Math.PI*2 + i;
                    const br = r - 0.4;
                    const bulbColor = Math.random()>0.5 ? 0xff0000 : 0xffaa00;
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({
                        color: 0x000000, emissive: bulbColor, emissiveIntensity: PARAMS.bulbBrightness
                    }));
                    bulb.position.set(Math.cos(angle)*br, y-3, Math.sin(angle)*br);
                    bulb.userData = { type: 'bulb' };
                    emissiveObjects.push(bulb);
                    grp.add(bulb);
                }
            }
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(2.5), new THREE.MeshStandardMaterial({
                color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: PARAMS.starBrightness
            }));
            star.position.y = 28; star.userData = { type: 'star' };
            emissiveObjects.push(star);
            grp.add(star);
            scene.add(grp);
        }

        // ============================
        // ğŸš‚ ç«è½¦ç³»ç»Ÿ (é•¿åˆ—è½¦)
        // ============================
        function createTrainSystem() {
            train = new TrainSystem(scene);
        }

        class TrainSystem {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.smokes = [];
                this.angle = 0;
                this.speed = 0;
                this.targetSpeed = PARAMS.trainSpeed;
                
                this.loco = this.createLoco();
                this.group.add(this.loco);
                
                const carriageCount = 5;
                const firstCarOffset = 0.17; 
                const carGap = 0.15;

                for(let i=0; i<carriageCount; i++) {
                    const car = this.createCar(i);
                    car.userData.offset = firstCarOffset + (i * carGap);
                    this.group.add(car);
                }
                scene.add(this.group);
            }

            createLoco() {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.4}); 
                const body = new THREE.Mesh(new THREE.BoxGeometry(3.5, 4.5, 7), mat);
                body.position.set(0, 3.5, -1); g.add(body);
                const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 6, 16), mat);
                boiler.rotation.x = Math.PI/2; boiler.position.set(0, 3, 3); g.add(boiler);
                this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1.8), new THREE.MeshStandardMaterial({color:0x222}));
                this.chimney.position.set(0, 4.2, 4.5); g.add(this.chimney);

                const lamp = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4), new THREE.MeshStandardMaterial({color:0x000000, emissive:0xffdd88, emissiveIntensity: PARAMS.trainLightPower}));
                lamp.rotation.x = -Math.PI/2; lamp.position.set(0, 3, 6);
                lamp.userData = { type: 'headlight' };
                emissiveObjects.push(lamp);
                g.add(lamp);

                const spot = new THREE.SpotLight(0xffdd88, 20, 80, 0.6, 0.4);
                spot.position.set(0, 3.5, 6); spot.target.position.set(0, 0, 30);
                g.add(spot); g.add(spot.target);

                const coupler = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 1.5), new THREE.MeshStandardMaterial({color:0x222}));
                coupler.position.set(0, 2, -4.8); g.add(coupler);

                const hit = new THREE.Mesh(new THREE.BoxGeometry(5, 6, 12), new THREE.MeshBasicMaterial({visible:false}));
                hit.userData = { isTrain: true }; g.add(hit);

                this.addWheels(g, 0);
                return g;
            }

            createCar(idx) {
                const g = new THREE.Group();
                const colors = [0x1565c0, 0x2e7d32, 0xf9a825, 0x6a1b9a, 0x00838f];
                const mat = new THREE.MeshStandardMaterial({color: colors[idx % colors.length]});
                const box = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3.5, 5), mat);
                box.position.y = 3; g.add(box);
                
                const cMat = new THREE.MeshStandardMaterial({color:0x222});
                const fc = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,1), cMat); fc.position.set(0,2,2.8); g.add(fc);
                const bc = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,1), cMat); bc.position.set(0,2,-2.8); g.add(bc);

                if(idx % 2 === 0) {
                    const gift = new THREE.Mesh(new THREE.BoxGeometry(2,1.5,2), new THREE.MeshStandardMaterial({color:0xffd54f}));
                    gift.position.y = 5.5; g.add(gift);
                } else {
                    const p1 = new THREE.Mesh(new THREE.BoxGeometry(1.5,1,1.5), new THREE.MeshStandardMaterial({color:0xffffff}));
                    p1.position.set(0, 5, 1); g.add(p1);
                    const p2 = new THREE.Mesh(new THREE.BoxGeometry(1.5,1,1.5), new THREE.MeshStandardMaterial({color:0xff0000}));
                    p2.position.set(0, 5, -1); g.add(p2);
                }
                this.addWheels(g, 1);
                return g;
            }

            addWheels(p, type) {
                const geo = new THREE.CylinderGeometry(0.9, 0.9, 0.4); geo.rotateZ(Math.PI/2);
                const mat = new THREE.MeshStandardMaterial({color:0x111});
                const zOffsets = type === 0 ? [1.5, -1.5, -3.5] : [1.5, -1.5];
                zOffsets.forEach(z => {
                     const w1 = new THREE.Mesh(geo, mat); w1.position.set(1.8, 0.9, z); p.add(w1);
                     const w2 = new THREE.Mesh(geo, mat); w2.position.set(-1.8, 0.9, z); p.add(w2);
                });
            }

            toggle() { this.targetSpeed = this.targetSpeed===0 ? PARAMS.trainSpeed : 0; }

            update(delta) {
                this.speed += (this.targetSpeed - this.speed) * 0.05;
                if(this.speed > 0.01) {
                    this.angle -= this.speed * delta * 0.5;
                    const r = 40;
                    this.moveObj(this.loco, this.angle, r);
                    this.group.children.forEach(c => {
                        if(c.userData.offset) this.moveObj(c, this.angle + c.userData.offset, r);
                    });
                    if(Math.random() > 0.85) {
                        const wPos = new THREE.Vector3(); this.chimney.getWorldPosition(wPos); wPos.y += 0.5;
                        this.spawnSmoke(wPos);
                    }
                }
                this.updateSmoke();
            }

            moveObj(o, a, r) {
                o.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
                o.lookAt(Math.cos(a - 0.1)*r, 0, Math.sin(a - 0.1)*r);
            }

            spawnSmoke(pos) {
                const size = 0.5 + Math.random()*0.5;
                const m = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 0), new THREE.MeshStandardMaterial({color: 0xcccccc, transparent: true, opacity: 0.6, roughness: 1}));
                m.position.copy(pos); m.rotation.set(Math.random()*6, Math.random(), Math.random());
                this.scene.add(m); this.smokes.push({ mesh: m, life: 1.5, vy: 0.1+Math.random()*0.1 });
            }

            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i]; s.life -= 0.02; s.mesh.position.y += s.vy;
                    s.mesh.position.x *= 1.005; s.mesh.position.z *= 1.005; s.mesh.scale.multiplyScalar(1.02);
                    s.mesh.material.opacity = s.life * 0.4;
                    if(s.life<=0) { this.scene.remove(s.mesh); s.mesh.geometry.dispose(); s.mesh.material.dispose(); this.smokes.splice(i,1); }
                }
            }
        }

        // ============================
        // æ‚é¡¹
        // ============================
        function createGifts() {
            const colors = [0xd32f2f, 0x1976d2, 0xffb300];
            for(let i=0; i<8; i++) {
                const g = new THREE.Group();
                const sz = 1.5 + Math.random();
                const box = new THREE.Mesh(new THREE.BoxGeometry(sz,sz,sz), new THREE.MeshStandardMaterial({color:colors[i%3]}));
                box.castShadow = true; g.add(box);
                const rib = new THREE.Mesh(new THREE.BoxGeometry(sz*1.05, sz, sz*0.2), new THREE.MeshStandardMaterial({color:0xffffff}));
                g.add(rib);
                const ang = Math.random()*6.28; const dist = 12 + Math.random()*15;
                g.position.set(Math.cos(ang)*dist, sz/2, Math.sin(ang)*dist);
                g.rotation.y = Math.random();
                g.userData = { isGift:true, vy:0, y0:sz/2 };
                scene.add(g);
            }
        }

        class FireworkManager {
            constructor(scene) {
                this.scene = scene;
                this.list = [];
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
                this.tex = new THREE.CanvasTexture(cvs);
            }
            launch(target) {
                const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.6);
                this.list.push({
                    phase: 'up', pos: target.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10)),
                    vel: new THREE.Vector3(0, 1.2+Math.random()*0.5, 0), destY: 40+Math.random()*20, color: color,
                    trail: this.makeTrail(color), particles: null
                });
            }
            makeTrail(c) { const m = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:c})); this.scene.add(m); return m; }
            explode(fw) {
                this.scene.remove(fw.trail); fw.phase = 'exp';
                const cnt = 250; const pos = [], vels = [];
                for(let i=0; i<cnt; i++) {
                    pos.push(fw.pos.x, fw.pos.y, fw.pos.z);
                    const spd = 0.3+Math.random(); const th=Math.random()*6.28; const ph=Math.acos(2*Math.random()-1);
                    vels.push(Math.sin(ph)*Math.cos(th)*spd, Math.sin(ph)*Math.sin(th)*spd, Math.cos(ph)*spd);
                }
                const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({color: fw.color, size: 2.5, map: this.tex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false});
                fw.particles = new THREE.Points(geo, mat); fw.particles.userData = { vels: vels, life: 1.0 };
                this.scene.add(fw.particles);
            }
            update() {
                for(let i=this.list.length-1; i>=0; i--) {
                    const fw = this.list[i];
                    if(fw.phase === 'up') {
                        fw.pos.add(fw.vel); fw.vel.y *= 0.98; fw.trail.position.copy(fw.pos);
                        if(fw.vel.y<0.2 || fw.pos.y>fw.destY) this.explode(fw);
                    } else {
                        const pts = fw.particles; const p = pts.geometry.attributes.position.array; const v = pts.userData.vels;
                        pts.userData.life -= 0.012;
                        for(let k=0; k<p.length/3; k++) {
                            v[k*3+1] -= 0.005; v[k*3]*=0.96; v[k*3+1]*=0.96; v[k*3+2]*=0.96;
                            p[k*3]+=v[k*3]; p[k*3+1]+=v[k*3+1]; p[k*3+2]+=v[k*3+2];
                        }
                        pts.geometry.attributes.position.needsUpdate = true; pts.material.opacity = pts.userData.life;
                        if(pts.userData.life<=0) { this.scene.remove(pts); this.list.splice(i,1); }
                    }
                }
            }
        }

        class SnowSystem {
            constructor(scene) {
                const geo = new THREE.BufferGeometry(); const pos = [];
                for(let i=0; i<6000; i++) pos.push(Math.random()*500-250, Math.random()*250, Math.random()*500-250);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xaaaaaa, size: 0.6, transparent: true, opacity: 0.8}));
                scene.add(this.mesh);
            }
            update() {
                const p = this.mesh.geometry.attributes.position.array;
                for(let i=1; i<p.length; i+=3) { p[i] -= 0.25; if(p[i]<0) p[i]=250; }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function setupInteraction() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.autoRotate = PARAMS.autoRotate; controls.autoRotateSpeed = 0.5;
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            window.addEventListener('pointerdown', (e) => {
                mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(scene.children, true);
                let hitObj = false;
                if(hits.length>0) {
                    let o = hits[0].object;
                    while(o) {
                        if(o.userData.isTrain) { train.toggle(); hitObj=true; break; }
                        if(o.userData.isGift) { o.userData.vy=0.6; hitObj=true; break; }
                        o = o.parent;
                    }
                }
                if(!hitObj) {
                    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
                    const t = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, t);
                    if(t) fireworkMgr.launch(t);
                }
            });
        }

        function setupGUI() {
            const gui = new GUI({ title: 'ç«¥è¯é•‡æ§åˆ¶å°' });
            
            const f1 = gui.addFolder('ğŸŒ• ç¯å¢ƒä¸å…‰ç…§');
            f1.add(PARAMS, 'moonIntensity', 0, 3).onChange(v => lights.moon.intensity = v);
            f1.addColor(PARAMS, 'groundColor').onChange(v => groundMesh.material.color.set(v));

            const f2 = gui.addFolder('ğŸ’¡ èŠ‚æ—¥å½©ç¯ (å‘å…‰)');
            const updateEmissive = () => {
                emissiveObjects.forEach(d => {
                    if(d.userData.type === 'bulb') d.material.emissiveIntensity = PARAMS.bulbBrightness;
                    if(d.userData.type === 'star') d.material.emissiveIntensity = PARAMS.starBrightness;
                    if(d.userData.type === 'headlight') d.material.emissiveIntensity = PARAMS.trainLightPower;
                    if(d.userData.type === 'lamp') d.material.emissiveIntensity = PARAMS.lampBrightness;
                });
            };
            f2.add(PARAMS, 'bulbBrightness', 1, 20).name('æ ‘ç¯å¼ºåº¦').onChange(updateEmissive);
            f2.add(PARAMS, 'lampBrightness', 1, 30).name('è·¯ç¯å¼ºåº¦').onChange(updateEmissive);
            f2.add(PARAMS, 'trainLightPower', 1, 50).name('ç«è½¦ç¯').onChange(updateEmissive);
            f2.add(PARAMS, 'bloomThreshold', 0.8, 2.0).onChange(v => bloomPass.threshold = v);
            f2.add(PARAMS, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);

            const f3 = gui.addFolder('ğŸš‚ ç‰©ç†');
            f3.add(PARAMS, 'trainSpeed', 0, 1.5).onChange(v => train.targetSpeed = v);
            f3.add(PARAMS, 'autoRotate').onChange(v => controls.autoRotate = v);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();
            scene.children.forEach(o => {
                if(o.userData.isGift && (o.userData.vy!==0 || o.position.y>o.userData.y0)) {
                    o.position.y += o.userData.vy; o.userData.vy -= 0.03;
                    if(o.position.y <= o.userData.y0) { o.position.y=o.userData.y0; o.userData.vy=0; }
                }
            });
            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
