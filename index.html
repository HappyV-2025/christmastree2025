<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Express - Smooth Ride</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020305; font-family: 'Microsoft YaHei', sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* å¯åŠ¨é¡µ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white; transition: opacity 0.8s;
        }
        h1 { font-size: 36px; color: #ffcc00; text-shadow: 0 0 15px #ff6600; margin-bottom: 20px; }
        #start-btn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            color: white; border: none; padding: 15px 50px; font-size: 20px; border-radius: 30px;
            cursor: pointer; box-shadow: 0 0 20px rgba(211, 47, 47, 0.6);
            transition: transform 0.2s;
        }
        #start-btn:active { transform: scale(0.95); }
        .tips { margin-top: 20px; font-size: 14px; color: #aaa; }

        /* HUD */
        #hud-left { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s; }
        #hud-title { color: #fff; font-size: 16px; font-weight: bold; text-shadow: 0 2px 4px #000; }
        
        /* è®¾ç½®æŒ‰é’® */
        #settings-btn {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 44px; height: 44px; background: rgba(0,0,0,0.5);
            border-radius: 50%; border: 1px solid #ffffff44;
            color: white; font-size: 22px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; opacity: 0; transition: opacity 1s;
        }
        
        /* å¼¹çª—å®¹å™¨ */
        #settings-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; display: none; }
        #modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 25; display: none; background: rgba(0,0,0,0.4); }
        
        #loading { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #666; font-size: 12px; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>ğŸ„ åœ£è¯æåœ°ç‰¹å¿«</h1>
        <button id="start-btn">å¼€å§‹æ—…ç¨‹</button>
        <div class="tips">åŒå‡»å±å¹•åˆ‡æ¢è§†è§’ | æ»‘åŠ¨å±å¹•æ—‹è½¬é•œå¤´</div>
    </div>

    <div id="hud-left"><div id="hud-title">ğŸ¥ è·Ÿéšæ¨¡å¼</div></div>
    <div id="settings-btn">âš™ï¸</div>

    <div id="modal-overlay"></div>
    <div id="settings-modal"></div>
    
    <div id="loading">æ­£åœ¨ç»„è£…åŠ é•¿åˆ—è½¦...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        const STATE = { started: false, viewMode: 'FOLLOW', settingsOpen: false };
        const PARAMS = {
            moonIntensity: 1.5,
            bulbBrightness: 15.0,
            trainLightPower: 40.0,
            bloomStrength: 0.8,
            trainSpeed: 0.1, // ç¨å¾®é™ä½é€Ÿåº¦ä»¥å‡å°‘è§†è§‰çœ©æ™•
        };

        let scene, camera, renderer, composer, controls, gui;
        let train, fireworkMgr, snowSystem;
        let lights = {}, bloomPass;
        let emissiveObjects = [];
        let trackCurve;
        const clock = new THREE.Clock();
        
        // ç¼“å­˜å‘é‡é¿å…GC
        const _vec3_1 = new THREE.Vector3();
        const _vec3_2 = new THREE.Vector3();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            scene.fog = new THREE.FogExp2(0x020408, 0.002);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, 100, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupLights();
            generateTrack();
            createEnvironment();

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 1.1;
            bloomPass.strength = PARAMS.bloomStrength;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // å®ä½“
            train = new TrainSystem(scene, trackCurve);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupControls();
            setupUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupLights() {
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-100, 150, -50);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(1024, 1024); // é™ä½é˜´å½±è´´å›¾å¤§å°ä¼˜åŒ–æ€§èƒ½
            lights.moon.shadow.camera.left = -150; lights.moon.shadow.camera.right = 150;
            lights.moon.shadow.camera.top = 150; lights.moon.shadow.camera.bottom = -150;
            scene.add(lights.moon);

            const ambient = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambient);

            const ground = new THREE.Mesh(new THREE.CircleGeometry(500, 64), new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 1.0, metalness: 0.0 }));
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true;
            scene.add(ground);
        }

        function generateTrack() {
            // ä¸‰å¶è‰è·¯å¾„
            const points = [
                new THREE.Vector3(10, 0, 20), new THREE.Vector3(50, 2, 50), new THREE.Vector3(90, 0, 0),
                new THREE.Vector3(50, 0, -50), new THREE.Vector3(10, 0, -20), new THREE.Vector3(-20, 0, -20),
                new THREE.Vector3(-50, 3, -70), new THREE.Vector3(-90, 0, -50), new THREE.Vector3(-60, 0, -10),
                new THREE.Vector3(-60, 0, 10), new THREE.Vector3(-90, 0, 50), new THREE.Vector3(-50, 3, 70),
                new THREE.Vector3(-20, 0, 20), new THREE.Vector3(0, 0, 0)
            ];
            trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            
            // æ¸²æŸ“è½¨é“
            const divisions = 300;
            const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divisions, 2.5, 6, true), new THREE.MeshStandardMaterial({color: 0x050505, roughness: 1}));
            bed.position.y = -0.1; bed.scale.y = 0.1; scene.add(bed);

            // æ•æœ¨ (InstancedMesh ä¼˜åŒ–)
            const plankGeo = new THREE.BoxGeometry(4.5, 0.3, 1.0);
            const plankMat = new THREE.MeshStandardMaterial({color: 0x4e342e});
            const planks = new THREE.InstancedMesh(plankGeo, plankMat, divisions);
            const dummy = new THREE.Object3D();
            for(let i=0; i<divisions; i++) {
                const t = i/divisions;
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t);
                dummy.position.copy(pos); dummy.lookAt(pos.clone().add(tangent)); dummy.updateMatrix();
                planks.setMatrixAt(i, dummy.matrix);
            }
            planks.receiveShadow = true; scene.add(planks);
        }

        function createEnvironment() {
            // ä¸‰ä¸ªåœ°æ ‡æ ‘
            createHeroTree(50, 0, 1.5, 0xff0000); 
            createHeroTree(-60, 40, 1.3, 0x00ff00);
            createHeroTree(-60, -40, 1.4, 0xffcc00);
            
            // éšæœºæ£®æ— (ä½¿ç”¨ Group å…‹éš†å¤ªé‡ï¼Œç®€å•ç”¨å¾ªç¯ç”Ÿæˆ)
            // ä¼˜åŒ–ï¼šå‡å°‘å‡ ä½•ä½“æ®µæ•°
            const treeGeo = new THREE.ConeGeometry(1, 1, 8); 
            for(let i=0; i<80; i++) {
                const r = 30 + Math.random() * 120;
                const a = Math.random() * Math.PI * 2;
                const x = Math.cos(a)*r; const z = Math.sin(a)*r;
                // ç®€å•é¿éšœ
                if(x*x + z*z > 400 && Math.random()>0.3) createNatureTree(x, z);
            }
        }

        function createHeroTree(x, z, s, c) {
            const g = new THREE.Group(); g.position.set(x, 0, z); g.scale.set(s,s,s);
            // æ ‘å¹²
            const t = new THREE.Mesh(new THREE.CylinderGeometry(1,2,4,8), new THREE.MeshStandardMaterial({color:0x3e2723})); t.position.y=2; g.add(t);
            // å¶å­
            const lm = new THREE.MeshStandardMaterial({color:0x0f4d0f, roughness:0.8});
            for(let i=0;i<4;i++){
                const cone=new THREE.Mesh(new THREE.ConeGeometry(10-i*2,6,12),lm); cone.position.y=4+i*3.5; cone.castShadow=true; g.add(cone);
                // ç¯
                const cnt=5+i;
                for(let k=0;k<cnt;k++){
                    const a=(k/cnt)*6.28+i; const br=10-i*2-0.5;
                    const b=new THREE.Mesh(new THREE.SphereGeometry(0.35,6,6),new THREE.MeshStandardMaterial({color:0,emissive:Math.random()>0.5?c:0xffffff,emissiveIntensity:PARAMS.bulbBrightness}));
                    b.position.set(Math.cos(a)*br,4+i*3.5-2.5,Math.sin(a)*br); b.userData={type:'bulb'}; emissiveObjects.push(b); g.add(b);
                }
            }
            // æ˜Ÿæ˜Ÿ
            const st=new THREE.Mesh(new THREE.OctahedronGeometry(1.5),new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffaa00,emissiveIntensity:20}));
            st.position.y=20; st.userData={type:'star'}; emissiveObjects.push(st); g.add(st);
            // åœ°ç¯
            const pl=new THREE.PointLight(c,2,30); pl.position.y=5; g.add(pl);
            scene.add(g);
        }

        function createNatureTree(x, z) {
            const g=new THREE.Group(); g.position.set(x,0,z); const s=0.8+Math.random()*0.8; g.scale.set(s,s,s);
            const t=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.8,3,6),new THREE.MeshStandardMaterial({color:0x3e2723})); t.position.y=1.5; g.add(t);
            const m=new THREE.MeshStandardMaterial({color:0x1b3e20});
            for(let i=0;i<3;i++){
                const c=new THREE.Mesh(new THREE.ConeGeometry(4-i,5,8),m); c.position.y=3.5+i*3; c.castShadow=true; g.add(c);
            }
            scene.add(g);
        }

        // ============================
        // ğŸš‚ ä¼˜åŒ–åçš„ç«è½¦ç³»ç»Ÿ
        // ============================
        class TrainSystem {
            constructor(scene, curve) {
                this.scene = scene; this.curve = curve;
                this.group = new THREE.Group();
                this.smokes = [];
                this.progress = 0;
                
                // è½¦å¤´
                this.loco = this.createLoco();
                this.group.add(this.loco);
                
                // è½¦å¢ (åŠ é•¿åˆ°8èŠ‚)
                this.cars = [];
                // é—´è·è®¡ç®—ï¼šçº¦ç­‰äº 0.012 (å–å†³äºæ›²çº¿é•¿åº¦ï¼Œå¾®è°ƒä»¥é˜²è„±èŠ‚)
                // å‡è®¾æ›²çº¿é•¿ ~400ï¼Œè½¦é•¿ ~5ï¼ŒGapåº”ä¸º ~0.0125
                const gapStep = 0.013; 
                
                for(let i=1; i<=8; i++) {
                    const car = this.createCar(i);
                    car.userData.tOffset = i * gapStep; 
                    this.group.add(car);
                    this.cars.push(car);
                }
                scene.add(this.group);
            }

            createLoco() {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.4});
                const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4, 6), mat); body.position.y=3.2; g.add(body);
                this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.4,1.8), new THREE.MeshStandardMaterial({color:0x111}));
                this.chimney.position.set(0,4.2,2); g.add(this.chimney);
                
                const l=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.2),new THREE.MeshStandardMaterial({color:0,emissive:0xffdd88,emissiveIntensity:PARAMS.trainLightPower}));
                l.rotation.x=-1.57; l.position.set(0,3,3.1); l.userData={type:'headlight'}; emissiveObjects.push(l); g.add(l);
                
                const s=new THREE.SpotLight(0xffdd88,30,60,0.6,0.5); s.position.set(0,3.5,4); s.target.position.set(0,0,20); g.add(s); g.add(s.target);
                
                // åè¿æ¥å™¨
                const coup = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.5,1.5), new THREE.MeshStandardMaterial({color:0x111}));
                coup.position.set(0,2,-3.5); g.add(coup);

                return g;
            }

            createCar(i) {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: i%2===0?0x1565c0:0x2e7d32});
                const b = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.2, 4.5), mat); b.position.y=2.8; g.add(b);
                const gf = new THREE.Mesh(new THREE.BoxGeometry(2,1.2,2), new THREE.MeshStandardMaterial({color:0xffd54f})); gf.position.y=5; g.add(gf);
                
                // å‰åè¿æ¥å™¨ (å¡«è¡¥è§†è§‰ç¼éš™)
                const cMat = new THREE.MeshStandardMaterial({color:0x111});
                const fc = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.5,1), cMat); fc.position.set(0,2,2.5); g.add(fc);
                const bc = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.5,1), cMat); bc.position.set(0,2,-2.5); g.add(bc);
                
                return g;
            }

            update(delta) {
                const speed = PARAMS.trainSpeed * delta * 0.2;
                this.progress = (this.progress + speed) % 1;
                
                this.place(this.loco, this.progress);
                
                this.cars.forEach(c => {
                    let t = this.progress - c.userData.tOffset;
                    if(t < 0) t += 1;
                    this.place(c, t);
                });

                if(Math.random()>0.88) {
                    _vec3_1.setFromMatrixPosition(this.chimney.matrixWorld);
                    _vec3_1.y += 0.5;
                    this.spawnSmoke(_vec3_1);
                }
                this.updateSmoke();
            }

            place(obj, t) {
                const pos = this.curve.getPointAt(t);
                const tangent = this.curve.getTangentAt(t);
                obj.position.copy(pos);
                obj.lookAt(pos.clone().add(tangent));
            }

            spawnSmoke(pos) {
                const m = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4+Math.random()*0.4, 0), new THREE.MeshStandardMaterial({color:0xcccccc, transparent:true, opacity:0.4}));
                m.position.copy(pos);
                this.scene.add(m); this.smokes.push({m, life:1.2});
            }
            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i]; s.life-=0.02; s.m.position.y+=0.06; s.m.scale.multiplyScalar(1.02); s.m.material.opacity=s.life*0.3;
                    if(s.life<=0){ this.scene.remove(s.m); this.smokes.splice(i,1); }
                }
            }
        }

        class FireworkManager {
            constructor(s){this.s=s;this.l=[];const c=document.createElement('canvas');c.width=32;c.height=32;const x=c.getContext('2d');const g=x.createRadialGradient(16,16,0,16,16,16);g.addColorStop(0,'#fff');g.addColorStop(1,'transparent');x.fillStyle=g;x.fillRect(0,0,32,32);this.t=new THREE.CanvasTexture(c);}
            launch(){
                // åœ¨ç›¸æœºå‰æ–¹éšæœºä½ç½®å‘å°„
                const dist = 50;
                _vec3_1.set(0,0,-dist).applyQuaternion(camera.quaternion).add(camera.position);
                const pos = _vec3_1.clone().add(new THREE.Vector3((Math.random()-0.5)*40, -20, (Math.random()-0.5)*40));
                
                const c = new THREE.Color().setHSL(Math.random(),1,0.6);
                this.l.push({ph:'up',p:pos,v:new THREE.Vector3(0,1.2+Math.random(),0),dy:pos.y+40+Math.random()*20,c:c,tr:new THREE.Mesh(new THREE.SphereGeometry(0.4),new THREE.MeshBasicMaterial({color:c})),pt:null});
                this.s.add(this.l[this.l.length-1].tr);
            }
            update(){
                for(let i=this.l.length-1;i>=0;i--){
                    const f=this.l[i];
                    if(f.ph==='up'){
                        f.p.add(f.v);f.v.y*=0.98;f.tr.position.copy(f.p);
                        if(f.v.y<0.1||f.p.y>f.dy){this.s.remove(f.tr);f.ph='pop';this.exp(f);}
                    }else{
                        const p=f.pt.geometry.attributes.position.array;f.li-=0.015;
                        for(let k=0;k<p.length/3;k++){p[k*3]+=f.vs[k*3];p[k*3+1]+=f.vs[k*3+1];p[k*3+2]+=f.vs[k*3+2];f.vs[k*3+1]-=0.005;}
                        f.pt.geometry.attributes.position.needsUpdate=true;f.pt.material.opacity=f.li;
                        if(f.li<=0){this.s.remove(f.pt);this.l.splice(i,1);}
                    }
                }
            }
            exp(f){
                const cnt=150;const p=[],v=[];
                for(let i=0;i<cnt;i++){p.push(f.p.x,f.p.y,f.p.z);const s=0.2+Math.random()*0.3,th=Math.random()*6.28,ph=Math.acos(2*Math.random()-1);v.push(Math.sin(ph)*Math.cos(th)*s,Math.sin(ph)*Math.sin(th)*s,Math.cos(ph)*s);}
                const g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));
                const m=new THREE.PointsMaterial({color:f.c,size:2,map:this.t,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false});
                f.pt=new THREE.Points(g,m);f.li=1.0;f.vs=v;this.s.add(f.pt);
            }
        }
        
        class SnowSystem {
            constructor(s){
                const p=[];for(let i=0;i<3000;i++)p.push(Math.random()*600-300,Math.random()*200,Math.random()*600-300);
                const g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));
                this.m=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.7}));s.add(this.m);
            }
            update(){
                const p=this.m.geometry.attributes.position.array;
                for(let i=1;i<p.length;i+=3){p[i]-=0.25;if(p[i]<0)p[i]=200;}
                this.m.geometry.attributes.position.needsUpdate=true;
            }
        }

        // ============================
        // äº¤äº’é€»è¾‘
        // ============================
        function setupUI() {
            const startBtn = document.getElementById('start-btn');
            const startScreen = document.getElementById('start-screen');
            const hudLeft = document.getElementById('hud-left');
            const settingsBtn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const overlay = document.getElementById('modal-overlay');

            startBtn.addEventListener('click', () => {
                STATE.started = true;
                startScreen.style.opacity = '0';
                setTimeout(() => startScreen.style.display = 'none', 800);
                hudLeft.style.opacity = '1';
                settingsBtn.style.opacity = '1';
            });

            const toggleSettings = () => {
                STATE.settingsOpen = !STATE.settingsOpen;
                modal.style.display = STATE.settingsOpen ? 'block' : 'none';
                overlay.style.display = STATE.settingsOpen ? 'block' : 'none';
            };
            settingsBtn.addEventListener('click', toggleSettings);
            overlay.addEventListener('click', toggleSettings);

            // GUI
            gui = new GUI({ container: modal, width: '100%' });
            gui.title('æ¸¸æˆè®¾ç½®');
            const f1 = gui.addFolder('å…‰å½±');
            f1.add(PARAMS, 'moonIntensity', 0, 5).onChange(v => lights.moon.intensity = v);
            f1.add(PARAMS, 'bloomStrength', 0, 2).onChange(v => bloomPass.strength = v);
            const f2 = gui.addFolder('æ¸¸æˆ');
            f2.add(PARAMS, 'trainSpeed', 0, 0.4);
            const updateEmis = () => emissiveObjects.forEach(o => {
                if(o.userData.type==='bulb') o.material.emissiveIntensity=PARAMS.bulbBrightness;
                if(o.userData.type==='headlight') o.material.emissiveIntensity=PARAMS.trainLightPower;
            });
            f1.add(PARAMS, 'bulbBrightness', 1, 30).onChange(updateEmis);
            f1.add(PARAMS, 'trainLightPower', 1, 60).onChange(updateEmis);

            // ç‚¹å‡»æ”¾çƒŸèŠ± & åŒå‡»åˆ‡æ¢
            window.addEventListener('pointerdown', (e) => {
                if(STATE.settingsOpen || !STATE.started) return;
                // ç‚¹å‡»å±å¹•ä¸ŠåŠéƒ¨åˆ†æˆ–ä»»æ„ä½ç½®æ”¾çƒŸèŠ±
                fireworkMgr.launch(); 
            });
            
            window.addEventListener('dblclick', () => {
                if(!STATE.started) return;
                STATE.viewMode = STATE.viewMode === 'FOLLOW' ? 'GOD' : 'FOLLOW';
                document.getElementById('hud-title').innerText = STATE.viewMode === 'FOLLOW' ? "ğŸ¥ è·Ÿéšæ¨¡å¼" : "â˜ï¸ ä¸Šå¸è§†è§’";
                if(STATE.viewMode === 'GOD') controls.target.set(0,0,0);
            });
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 400;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();

            if (STATE.started && STATE.viewMode === 'FOLLOW' && train) {
                const targetPos = train.loco.position;
                const targetQuat = train.loco.quaternion;

                // 1. æ ¸å¿ƒï¼šæ§åˆ¶å™¨ç›®æ ‡å§‹ç»ˆé”å®šè½¦å¤´
                controls.target.copy(targetPos);

                // 2. æ¶ˆé™¤å¡é¡¿çš„è½¯è·Ÿéšé€»è¾‘
                // æˆ‘ä»¬ä¸å¼ºè¡Œè®¾ç½® camera.positionï¼Œè€Œæ˜¯è®© camera å°½é‡ä¿æŒåœ¨è½¦åæŸä¸ªç›¸å¯¹ä½ç½®
                // å¦‚æœç”¨æˆ·åœ¨æ—‹è½¬ï¼ˆuser interactingï¼‰ï¼Œæˆ‘ä»¬å°±æš‚åœè‡ªåŠ¨å½’ä½ï¼Œé¿å…æ‰“æ¶
                // è¿™é‡Œç”¨ä¸€ä¸ªç®€åŒ–çš„é€»è¾‘ï¼šå¦‚æœè·ç¦»è¿‡è¿œï¼Œå°±è½»è½»æ‹‰ä¸€æŠŠ
                
                // è®¡ç®—ç†æƒ³ä½ç½®ï¼šè½¦å 25ç±³ï¼Œé«˜ 12ç±³
                _vec3_1.set(0, 12, -25).applyQuaternion(targetQuat).add(targetPos);
                
                // åªæœ‰å½“è·ç¦»åå·®è¾ƒå¤§æ—¶æ‰å¯ç”¨ lerpï¼Œæˆ–è€…å§‹ç»ˆå¼€å¯å¾®å¼±çš„ lerp
                // å…³é”®ç‚¹ï¼šOrbitControls çš„ update() ä¼šæ ¹æ® target æ›´æ–°ç›¸æœº
                // æˆ‘ä»¬åªéœ€è¦è½»å¾®ä¿®æ­£ç›¸æœºä½ç½®ä»¥è·Ÿéšç«è½¦çš„ä½ç§»å‘é‡
                
                // ç®€å•æ–¹æ¡ˆï¼šç›´æ¥ç”¨ OrbitControls å¤„ç†æ—‹è½¬ï¼Œæˆ‘ä»¬åªç§»åŠ¨ Camera ä½ç½®ä»¥æŠµæ¶ˆç«è½¦ä½ç§»
                // ä½†è¿™å¾ˆéš¾å®Œç¾ã€‚æ›´ç¨³å¥çš„æ–¹æ¡ˆï¼š
                // ä½¿ç”¨ smooth lerp é€¼è¿‘ç†æƒ³ç‚¹
                camera.position.lerp(_vec3_1, 0.02); 
            } else if (!STATE.started) {
                // å¾…æœºåŠ¨ç”»ï¼šç›˜æ—‹
                const t = Date.now() * 0.0001;
                camera.position.x = Math.sin(t) * 150;
                camera.position.z = Math.cos(t) * 150;
                camera.position.y = 100;
                camera.lookAt(0,0,0);
            }

            controls.update();
            composer.render();
        }

        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
