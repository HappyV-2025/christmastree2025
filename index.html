<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas - Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* å·¦ä¸Šè§’æç¤º UI */
        #ui {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.9); pointer-events: none;
            text-shadow: 0 0 4px #000; z-index: 10; font-size: 14px;
        }
        h1 { margin: 0 0 8px 0; font-size: 24px; color: #ffcc00; }
        .highlight { color: #00ffff; font-weight: bold; }
        
        /* åŠ è½½åŠ¨ç”» */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 18px; letter-spacing: 2px;
            background: rgba(0,0,0,0.7); padding: 20px 40px; border-radius: 10px;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>ğŸ„ åœ£è¯æ¢¦å·¥åœº (å¯è°ƒå‚ç‰ˆ)</h1>
        <p>1. ç‚¹å‡»å¤œç©º: <span class="highlight">æ”¾çƒŸèŠ±</span></p>
        <p>2. ç‚¹å‡»ç‰©ä½“: <span class="highlight">ç«è½¦å¯åœ / ç¤¼ç‰©äº’åŠ¨</span></p>
        <p>3. å³ä¾§é¢æ¿: <span class="highlight">è°ƒæ•´æ‰€æœ‰ç”»é¢å‚æ•°</span></p>
    </div>
    
    <div id="loading">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js'; // å¼•å…¥GUIåº“

        // --- å‚æ•°é…ç½®å¯¹è±¡ (ç”¨äº GUI) ---
        const PARAMS = {
            // ç¯å¢ƒ
            ambientIntensity: 0.4,
            hemiIntensity: 0.4,
            moonIntensity: 1.2,
            groundRoughness: 0.9,
            
            // Bloom åå¤„ç†
            bloomStrength: 1.0,  // å‘å…‰å¼ºåº¦
            bloomRadius: 0.5,    // æ‰©æ•£åŠå¾„
            bloomThreshold: 0.3, // é˜ˆå€¼ï¼šåªæœ‰äº®åº¦è¶…è¿‡0.3çš„åƒç´ æ‰å‘å…‰ï¼ˆè§£å†³åœ°é¢è¿‡æ›ï¼‰

            // ç«è½¦
            trainSpeed: 0.5,
            smokeSize: 1.0,
            smokeOpacity: 0.4,
            
            // çƒŸèŠ±
            gravity: 0.005,
            explosionSize: 2.5,
            
            // äº¤äº’
            autoRotate: true,
        };

        let scene, camera, renderer, composer, controls, gui;
        let raycaster, mouse;
        let train, fireworkMgr, snowSystem;
        let lights = {}; // å­˜å‚¨ç¯å…‰å¼•ç”¨ä»¥ä¾¿è°ƒæ•´
        let groundMesh;
        let bloomPass;
        let gifts = [];
        const clock = new THREE.Clock();

        function init() {
            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x02040a);
            scene.fog = new THREE.FogExp2(0x02040a, 0.0025); 

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, 40, 120);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPIä¼˜åŒ–æ€§èƒ½
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. ç¯å…‰
            setupLights();

            // 5. åå¤„ç† Bloom
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            // åº”ç”¨åˆå§‹å‚æ•°
            bloomPass.threshold = PARAMS.bloomThreshold;
            bloomPass.strength = PARAMS.bloomStrength;
            bloomPass.radius = PARAMS.bloomRadius;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 6. åœºæ™¯ç‰©ä½“
            createEnvironment();
            
            // 7. åˆå§‹åŒ–ç³»ç»Ÿ
            train = new TrainSystem(scene);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            // 8. äº¤äº’
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = PARAMS.autoRotate;
            controls.autoRotateSpeed = 0.5;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            // 9. åˆ›å»º GUI é¢æ¿
            setupGUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupLights() {
            // ç¯å¢ƒå…‰
            lights.ambient = new THREE.AmbientLight(0xffffff, PARAMS.ambientIntensity);
            scene.add(lights.ambient);

            // åŠçƒå…‰ (æ¨¡æ‹Ÿå¤©å…‰åœ°å…‰)
            lights.hemi = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, PARAMS.hemiIntensity);
            scene.add(lights.hemi);

            // æœˆå…‰ (ä¸»å…‰)
            lights.dir = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.dir.position.set(-50, 100, -50);
            lights.dir.castShadow = true;
            lights.dir.shadow.mapSize.set(2048, 2048);
            lights.dir.shadow.camera.left = -100;
            lights.dir.shadow.camera.right = 100;
            lights.dir.shadow.camera.top = 100;
            lights.dir.shadow.camera.bottom = -100;
            scene.add(lights.dir);
        }

        function setupGUI() {
            gui = new GUI({ title: 'ğŸ„ åœºæ™¯æ§åˆ¶å™¨' });
            
            const folderEnv = gui.addFolder('ğŸŒŒ ç¯å¢ƒä¸ç¯å…‰');
            folderEnv.add(PARAMS, 'ambientIntensity', 0, 2).name('ç¯å¢ƒå…‰å¼ºåº¦').onChange(v => lights.ambient.intensity = v);
            folderEnv.add(PARAMS, 'moonIntensity', 0, 3).name('æœˆå…‰å¼ºåº¦').onChange(v => lights.dir.intensity = v);
            folderEnv.add(PARAMS, 'bloomStrength', 0, 3).name('å‘å…‰å¼ºåº¦ (Bloom)').onChange(v => bloomPass.strength = v);
            folderEnv.add(PARAMS, 'bloomThreshold', 0, 1).name('å‘å…‰é˜ˆå€¼').onChange(v => bloomPass.threshold = v);
            
            const folderGround = gui.addFolder('â„ï¸ åœ°é¢è®¾ç½®');
            folderGround.add(PARAMS, 'groundRoughness', 0, 1).name('é›ªåœ°ç²—ç³™åº¦').onChange(v => groundMesh.material.roughness = v);
            folderGround.addColor({ color: 0xeef2f5 }, 'color').name('é›ªåœ°é¢œè‰²').onChange(v => groundMesh.material.color.set(v));

            const folderTrain = gui.addFolder('ğŸš‚ ç«è½¦è®¾ç½®');
            folderTrain.add(PARAMS, 'trainSpeed', 0, 2).name('è¡Œé©¶é€Ÿåº¦').onChange(v => train.targetSpeed = v);
            folderTrain.add(PARAMS, 'smokeSize', 0.1, 3).name('çƒŸé›¾å¤§å°');

            const folderFW = gui.addFolder('ğŸ† çƒŸèŠ±è®¾ç½®');
            folderFW.add(PARAMS, 'gravity', 0, 0.02).name('é‡åŠ›ç³»æ•°');
            folderFW.add(PARAMS, 'explosionSize', 1, 5).name('çˆ†ç‚¸èŒƒå›´');

            const folderCam = gui.addFolder('ğŸ¥ ç›¸æœº');
            folderCam.add(PARAMS, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬åœºæ™¯').onChange(v => controls.autoRotate = v);
        }

        // ============================
        // åœºæ™¯æ„å»º
        // ============================
        function createEnvironment() {
            // 1. åœ°é¢ (è°ƒæš—ä¸€ç‚¹ï¼Œé˜²æ­¢å…¨ç™½è¿‡æ›)
            const groundGeo = new THREE.CircleGeometry(300, 64);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0xeef2f5, 
                roughness: PARAMS.groundRoughness,
                metalness: 0.1,
            });
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2; 
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // è½¨é“
            const tGeo = new THREE.TorusGeometry(35, 0.4, 8, 120);
            const track = new THREE.Mesh(tGeo, new THREE.MeshStandardMaterial({color:0x111111}));
            track.rotation.x = Math.PI/2; track.position.y=0.1; 
            scene.add(track);

            // 2. çœŸå®æ„Ÿåœ£è¯æ ‘
            createRealisticTree();

            // 3. è£…é¥°ç‰©
            createHouse(50, -30, 0);
            createHouse(-45, 20, 1.5);
            createFancyGifts();
        }

        // --- æ ¸å¿ƒï¼šé‡å†™åœ£è¯æ ‘ ---
        function createRealisticTree() {
            const treeGroup = new THREE.Group();
            
            // æ ‘å¹²
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 2.5, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.9 })
            );
            trunk.position.y = 4;
            treeGroup.add(trunk);

            // æ ‘å¶å±‚ (ä½¿ç”¨å¤šå±‚åœ†é”¥æ¨¡æ‹ŸèŒ‚å¯†æ„Ÿ)
            const leafMat = new THREE.MeshStandardMaterial({ 
                color: 0x0f4d0f, 
                roughness: 0.8,
                flatShading: true // ä½å¤šè¾¹å½¢é£æ ¼
            });
            
            const layers = 7;
            for (let i = 0; i < layers; i++) {
                const ratio = i / layers;
                const radius = 14 * (1 - ratio) + 2; // åº•éƒ¨å¤§é¡¶éƒ¨å°
                const height = 6;
                const y = 6 + i * 3.5;
                
                // æ¯ä¸€å±‚
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, height, 16),
                    leafMat
                );
                cone.position.y = y;
                cone.castShadow = true;
                cone.scale.set(1, 1, 1);
                treeGroup.add(cone);

                // åœ¨æ¯å±‚æŒ‚ç‚¹å½©ç¯çƒ
                if (i < layers - 1) {
                    const bulbsCount = 6 + i;
                    for (let j = 0; j < bulbsCount; j++) {
                        const angle = (j / bulbsCount) * Math.PI * 2 + (i * 0.5); // é”™ä½
                        const r = radius - 0.5;
                        const bx = Math.cos(angle) * r;
                        const bz = Math.sin(angle) * r;
                        const by = y - height * 0.45; // æŒ‚åœ¨å¶å­è¾¹ç¼˜ä¸‹æ–¹

                        const bulbColor = Math.random() > 0.5 ? 0xff0000 : 0xffd700;
                        const bulb = new THREE.Mesh(
                            new THREE.SphereGeometry(0.5, 8, 8),
                            new THREE.MeshStandardMaterial({
                                color: bulbColor,
                                emissive: bulbColor,
                                emissiveIntensity: 2.0 // ç¡®ä¿å‘å…‰
                            })
                        );
                        bulb.position.set(bx, by, bz);
                        treeGroup.add(bulb);
                    }
                }
            }

            // èºæ—‹å½©å¸¦ (Tinsel)
            const points = [];
            const spiralHeight = 25;
            const spiralRadiusStart = 14;
            const loops = 4;
            for(let i=0; i<=100; i++) {
                const t = i/100;
                const angle = t * Math.PI * 2 * loops;
                const r = spiralRadiusStart * (1 - t) + 1;
                const y = 6 + t * spiralHeight;
                points.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
            }
            const ribbonGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 64, 0.4, 8, false);
            const ribbonMat = new THREE.MeshStandardMaterial({
                color: 0xffd700, metalness: 0.6, roughness: 0.2, emissive: 0xaa8800, emissiveIntensity: 0.2
            });
            const ribbon = new THREE.Mesh(ribbonGeo, ribbonMat);
            treeGroup.add(ribbon);

            // æ ‘é¡¶æ˜Ÿ
            const star = new THREE.Mesh(
                new THREE.OctahedronGeometry(2.5, 0),
                new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffcc00, emissiveIntensity: 3.0 })
            );
            star.position.y = 32;
            star.userData = { isStar: true }; // ç”¨äºåŠ¨ç”»
            treeGroup.add(star);

            scene.add(treeGroup);
            
            // æ³¨å†ŒåŠ¨ç”»
            treeGroup.userData.update = function(t) {
                star.rotation.y = t;
                star.material.emissiveIntensity = 2.5 + Math.sin(t * 3) * 1.0;
            };
            return treeGroup;
        }

        // ============================
        // ç«è½¦ç³»ç»Ÿ (ä¿®å¤çƒŸé›¾ä½ç½®)
        // ============================
        class TrainSystem {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.wheels = [];
                this.angle = 0;
                this.speed = 0;
                this.targetSpeed = PARAMS.trainSpeed;
                
                this.loco = this.buildLoco();
                this.group.add(this.loco);
                
                // è½¦å¢
                for(let i=1; i<=2; i++) {
                    const car = this.buildCar();
                    // ç®€å•çš„åç§»é€»è¾‘ï¼šæ¯ä¸ªè½¦å¢åœ¨è½¨é“åœ†å‘¨ä¸Šæ»åä¸€å®šè§’åº¦
                    car.userData.angleOffset = i * 0.35; 
                    this.group.add(car);
                }

                this.scene.add(this.group);
                this.smokes = [];
            }

            buildLoco() {
                const grp = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: 0xd32f2f, roughness: 0.4});
                
                // è½¦ä½“
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 6), mat);
                body.position.y = 3;
                grp.add(body);
                
                // é”…ç‚‰
                const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 4, 16), mat);
                boiler.rotation.x = Math.PI/2; boiler.position.set(0, 3, 3);
                grp.add(boiler);

                // çƒŸå›± (å…³é”®ï¼šç¡®å®šä½ç½®)
                const chim = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1.5), new THREE.MeshStandardMaterial({color:0x222}));
                chim.position.set(0, 4.2, 4); // å±€éƒ¨åæ ‡ï¼šY=4.2, Z=4 (è½¦å¤´å‰æ–¹)
                grp.add(chim);
                this.chimneyRef = chim; // ä¿å­˜å¼•ç”¨

                // è½¦ç¯
                const light = new THREE.SpotLight(0xffaa00, 10, 40, 0.6, 0.5);
                light.position.set(0, 3, 5.5);
                light.target.position.set(0, 0, 20);
                grp.add(light); grp.add(light.target);

                // å…‰æŸ±
                const beam = new THREE.Mesh(
                    new THREE.ConeGeometry(2, 10, 32, 1, true),
                    new THREE.MeshBasicMaterial({color: 0xffaa00, transparent:true, opacity:0.1, depthWrite:false, blending:THREE.AdditiveBlending})
                );
                beam.rotation.x = -Math.PI/2; beam.position.set(0, 3, 5.5); beam.geometry.translate(0,-5,0);
                grp.add(beam);

                this.addWheels(grp);
                
                // ç‚¹å‡»åˆ¤å®šç›’
                const hit = new THREE.Mesh(new THREE.BoxGeometry(5,6,10), new THREE.MeshBasicMaterial({visible:false}));
                hit.userData = { isTrain: true };
                grp.add(hit);

                return grp;
            }

            buildCar() {
                const grp = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: 0x1976d2});
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 4), mat);
                body.position.y = 2.5;
                grp.add(body);
                this.addWheels(grp);
                return grp;
            }

            addWheels(parent) {
                const geo = new THREE.CylinderGeometry(0.8, 0.8, 0.4);
                geo.rotateZ(Math.PI/2);
                const mat = new THREE.MeshStandardMaterial({color:0x111});
                [1.6, -1.6].forEach(x => {
                    [1.5, -1.5].forEach(z => {
                        const w = new THREE.Mesh(geo, mat);
                        w.position.set(x, 0.8, z);
                        parent.add(w);
                        this.wheels.push(w);
                    });
                });
            }

            toggle() { this.targetSpeed = this.targetSpeed === 0 ? PARAMS.trainSpeed : 0; }

            update(delta) {
                // é€Ÿåº¦å¹³æ»‘
                const dest = this.targetSpeed;
                if(Math.abs(this.speed - dest) > 0.01) this.speed += (dest - this.speed)*0.05;
                else this.speed = dest;

                if(this.speed > 0) {
                    this.angle -= this.speed * delta * 0.5;
                    
                    // æ›´æ–°è½¦å¤´ä½ç½®
                    const r = 35;
                    this.updatePiece(this.loco, this.angle, r);
                    
                    // æ›´æ–°è½¦å¢ä½ç½®
                    this.group.children.forEach(c => {
                        if(c.userData.angleOffset) {
                            this.updatePiece(c, this.angle + c.userData.angleOffset, r);
                        }
                    });

                    // è½®å­è½¬åŠ¨
                    this.wheels.forEach(w => w.rotation.x += this.speed * 0.5);

                    // å†’çƒŸé€»è¾‘
                    this.spawnSmoke();
                }

                // æ›´æ–°æ‰€æœ‰çƒŸé›¾ç²’å­
                this.updateSmoke();
            }

            updatePiece(mesh, angle, r) {
                mesh.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                mesh.lookAt(Math.cos(angle-0.1)*r, 0, Math.sin(angle-0.1)*r);
            }

            spawnSmoke() {
                if(Math.random() > 0.9) { // æ§åˆ¶é¢‘ç‡
                    // 1. è·å–çƒŸå›±é¡¶éƒ¨çš„ä¸–ç•Œåæ ‡
                    const worldPos = new THREE.Vector3();
                    this.chimneyRef.getWorldPosition(worldPos);
                    worldPos.y += 0.5; // ç¨å¾®å†é«˜ä¸€ç‚¹

                    // 2. åˆ›å»ºçƒŸé›¾ç²’å­
                    const size = 0.5 * PARAMS.smokeSize;
                    const geo = new THREE.DodecahedronGeometry(size, 0); // ä½å¤šè¾¹å½¢çƒŸé›¾
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xcccccc, 
                        transparent: true, 
                        opacity: PARAMS.smokeOpacity,
                        roughness: 1,
                        flatShading: true
                    });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(worldPos);
                    
                    // éšæœºæ—‹è½¬
                    p.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    
                    this.scene.add(p);
                    this.smokes.push({ mesh: p, life: 1.0, scale: 1.0 });
                }
            }

            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i];
                    s.life -= 0.015; // è¡°å‡
                    
                    // å‘ä¸Šé£˜ + ç•¥å¾®å‘å(æ¨¡æ‹Ÿé£é˜»)
                    s.mesh.position.y += 0.08;
                    // è·å–ç«è½¦åæ–¹å‘å¤§æ¦‚æ˜¯åˆ‡çº¿æ–¹å‘ï¼Œç®€åŒ–ä¸ºç¨å¾®æ»å
                    s.mesh.position.x *= 1.002; 
                    s.mesh.position.z *= 1.002;

                    // å˜å¤§ & å˜æ·¡
                    s.scale += 0.03;
                    s.mesh.scale.setScalar(s.scale);
                    s.mesh.material.opacity = s.life * PARAMS.smokeOpacity;

                    if(s.life <= 0) {
                        this.scene.remove(s.mesh);
                        s.mesh.geometry.dispose();
                        s.mesh.material.dispose();
                        this.smokes.splice(i, 1);
                    }
                }
            }
        }

        // ============================
        // çƒŸèŠ± (æ¥å…¥ GUI å‚æ•°)
        // ============================
        class FireworkManager {
            constructor(scene) {
                this.scene = scene;
                this.fireworks = [];
                // è´´å›¾
                const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
                const ctx = canvas.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'rgba(255,255,255,1)');
                g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                this.texture = new THREE.CanvasTexture(canvas);
            }

            launch(target) {
                const count = 3;
                for(let i=0; i<count; i++) {
                    setTimeout(()=>{
                        const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);
                        this.fireworks.push({
                            phase: 'rise',
                            pos: target.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10)),
                            vel: new THREE.Vector3(0, 1.0 + Math.random()*0.5, 0),
                            destY: 40 + Math.random()*20,
                            color: color,
                            trail: this.makeTrail(color),
                            particles: null
                        });
                    }, i*200);
                }
            }

            makeTrail(c) {
                const m = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({color:c}));
                this.scene.add(m); return m;
            }

            explode(fw) {
                this.scene.remove(fw.trail);
                fw.phase = 'explode';
                const count = 300;
                const geo = new THREE.BufferGeometry();
                const pos = [], vels = [];
                for(let i=0; i<count; i++) {
                    pos.push(fw.pos.x, fw.pos.y, fw.pos.z);
                    // çƒå½¢éšæœº
                    const theta = Math.random()*Math.PI*2;
                    const phi = Math.acos(2*Math.random()-1);
                    const speed = (0.2 + Math.random()*0.8) * PARAMS.explosionSize * 0.5; // å…³è”å‚æ•°
                    vels.push(
                        speed*Math.sin(phi)*Math.cos(theta),
                        speed*Math.sin(phi)*Math.sin(theta),
                        speed*Math.cos(phi)
                    );
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    color: fw.color, size: 2.0, map: this.texture, 
                    transparent:true, blending:THREE.AdditiveBlending, depthWrite:false
                });
                fw.particles = new THREE.Points(geo, mat);
                fw.particles.userData = { vels: vels, life: 1.0 };
                this.scene.add(fw.particles);
            }

            update() {
                for(let i=this.fireworks.length-1; i>=0; i--) {
                    const fw = this.fireworks[i];
                    if(fw.phase==='rise') {
                        fw.pos.add(fw.vel);
                        fw.trail.position.copy(fw.pos);
                        fw.vel.y *= 0.98;
                        if(fw.vel.y < 0.2 || fw.pos.y > fw.destY) this.explode(fw);
                    } else {
                        const pts = fw.particles;
                        const p = pts.geometry.attributes.position.array;
                        const v = pts.userData.vels;
                        pts.userData.life -= 0.015;
                        
                        for(let k=0; k<p.length/3; k++) {
                            // ç‰©ç†æ›´æ–°
                            v[k*3] *= 0.95; v[k*3+1] *= 0.95; v[k*3+2] *= 0.95; // ç©ºæ°”é˜»åŠ›
                            v[k*3+1] -= PARAMS.gravity; // é‡åŠ›å‚æ•°
                            
                            p[k*3] += v[k*3];
                            p[k*3+1] += v[k*3+1];
                            p[k*3+2] += v[k*3+2];
                        }
                        pts.geometry.attributes.position.needsUpdate = true;
                        pts.material.opacity = pts.userData.life;
                        if(pts.userData.life<=0) {
                            this.scene.remove(pts);
                            this.fireworks.splice(i,1);
                        }
                    }
                }
            }
        }

        // ============================
        // è¾…åŠ©å·¥å…·
        // ============================
        class SnowSystem {
            constructor(scene) {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<4000; i++) pos.push(Math.random()*400-200, Math.random()*200, Math.random()*400-200);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff, size:0.6, transparent:true, opacity:0.8}));
                scene.add(this.mesh);
            }
            update() {
                const p = this.mesh.geometry.attributes.position.array;
                for(let i=1; i<p.length; i+=3) {
                    p[i] -= 0.3;
                    if(p[i]<0) p[i]=200;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createHouse(x, z, rot) {
            const g = new THREE.Group();
            g.position.set(x, 2, z); g.rotation.y = rot;
            const body = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 6), new THREE.MeshStandardMaterial({color:0x8d6e63}));
            body.castShadow = true;
            const roof = new THREE.Mesh(new THREE.ConeGeometry(7, 4, 4), new THREE.MeshStandardMaterial({color:0xffffff}));
            roof.position.y = 5; roof.rotation.y=Math.PI/4;
            g.add(body); g.add(roof);
            scene.add(g);
        }

        function createFancyGifts() {
            const colors = [0xe53935, 0x1e88e5, 0xfdd835];
            for(let i=0; i<10; i++) {
                const g = new THREE.Group();
                const sz = 1.5 + Math.random();
                const box = new THREE.Mesh(new THREE.BoxGeometry(sz,sz,sz), new THREE.MeshStandardMaterial({color:colors[i%3]}));
                box.castShadow = true;
                g.add(box);
                const r = 10 + Math.random()*15;
                const a = Math.random()*Math.PI*2;
                g.position.set(Math.cos(a)*r, sz/2, Math.sin(a)*r);
                g.userData = { isGift: true, y0: sz/2, vy: 0 };
                scene.add(g);
                gifts.push(g);
            }
        }

        function onPointerDown(e) {
            mouse.x = (e.clientX/window.innerWidth)*2-1; 
            mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            
            const hits = raycaster.intersectObjects(scene.children, true);
            let clickedObj = false;

            // æ£€æŸ¥ç‚¹å‡»ç‰©ä½“
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj) {
                    if(obj.userData.isTrain) { train.toggle(); clickedObj=true; break; }
                    if(obj.userData.isGift) { obj.userData.vy=0.5; clickedObj=true; break; }
                    obj = obj.parent;
                }
            }

            // æ²¡ç‚¹åˆ°ç‰©ä½“åˆ™æ”¾çƒŸèŠ±
            if(!clickedObj) {
                const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                if(target) fireworkMgr.launch(target);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();
            
            // ç¤¼ç‰©è·³åŠ¨
            gifts.forEach(g => {
                if(g.userData.vy!==0 || g.position.y>g.userData.y0) {
                    g.position.y += g.userData.vy; g.userData.vy -= 0.02;
                    if(g.position.y<=g.userData.y0) { g.position.y=g.userData.y0; g.userData.vy=0; }
                }
            });

            // åœºæ™¯å¾®åŠ¨
            scene.children.forEach(obj => {
                if(obj.userData.update) obj.userData.update(time);
            });

            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
