<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8"><meta name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Christmas Express: Definitive Edition</title>
        <style>
    body{margin:0;overflow:hidden;background:#000;font-family:'Segoe UI',sans-serif;user-select:none}
    #canvas-container{width:100vw;height:100vh;display:block}
    /* UI Overlay */
    #start-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle at center,#1b2028 0%,#000 100%);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100;transition:opacity 0.8s}
    .card{background:rgba(255,255,255,0.06);padding:40px;border-radius:24px;border:1px solid rgba(255,255,255,0.1);text-align:center;backdrop-filter:blur(20px);box-shadow:0 40px 80px rgba(0,0,0,0.6);width:400px}
    h1{color:#ffb300;margin:0 0 20px;letter-spacing:4px;text-shadow:0 0 30px rgba(255,165,0,0.5);text-transform:uppercase}
    .tips{color:#ccc;font-size:14px;line-height:2.2;text-align:left;margin-bottom:30px}
    .k{color:#4fc3f7;font-weight:bold;margin-right:8px;border-bottom:1px dashed #4fc3f7}
    button{background:linear-gradient(135deg,#d32f2f,#b71c1c);color:#fff;border:none;padding:16px 60px;font-size:20px;border-radius:50px;cursor:pointer;box-shadow:0 10px 30px rgba(211,47,47,0.4);transition:0.2s;font-weight:bold;letter-spacing:1px}
    button:hover{transform:scale(1.05);box-shadow:0 15px 40px rgba(211,47,47,0.6)}
    #hud{position:absolute;top:20px;left:20px;z-index:10;opacity:0;transition:1s}
    .tag{background:rgba(0,0,0,0.7);color:#fff;padding:8px 18px;border-radius:30px;font-size:14px;border:1px solid #ffffff22;backdrop-filter:blur(5px);display:flex;align-items:center;gap:10px}
    .dot{width:8px;height:8px;background:#00ff00;border-radius:50%;box-shadow:0 0 8px #00ff00;transition:0.3s}
    .dot.stop{background:#ff3300;box-shadow:0 0 8px #ff3300}
    #settings-btn{position:absolute;top:20px;right:20px;z-index:20;width:44px;height:44px;background:rgba(255,255,255,0.1);border-radius:50%;border:1px solid #ffffff33;color:#fff;font-size:20px;display:flex;justify-content:center;align-items:center;cursor:pointer;opacity:0;backdrop-filter:blur(5px)}
    #settings-modal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:30;display:none;width:320px}
    #modal-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:25;display:none;background:rgba(0,0,0,0.5)}
    #loading{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);color:#666;font-size:12px;letter-spacing:2px}
</style>
    </head>
    <body>
        <div id="start-screen"><div class="card">
                <h1>ğŸ„ åœ£è¯å¿«ä¹</h1>
                <div class="tips">
                    <div><span class="k">ğŸš‚ ç‚¹å‡»ç«è½¦</span> å¯åŠ¨ / åœæ­¢ (æƒ¯æ€§æ»‘è¡Œ)</div>
                    <div><span class="k">ğŸ† ç‚¹å‡»ç©ºåœ°</span> ç‡ƒæ”¾ç‰©ç†çƒŸèŠ±</div>
                    <div><span class="k">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾</span> è°ƒæ•´è·Ÿéšè·ç¦» (è‡ªåŠ¨è®°å¿†)</div>
                    <div><span class="k">ğŸ‘† æ‹–åŠ¨æ—‹è½¬</span> 360Â° è‡ªç”±è§‚å¯Ÿ</div>
                </div>
                <button id="start-btn">é¸£ç¬›å‘è½¦</button>
            </div></div>
        <div id="hud"><div class="tag"><div id="d-status"
                    class="dot"></div><span
                    id="t-status">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span></div></div>
        <div id="settings-btn">âš™ï¸</div>
        <div id="modal-overlay"></div><div id="settings-modal"></div>
        <div id="loading">æ­£åœ¨è£…è½½ç¤¼ç‰©ä¸é­”æ³•...</div>
        <div id="canvas-container"></div>

        <script
            type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
        <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


// ============================
// 3. æ›¿æ¢ AudioEngine ç±» (æ‹ŸçœŸè’¸æ±½é¸£ç¬› + å“äº®è¡Œé©¶å£°)
// ============================
class AudioEngine {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.nextChug = 0;
        this.bgmTimer = null;
        this.isBgmPlaying = false;
        
        // ğŸšï¸ é»˜è®¤éŸ³é‡é…ç½®
        this.vol = {
            master: 0.7,    // æ€»éŸ³é‡ç¨å¤§
            bgm: 0.6,       // BGM é€‚ä¸­ï¼Œä¸è¦ç›–è¿‡éŸ³æ•ˆ
            train: 0.8,     // ç«è½¦å£°æ¸…æ™°
            firework: 1.0   // çƒŸèŠ±éœ‡æ’¼
        };
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // æ··éŸ³é“¾è·¯
            this.nodes.master = this.ctx.createGain();
            this.nodes.bgm = this.ctx.createGain();
            this.nodes.train = this.ctx.createGain();
            this.nodes.fw = this.ctx.createGain();

            this.nodes.bgm.connect(this.nodes.master);
            this.nodes.train.connect(this.nodes.master);
            this.nodes.fw.connect(this.nodes.master);
            this.nodes.master.connect(this.ctx.destination);

            this.updateVols();

            // ç”Ÿæˆé€šç”¨å™ªéŸ³ Buffer (ç”¨äºæ¨¡æ‹Ÿæ°”æµã€çˆ†ç‚¸)
            const bSize = this.ctx.sampleRate * 2;
            this.noiseBuf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const out = this.noiseBuf.getChannelData(0);
            for (let i = 0; i < bSize; i++) {
                // æ··åˆç™½å™ªéŸ³å’Œç²‰çº¢å™ªéŸ³ï¼Œè´¨æ„Ÿæ›´å¥½
                const white = Math.random() * 2 - 1;
                out[i] = (lastOut + (0.02 * white)) / 1.02; // ç®€å•çš„ä½é€šæ»¤æ³¢æ¨¡æ‹Ÿç²‰çº¢å™ªéŸ³
                lastOut = out[i];
                out[i] *= 3.5; // è¡¥å¿éŸ³é‡
            }
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    
    updateVols() {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        this.nodes.master.gain.setTargetAtTime(this.vol.master, t, 0.1);
        this.nodes.bgm.gain.setTargetAtTime(this.vol.bgm, t, 0.1);
        this.nodes.train.gain.setTargetAtTime(this.vol.train, t, 0.1);
        this.nodes.fw.gain.setTargetAtTime(this.vol.firework, t, 0.1);
    }

    // ğŸµ BGM: ç»å¯¹æ ‡å‡†ç‰ˆã€ŠJingle Bellsã€‹ (ä¸»æ­Œ+å‰¯æ­Œå®Œæ•´å¾ªç¯)
    playBGM() {
        if(!this.ctx || this.isBgmPlaying) return;
        this.isBgmPlaying = true;
        
        // æ ‡å‡†éŸ³é«˜ (Cå¤§è°ƒ)
        const N = { 
            G3:196, A3:220, B3:247, 
            C4:262, D4:294, E4:330, F4:349, G4:392, A4:440, B4:494, 
            C5:523, D5:587, E5:659 
        };
        
        // åŸºç¡€æ‹é€Ÿ (BPM çº¦ 100)
        const Q = 500;  // å››åˆ†éŸ³ç¬¦ (1æ‹)
        const H = 1000; // äºŒåˆ†éŸ³ç¬¦ (2æ‹)
        const W = 2000; // å…¨éŸ³ç¬¦ (4æ‹)
        
        const melody = [
            // === ä¸»æ­Œ Verse (Dashing through the snow) ===
            // 1. Dashing through the snow
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 2. In a one horse open sleigh
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 3. O'er the fields we go
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.B3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 4. Laughing all the way
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:H}, {n:0,d:Q}, {n:0,d:Q},
            
            // 5. Bells on bobtail ring
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 6. Making spirits bright
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 7. What fun it is to ride and sing
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q},
            // 8. A sleighing song tonight
            {n:N.A4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:H}, {n:N.G4,d:H}, // æœ€åG4æ˜¯è¿‡æ¸¡

            // === å‰¯æ­Œ Chorus (Jingle Bells) ===
            // 9. Jingle bells, jingle bells
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 10. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 11. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 12. In a one horse open sleigh
            {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:H}, {n:N.G4,d:H},

            // 13. Jingle bells, jingle bells (Repeat)
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 14. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 15. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 16. In a one horse open sleigh! (Ending)
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:W}, {n:0,d:W}
        ];

        let idx = 0;
        const playNext = () => {
            if(!this.isBgmPlaying) return;
            const note = melody[idx];
            if(note.n > 0) {
                const t = this.ctx.currentTime, dur = note.d/1000;
                
                // ğŸ¹ éŸ³è‰²æ ¸å¿ƒï¼šé«˜é¢‘æ³›éŸ³å åŠ 
                const playLayer = (freq, type, vol, decay) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = type;
                    osc.frequency.value = freq;
                    const gain = this.ctx.createGain();
                    gain.connect(this.nodes.bgm);
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(vol, t + 0.01); // æå¿«èµ·éŸ³
                    gain.gain.exponentialRampToValueAtTime(0.001, t + decay);
                    osc.start(t); osc.stop(t + decay + 0.1);
                };

                // 1. åŸºéŸ³ (Sine) - æ¸©æš–çš„ä¸»ä½“
                playLayer(note.n, 'sine', 0.4, dur * 1.5);
                // 2. äºŒæ¬¡è°æ³¢ (Sine) - å¢åŠ åšåº¦
                playLayer(note.n * 2, 'sine', 0.2, dur * 1.2);
                // 3. æ•²å‡»å£° (Triangle) - ç¬é—´çš„é«˜é¢‘ï¼Œæ¨¡æ‹Ÿæ•²å‡»é‡‘å±ç‰‡
                playLayer(note.n * 4, 'triangle', 0.05, 0.1); 
                // 4. ç©ºçµæ„Ÿ (Detuned Sine)
                playLayer(note.n + 5, 'sine', 0.1, dur);
            }
            this.bgmTimer = setTimeout(playNext, note.d);
            idx = (idx + 1) % melody.length;
        };
        playNext();
    }
    
    stopBGM() { this.isBgmPlaying = false; clearTimeout(this.bgmTimer); }

    // ğŸš‚ è’¸æ±½é¸£ç¬› (å¸¦ADSRåŒ…ç»œï¼Œè§£å†³çªç„¶æ¶ˆå¤±çš„é—®é¢˜)
    whistle() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const g = this.ctx.createGain();
        g.connect(this.nodes.train);

        // 1. åŒéŸ³è°ƒ (æ¨¡æ‹Ÿèµ°éŸ³çš„é“œç®¡)
        const freqs = [350, 420]; 
        freqs.forEach(f => {
            const o = this.ctx.createOscillator(); 
            o.type = 'sawtooth'; 
            // ä½é€šæ»¤æ³¢è®©å£°éŸ³å˜æš–
            const lpf = this.ctx.createBiquadFilter();
            lpf.type = 'lowpass'; lpf.frequency.value = 1000;
            o.connect(lpf); lpf.connect(g);
            o.frequency.setValueAtTime(f, t);
            o.frequency.linearRampToValueAtTime(f + 5, t + 0.5); // æ°”å‹ä¸Šå‡å¯¼è‡´çš„éŸ³é«˜å¾®å‡
            o.start(t); o.stop(t + 2.5);
        });

        // 2. æ°”æµå™ªéŸ³ (æ¨¡æ‹Ÿå–·æ°”å£°)
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        const nFilter = this.ctx.createBiquadFilter();
        nFilter.type = 'bandpass'; nFilter.frequency.value = 700;
        const nGain = this.ctx.createGain(); nGain.gain.value = 0.5;
        noise.connect(nFilter); nFilter.connect(nGain); nGain.connect(g);
        noise.start(t); noise.stop(t + 2.5);

        // 3. å…³é”®ï¼šéŸ³é‡åŒ…ç»œ (æ·¡å…¥æ·¡å‡º)
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.8, t + 0.3); // 0.3ç§’æ·¡å…¥ (æ°”å‹å»ºç«‹)
        g.gain.setValueAtTime(0.8, t + 1.5); // ä¿æŒ
        g.gain.exponentialRampToValueAtTime(0.001, t + 2.5); // 1ç§’é•¿å°¾éŸ³æ·¡å‡º
    }

    // ğŸš‚ è¡Œé©¶å£° (èŠ‚å¥éšé€Ÿåº¦å˜åŒ–)
    chug(speed) { // æ³¨æ„ï¼šå»æ‰ max å‚æ•°ï¼Œä¸éœ€è¦å®ƒäº†
        if (!this.ctx || speed < 0.001) return;
        const t = this.ctx.currentTime;
        
        // ç®—æ³•ä¿®æ­£ï¼šé€Ÿåº¦è¶Šå¿«ï¼Œé—´éš”è¶Šå° (åæ¯”å…³ç³»)
        // 0.05(æ…¢é€Ÿ) -> é—´éš” 0.3s
        // 0.30(å¿«é€Ÿ) -> é—´éš” 0.1s
        // é™åˆ¶æœ€å°é—´éš” 0.08sï¼Œé˜²æ­¢å¿«æˆç”µæµå£°
        const interval = Math.max(0.08, 1.0 / (speed * 45)); 
        
        if (t >= this.nextChug) {
            this.nextChug = t + interval;
            const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuf;
            
            // é€Ÿåº¦è¶Šå¿«ï¼Œå£°éŸ³è¶Šè„† (Filteré¢‘ç‡å‡é«˜)
            const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; 
            f.frequency.value = 200 + speed * 2500; // åŸºäºç»å¯¹é€Ÿåº¦

            const g = this.ctx.createGain();
            // éŸ³é‡ä¹ŸåŸºäºç»å¯¹é€Ÿåº¦
            const vol = 0.2 + speed * 1.5; 
            g.gain.setValueAtTime(vol, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.1); 

            src.connect(f); f.connect(g); g.connect(this.nodes.train);
            src.start(t); src.stop(t + 0.15);
        }
    }

    // ğŸ† çƒŸèŠ±çˆ†ç‚¸ (3ç§éšæœºç±»å‹)
    explode() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const rnd = Math.random();
        
        const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuf;
        const f = this.ctx.createBiquadFilter(); 
        const g = this.ctx.createGain();
        
        // éšæœºéŸ³é«˜å¾®è°ƒ
        const detune = (Math.random() - 0.5) * 200;

        if(rnd < 0.33) {
            // A. æ²‰é—·å·¨å“ (Boom)
            f.type = 'lowpass'; f.frequency.value = 200 + detune;
            g.gain.setValueAtTime(3.0, t); 
            g.gain.exponentialRampToValueAtTime(0.01, t + 1.5); // é•¿å°¾
        } else if (rnd < 0.66) {
            // B. æ¸…è„†ç‚¸è£‚ (Crack)
            f.type = 'highpass'; f.frequency.value = 800 + detune;
            g.gain.setValueAtTime(1.5, t); 
            g.gain.exponentialRampToValueAtTime(0.01, t + 0.4); // çŸ­ä¿ƒ
        } else {
            // C. æ ‡å‡†çˆ†ç‚¸ (Standard)
            f.type = 'lowpass'; f.frequency.setValueAtTime(800, t); 
            f.frequency.linearRampToValueAtTime(50, t + 0.5); // æ‰«é¢‘
            g.gain.setValueAtTime(2.0, t); 
            g.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
        }
        
        src.connect(f); f.connect(g); g.connect(this.nodes.fw);
        src.start(t); src.stop(t + 1.6);
    }
}
let lastOut = 0; // è¾…åŠ©å˜é‡
const audio = new AudioEngine();

// ============================
// âš™ï¸ å…¨å±€é…ç½® & çŠ¶æ€
// ============================
// 1. ä¿®æ”¹ CFG é…ç½® (è°ƒä½é›¾æµ“åº¦ï¼Œè°ƒæ•´Bloom)
const CFG = {
    // ğŸš‚ ç‰©ç†
    maxSpeed: 0.22, accel: 0.005, decel: 0.003, wheelMult: 2.0, carriageGap: 0.009,
    
    // ğŸ¥ ç›¸æœº
    camHeight: 20, camSmooth: 0.04,
    
    // ğŸ’¡ è§†è§‰ä¿®æ­£
    moonInt: 2.5, 
    // [ä¿®å¤] é›¾æ°”ææ·¡ï¼Œé…åˆé»‘è‰²èƒŒæ™¯
    fogDen: 0.0004, 
    
    // [ä¿®å¤] é˜ˆå€¼è®¾ä¸º 0.05 (ç¨ç¨æŠ¬é«˜ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢èƒŒæ™¯åº•å™ªå‘å…‰)ï¼Œå¼ºåº¦é€‚ä¸­
    bloomStr: 0.7,  
    bloomThr: 0.02, 
    
    lightPow: 100, bulbBri: 30,
    autoFw: false, fwRate: 5
};

const STATE = {
    started: false,
    viewMode: 'FOLLOW', // FOLLOW | FREE
    settings: false,
    interacting: false, // ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨
    running: true, // ç›®æ ‡çŠ¶æ€ï¼šæ˜¯å¦åº”è¯¥è·‘
    curSpeed: 0,   // å½“å‰å®é™…ç‰©ç†é€Ÿåº¦
    clickTime: 0
};

let scene, camera, renderer, composer, controls, gui;
let train, fwMgr, snowMgr, trackCurve;
let lights={}, bloomPass;
let ground, trackPoints=[];
let autoTimer=null;
const clock = new THREE.Clock();
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const vec3 = new THREE.Vector3();
const emissives = []; // ç”¨äºç»Ÿä¸€è°ƒå…‰

// ============================
// ğŸš€ åˆå§‹åŒ–ä¸å¾ªç¯
// ============================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
    scene.fog = new THREE.FogExp2(0x000000, CFG.fogDen);

    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 4000);
    camera.position.set(0, 150, 150);

    // [å…¼å®¹æ€§] 1. å¼ºåˆ¶å…³é—­æŠ—é”¯é½¿ï¼Œé™ä½æ˜¾å­˜æ¶ˆè€—
    renderer = new THREE.WebGLRenderer({
        antialias: false, 
        powerPreference: "high-performance",
        depth: true,
        stencil: false // å…³é—­æ¨¡æ¿ç¼“å†²ï¼Œçœæ˜¾å­˜
    });
    renderer.setSize(innerWidth, innerHeight);
    
    // [æ€§èƒ½] 2. é”æ­»åƒç´ æ¯”ã€‚é«˜åˆ†å±æ‰‹æœºæ¸²æŸ“å‹åŠ›å¤ªå¤§ï¼Œé™åˆ¶åœ¨ 1.5 è¶³å¤Ÿæ¸…æ™°ä¸”æµç•…
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    buildLights();
    buildTrack();
    buildEnv();

    // [å…¼å®¹æ€§] 3. ä½¿ç”¨ UnsignedByteType æ›¿ä»£ HalfFloatType
    // å¾ˆå¤šè€å®‰å“æœºä¸æ”¯æŒæµ®ç‚¹çº¹ç†ï¼Œè¿™æ˜¯å¯¼è‡´é»‘å±çš„å…ƒå‡¶
    const rt = new THREE.WebGLRenderTarget(
        innerWidth * renderer.getPixelRatio(),
        innerHeight * renderer.getPixelRatio(),
        { 
            type: THREE.UnsignedByteType, // æ ‡å‡†æ ¼å¼ï¼Œå…¼å®¹æ€§ 100%
            stencilBuffer: false,
            depthBuffer: true
        }
    );

    const rp = new RenderPass(scene, camera);
    bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = CFG.bloomThr; 
    bloomPass.strength = CFG.bloomStr; 
    bloomPass.radius = 0.5;

    composer = new EffectComposer(renderer, rt);
    composer.addPass(rp);
    composer.addPass(bloomPass);

    train = new Train(scene, trackCurve);
    fwMgr = new Fireworks(scene);
    snowMgr = new Snow(scene);

    setupControls();
    setupUI();
    
    document.getElementById('loading').style.display='none';
    animate();
}

// ============================
// animate å‡½æ•° (æ”¯æŒ Instanced LED é—ªçƒ)
// ============================
function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    if(STATE.running) { if(STATE.curSpeed < CFG.maxSpeed) STATE.curSpeed += CFG.accel; } 
    else { if(STATE.curSpeed > 0) STATE.curSpeed -= CFG.decel; if(STATE.curSpeed < 0) STATE.curSpeed = 0; }

    if(train) train.update(dt, STATE.curSpeed);
    if(fwMgr) fwMgr.update();
    if(snowMgr) snowMgr.update(dt);

    // ğŸŒŸ ç¯å…‰åŠ¨ç”»
    emissives.forEach(obj => {
        // [LED Instanced]
        if(obj.userData.type === 'led_instanced') {
            const data = obj.userData.data;
            const tempCol = new THREE.Color();
            
            for(let i=0; i<obj.count; i++) {
                const item = data[i];
                const val = Math.sin(time * item.speed + item.offset);
                // [ä¼˜åŒ–] äº®åº¦èŒƒå›´ï¼š0.5 ~ 3.0 (HDR)
                // æé«˜ä¸Šé™ï¼Œè®© Bloom ç‚¸å¼€ï¼Œæ¨¡æ‹Ÿâ€œç…§äº®å‘¨å›´â€çš„è§†è§‰å‡è±¡
                const intensity = 0.5 + 1.25 * (val + 1); 
                
                tempCol.copy(item.baseCol).multiplyScalar(intensity);
                obj.setColorAt(i, tempCol);
            }
            if(obj.instanceColor) obj.instanceColor.needsUpdate = true;
        }

        // [æ™®é€šç¯æ³¡] (è·¯ç¯ç­‰)
        if(obj.userData.type === 'bulb') {
            if(obj.userData.baseCol) {
                const blink = 0.6 + 0.4 * Math.sin(time * 3.0 + obj.userData.phase);
                const intensity = 1.0 + blink * (CFG.bulbBri / 8); 
                obj.material.color.copy(obj.userData.baseCol).multiplyScalar(intensity);
            }
        }
        
        // [æ˜Ÿæ˜Ÿ]
        if(obj.userData.type === 'star') {
            // é‡‘è‰² -> ç™½é‡‘è‰² å‘¼å¸
            obj.material.color.setHSL(0.14, 1.0, 0.5 + 0.4 * Math.sin(time * 1.5));
        }
        
        if(obj.userData.type === 'headlight') { 
             obj.material.color.setHex(0xffdd88).multiplyScalar(CFG.lightPow/30);
        }
        if(obj.userData.type === 'headlight_spot') {
            obj.intensity = CFG.lightPow;
        }
    });

    if(STATE.started && train && train.loco) {
        const locoPos = train.loco.position;
        controls.target.copy(locoPos);
        if(STATE.viewMode === 'FOLLOW' && STATE.curSpeed > 0.001 && !STATE.interacting) {
            const dist = camera.position.distanceTo(locoPos);
            const back = new THREE.Vector3(0,0,-1).applyQuaternion(train.loco.quaternion).normalize();
            const ideal = locoPos.clone().add(back.multiplyScalar(dist)).add(new THREE.Vector3(0, CFG.camHeight, 0));
            camera.position.lerp(ideal, CFG.camSmooth);
        }
    }

    controls.update();
    composer.render();
}

// ============================
// ğŸŒ ä¸–ç•Œæ„å»º
// ============================
function buildLights() {
    const moon = new THREE.DirectionalLight(0xaaccff, CFG.moonInt);
    moon.position.set(-80, 150, -80);
    moon.castShadow=true; 
    moon.shadow.mapSize.set(2048,2048);
    moon.shadow.camera.left=-400; moon.shadow.camera.right=400;
    moon.shadow.camera.top=400; moon.shadow.camera.bottom=-400;
    scene.add(moon); lights.moon = moon;

    // æœˆäº®å®ä½“
    const mMesh = new THREE.Mesh(new THREE.SphereGeometry(15,32,32), new THREE.MeshBasicMaterial({color:0xffffee, fog:false}));
    mMesh.position.copy(moon.position).normalize().multiplyScalar(900);
    scene.add(mMesh);

    // æ˜Ÿç©º
    const sg = new THREE.BufferGeometry();
    const sp = [];
    for(let i=0;i<3000;i++) {
        const r=800+Math.random()*200;
        const th=Math.random()*Math.PI*2;
        const ph=Math.acos(2*Math.random()-1);
        if(Math.cos(ph)<0) continue; // åªåœ¨å¤©ä¸Š
        sp.push(r*Math.sin(ph)*Math.cos(th), Math.abs(r*Math.cos(ph)), r*Math.sin(ph)*Math.sin(th));
    }
    sg.setAttribute('position', new THREE.Float32BufferAttribute(sp,3));
    scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff, size:1.5, transparent:true, opacity:0.8, fog:false})));

    scene.add(new THREE.AmbientLight(0x303050, 0.4));
    
    // åœ°é¢
    ground = new THREE.Mesh(new THREE.CircleGeometry(1000,64), new THREE.MeshStandardMaterial({color:0x8899aa, roughness:1, metalness:0.1}));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow=true;
    scene.add(ground);
}

function buildTrack() {
    // å¤æ‚é—­åˆè½¨é“
    const s = 1.5; 
    const pts = [
        new THREE.Vector3(10*s, 0, 20*s), new THREE.Vector3(50*s, 2, 50*s), new THREE.Vector3(90*s, 0, 0),
        new THREE.Vector3(50*s, 0, -50*s), new THREE.Vector3(10*s, 0, -20*s), new THREE.Vector3(-20*s, 0, -20*s),
        new THREE.Vector3(-50*s, 3, -70*s), new THREE.Vector3(-90*s, 0, -50*s), new THREE.Vector3(-60*s, 0, -10*s),
        new THREE.Vector3(-60*s, 0, 10*s), new THREE.Vector3(-90*s, 0, 50*s), new THREE.Vector3(-50*s, 3, 70*s),
        new THREE.Vector3(-20*s, 0, 20*s), new THREE.Vector3(0, 0, 0)
    ];
    trackCurve = new THREE.CatmullRomCurve3(pts, true, 'catmullrom', 0.5);
    trackPoints = trackCurve.getPoints(600);

    const divs = 900;
    // è·¯åŸº
    const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 4.2, 8, true), new THREE.MeshStandardMaterial({color:0x080808, roughness:1}));
    bed.position.y=-0.2; bed.scale.y=0.1; scene.add(bed);
    
    // æ•æœ¨
    const pg = new THREE.BoxGeometry(6, 0.3, 1.2);
    const pm = new THREE.MeshStandardMaterial({color:0x3e2723});
    const pi = new THREE.InstancedMesh(pg, pm, divs);
    const dum = new THREE.Object3D();
    for(let i=0;i<divs;i++){
        const t=i/divs; const p=trackCurve.getPointAt(t); const tan=trackCurve.getTangentAt(t);
        dum.position.copy(p); dum.lookAt(p.clone().add(tan)); dum.updateMatrix();
        pi.setMatrixAt(i, dum.matrix);
    }
    pi.receiveShadow=true; scene.add(pi);

    // åŒé“è½¨ (Visual Hack)
    const rm = new THREE.MeshStandardMaterial({color:0x666666, metalness:0.8, roughness:0.3});
    const trL = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 0.15, 6, true), rm); trL.position.y=0.35; 
    // å³è½¨ç”¨ä¸€ä¸ªå®½æ‰ç®¡æ¨¡æ‹Ÿ
    const trFlat = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 2.4, 3, true), new THREE.MeshStandardMaterial({color:0x444444, metalness:0.7, roughness:0.4}));
    trFlat.scale.y=0.04; trFlat.position.y=0.32; scene.add(trFlat);
}

function buildEnv() {
    // è‹±é›„æ ‘ (ä¿æŒä¸å˜)
    createHeroTree(60, 0, 2.5); createHeroTree(-70, 50, 1.2); createHeroTree(-70, -50, 1.4);

    // ğŸŒ² å‡çº§ç‰ˆæ£®æ—ï¼šåˆå¹¶å‡ ä½•ä½“åˆ¶ä½œå±‚çº§æ¾æ ‘
    const treeGeo = new THREE.BufferGeometry();
    
    // åˆ›å»ºä¸‰å±‚æ ‘å¶
    const c1 = new THREE.ConeGeometry(3, 5, 8); c1.translate(0, 2.5, 0); // åº•å±‚
    const c2 = new THREE.ConeGeometry(2.2, 4, 8); c2.translate(0, 5.5, 0); // ä¸­å±‚
    const c3 = new THREE.ConeGeometry(1.5, 3, 8); c3.translate(0, 8.0, 0); // é¡¶å±‚
    
    // *æ³¨æ„*ï¼šä¸ºäº†ç®€ä¾¿åˆå¹¶ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨ BufferGeometryUtils çš„é€»è¾‘ç®€åŒ–ç‰ˆï¼Œæˆ–è€…ç›´æ¥æ‰‹åŠ¨åˆå¹¶
    // ä¸ºäº†ä¸å¼•å…¥æ–°åº“ï¼Œæˆ‘ä»¬åªç”¨ Instance æ¸²æŸ“æœ€ä¸»è¦çš„ä¸€å±‚ï¼Œæˆ–è€…æˆ‘ä»¬ç®€å•ç‚¹ï¼š
    // ä½¿ç”¨ä¸€ä¸ªå½¢çŠ¶æ›´å¥½çš„ Geometry: 
    // ç›´æ¥ç”¨ä¸€ä¸ªé«˜åœ†é”¥æ¨¡æ‹Ÿï¼Œæˆ–è€…... è¿˜æ˜¯ç”¨åœ†é”¥å§ï¼Œä½†æ˜¯è°ƒå¥½æ¯”ä¾‹
    // æ›´å¥½çš„æ–¹æ¡ˆï¼šæˆ‘ä»¬åˆ›å»º 3 ä¸ª InstancedMesh åˆ†åˆ«å¯¹åº”æ ‘çš„ä¸‹ä¸­ä¸Šå±‚ï¼Œè¿™æ ·é€ å‹æœ€å¥½
    
    const matTree = new THREE.MeshStandardMaterial({color:0x0f3315, roughness:0.9});
    const matSnow = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.6}); // æ ‘é¡¶é›ª
    
    const count = 700; // å‡å°‘æ•°é‡ï¼Œé¿å…å¤ªå¯†
    
    // æˆ‘ä»¬ç”¨ä¸‰ä¸ª Mesh æ‹¼æˆä¸€æ£µæ ‘
    const meshBot = new THREE.InstancedMesh(new THREE.ConeGeometry(3.5, 5, 7), matTree, count);
    const meshMid = new THREE.InstancedMesh(new THREE.ConeGeometry(2.5, 4, 7), matTree, count);
    const meshTop = new THREE.InstancedMesh(new THREE.ConeGeometry(1.5, 3, 7), matSnow, count); // é¡¶å±‚åšæˆé›ª
    
    meshBot.castShadow=true; meshBot.receiveShadow=true;
    meshMid.castShadow=true; meshMid.receiveShadow=true;
    
    const dummy = new THREE.Object3D();
    let idx = 0;
    
    for(let i=0; i<3000; i++) {
        if(idx >= count) break;
        
        // èŒƒå›´æ‰©å¤§
        const r = 60 + Math.random()*380;
        const a = Math.random()*6.28;
        const x = Math.cos(a)*r, z = Math.sin(a)*r;
        
        // é¿éšœæ£€æµ‹
        let safe=true;
        const distSq = 25*25; // åŠ å¤§å®‰å…¨è·ç¦»
        for(let k=0; k<trackPoints.length; k+=10) { // é™ä½é‡‡æ ·é¢‘ç‡ä¼˜åŒ–æ€§èƒ½
            const dx = trackPoints[k].x - x, dz = trackPoints[k].z - z;
            if((dx*dx + dz*dz) < distSq) { safe=false; break; }
        }

        if(safe) {
            // ğŸŒ² éšæœºå¤§å°ï¼š0.6 åˆ° 2.2 å€ï¼Œå·®å¼‚åŒ–å·¨å¤§
            const s = 0.6 + Math.random() * 1.6; 
            
            // éšæœºæ—‹è½¬
            const rotY = Math.random() * Math.PI;
            
            // åº•å±‚
            dummy.position.set(x, 2.5*s, z); 
            dummy.scale.set(s,s,s); 
            dummy.rotation.y = rotY; 
            dummy.updateMatrix();
            meshBot.setMatrixAt(idx, dummy.matrix);
            
            // ä¸­å±‚
            dummy.position.set(x, 5.5*s, z); 
            dummy.scale.set(s,s,s); 
            dummy.updateMatrix();
            meshMid.setMatrixAt(idx, dummy.matrix);
            
            // é¡¶å±‚(é›ª)
            dummy.position.set(x, 8.0*s, z); 
            dummy.scale.set(s,s,s); 
            dummy.updateMatrix();
            meshTop.setMatrixAt(idx, dummy.matrix);
            
            idx++;
        }
    }
    
    scene.add(meshBot);
    scene.add(meshMid);
    scene.add(meshTop);

    // è£…é¥°å“
    for(let i=0; i<30; i++){
        const x=(Math.random()-0.5)*350, z=(Math.random()-0.5)*350;
        let safe=true; 
        for(let k=0;k<trackPoints.length;k+=10) {
            const dx=trackPoints[k].x-x, dz=trackPoints[k].z-z;
            if((dx*dx+dz*dz)<400) { safe=false; break; }
        }
        if(safe) {
            const r=Math.random();
            if(r<0.3) createGift(x,z);
            else if(r<0.6) createSnowman(x,z);
            else createLamp(x,z);
        }
    }
}

// ============================
// createHeroTree (éšæœºå¸ƒçº¿ + ç¯å¢ƒå…‰ç…§ + å®Œç¾æ˜Ÿæ˜Ÿ)
// ============================
function createHeroTree(x, z, scale) {
    const g = new THREE.Group(); 
    g.position.set(x, 0, z); 
    g.scale.set(scale, scale, scale);

    // 1. æ ‘å¹²
    const matTrunk = new THREE.MeshStandardMaterial({ color: 0x4a2e16, roughness: 1.0 });
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(3, 5, 15, 8), matTrunk);
    trunk.position.y = 6; 
    g.add(trunk);

    // 2. æ ‘å¶
    const matFoliage = new THREE.MeshStandardMaterial({ color: 0x0f5515, roughness: 0.8, flatShading: true });

    // è£…é¥°æè´¨
    const matRed = new THREE.MeshStandardMaterial({ color: 0xe60000, roughness: 0.3 });
    const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 });
    const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
    const matSilver = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.3 });
    const bulbCols = [0xff0000, 0x00ff00, 0x0088ff, 0xffd700, 0xff00ff];

    // è¾…åŠ©ç”Ÿæˆå™¨
    const createCandyCane = () => {
        const cane = new THREE.Group();
        const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.2, 6), matWhite);
        stick.position.y = 0.6;
        const hook = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.15, 4, 8, Math.PI), matRed);
        hook.position.y = 1.2; hook.position.x = 0.35; hook.rotation.z = Math.PI/2;
        for(let i=0; i<3; i++) {
            const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.16, 0.02, 4, 6), matRed);
            stripe.position.y = 0.3 + i*0.4; stripe.rotation.x = Math.PI/2; cane.add(stripe);
        }
        cane.add(stick, hook);
        cane.scale.set(1.2, 1.2, 1.2);
        return cane;
    };
    const createMiniGift = () => {
        const boxG = new THREE.Group();
        const color = Math.random() > 0.5 ? matRed : matGold;
        const box = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), color);
        const r1 = new THREE.Mesh(new THREE.BoxGeometry(1.02, 1.02, 0.25), matWhite);
        const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.02, 1.02), matWhite);
        boxG.add(box, r1, r2);
        return boxG;
    };

    const tiers = [
        { r: 24, h: 16, y: 14 }, { r: 20, h: 15, y: 24 },
        { r: 16, h: 14, y: 34 }, { r: 11, h: 12, y: 43 },
        { r: 6,  h: 10, y: 51 }
    ];
    let treeTopY = 0;

    tiers.forEach((tier, index) => {
        const geo = new THREE.ConeGeometry(tier.r, tier.h, 8);
        const mesh = new THREE.Mesh(geo, matFoliage);
        mesh.position.y = tier.y;
        mesh.rotation.y = (index % 2) * (Math.PI / 8); 
        mesh.castShadow = true; mesh.receiveShadow = true;
        g.add(mesh);
        treeTopY = tier.y + tier.h / 2;

        // --- è£…é¥°å“ï¼šå†…æ”¶åœ¨è¡¨é¢ ---
        const decorCount = Math.floor(tier.r * 0.8) + 2; 
        for (let k = 0; k < decorCount; k++) {
            const angle = Math.random() * Math.PI * 2;
            const v = 0.1 + Math.random() * 0.5; 
            const surfR = tier.r * (1 - v);
            const embed = 0.85 + Math.random() * 0.15; // ç¨å¾®å†…åµŒ
            
            const lx = Math.cos(angle) * surfR * embed;
            const lz = Math.sin(angle) * surfR * embed;
            const ly = -tier.h / 2 + v * tier.h;

            const type = Math.random();
            let decor;
            if (type < 0.4) {
                decor = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), Math.random()>.5?matRed:matGold);
                decor.position.set(lx, ly, lz);
            } else if (type < 0.7) {
                decor = createMiniGift();
                decor.position.set(lx, ly + 0.5, lz); 
                decor.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
            } else {
                decor = createCandyCane();
                decor.position.set(lx, ly, lz);
                decor.lookAt(0, ly, 0); 
                decor.rotateX(Math.PI/4);
            }
            mesh.add(decor);
        }
    });

    // --- ğŸŒŸ 3. å®ä½“ç”µçº¿ (éšæœºå¸ƒçº¿é€»è¾‘) ---
    const wirePoints = [];
    wirePoints.push(new THREE.Vector3(0, 2, 2)); // èµ·ç‚¹
    let currentAngle = 0;

    tiers.forEach((tier) => {
        // A. é’»å‡ºï¼šä»æ ‘å¹²å†…éƒ¨å»¶ä¼¸åˆ°è¡¨é¢
        const startH = tier.y - tier.h/2 + 2; // å±‚åº•éƒ¨åä¸Š
        // åˆå§‹åŠå¾„å°(æ ‘å¹²)ï¼Œç»“æŸåŠå¾„å¤§(è¡¨é¢)
        
        // B. ç›˜æ—‹ï¼š0.5 ~ 1.5 åœˆ
        const loops = 0.5 + Math.random() * 1.0; 
        const steps = 15; // ç»†åˆ†
        
        for(let s=0; s <= steps; s++) {
            const t = s / steps;
            
            // è§’åº¦æ¨è¿›
            const angleStep = (Math.PI * 2 * loops) / steps;
            currentAngle += angleStep;
            
            // é«˜åº¦ï¼šåœ¨å½“å‰å±‚çˆ¬å‡
            // åªçˆ¬åˆ° 70% é«˜åº¦ï¼Œç•™å‡ºé’»å›å»çš„ç©ºé—´
            const py = (tier.y - tier.h/2) + (tier.h * 0.7) * t;
            
            // åŠå¾„ï¼šä»è¡¨é¢ç¨å¾®æµ®èµ·
            const surfR = tier.r * (1 - t * 0.7); // éšé«˜åº¦å˜ç»†
            const r = surfR * 1.05 + Math.random(); // éšæœºæ¾å¼›
            
            const px = Math.cos(currentAngle) * r;
            const pz = Math.sin(currentAngle) * r;
            wirePoints.push(new THREE.Vector3(px, py, pz));
        }

        // C. é’»å›ï¼šå›åˆ°æ ‘å¹²é™„è¿‘ï¼Œå‡†å¤‡å»ä¸‹ä¸€å±‚
        const endH = tier.y + tier.h/2 - 1;
        wirePoints.push(new THREE.Vector3(2 * Math.cos(currentAngle), endH, 2 * Math.sin(currentAngle)));
    });
    // ç»ˆç‚¹
    wirePoints.push(new THREE.Vector3(0, treeTopY, 0));

    const curve = new THREE.CatmullRomCurve3(wirePoints);
    const tubeGeo = new THREE.TubeGeometry(curve, 300, 0.08, 6, false);
    const wireMesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }));
    g.add(wireMesh);

    // --- ğŸŒŸ 4. LED ç¯ç  (ç¨€ç–åˆ†å¸ƒ + å±€éƒ¨ç‚¹å…‰æº) ---
    const totalLength = curve.getLength();
    // [ä¼˜åŒ–] é™ä½é‡‡æ ·ç‡ï¼Œè®©ç¯ç æ›´ç¨€ç–
    const bulbCountRaw = Math.floor(totalLength * 1.8); 
    
    const bulbGeo = new THREE.SphereGeometry(0.45, 8, 8);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
    const ledMesh = new THREE.InstancedMesh(bulbGeo, bulbMat, bulbCountRaw);
    
    const dummy = new THREE.Object3D();
    const ledData = [];
    let realCount = 0;
    let clusterState = false; 
    let clusterCounter = 0;

    for(let i=0; i<bulbCountRaw; i++) {
        const t = i / bulbCountRaw;
        
        // [ä¼˜åŒ–] èšç±»é€»è¾‘ï¼šæœ‰ç¯çš„æ®µçŸ­ï¼Œæ²¡ç¯çš„æ®µé•¿
        if (clusterCounter <= 0) {
            clusterState = !clusterState;
            // æœ‰ç¯ï¼š4~8ä¸ªï¼Œæ— ç¯ï¼š8~20ä¸ª (æ›´ç¨€ç–)
            clusterCounter = clusterState ? Math.floor(Math.random() * 5 + 4) : Math.floor(Math.random() * 12 + 8);
        }
        clusterCounter--;
        if (!clusterState) continue;

        const pos = curve.getPointAt(t);
        // éšæœºåç§»
        pos.x += (Math.random()-0.5)*0.3;
        pos.y += (Math.random()-0.5)*0.3;
        pos.z += (Math.random()-0.5)*0.3;

        dummy.position.copy(pos);
        dummy.scale.setScalar(1.0);
        dummy.updateMatrix();
        ledMesh.setMatrixAt(realCount, dummy.matrix);
        
        const colHex = bulbCols[Math.floor(Math.random() * bulbCols.length)];
        const color = new THREE.Color(colHex);
        ledMesh.setColorAt(realCount, color);
        
        ledData.push({ id: realCount, baseCol: color, speed: 0.5 + Math.random() * 3.0, offset: Math.random() * 100 });
        realCount++;
    }
    
    ledMesh.count = realCount;
    ledMesh.instanceColor.needsUpdate = true;
    ledMesh.userData = { type: 'led_instanced', data: ledData };
    emissives.push(ledMesh);
    g.add(ledMesh);

    // [æ–°å¢] å†…éƒ¨ç¯å¢ƒå…‰ (æ¨¡æ‹Ÿç¯å¸¦ç…§äº®æ ‘å¶)
    // å¢åŠ å¼ºåº¦ (30 -> 150)ï¼Œå¢åŠ èŒƒå›´ (25 -> 40)
    // é¢œè‰²æ”¹ä¸ºæš–é‡‘è‰²ï¼Œè®©æ ‘å¶çœ‹èµ·æ¥æœ‰èŠ‚æ—¥æ°”æ°›
    for(let i=1; i<=4; i++) { // å¢åŠ åˆ° 4 ä¸ªå…‰æº
        const innerLight = new THREE.PointLight(0xffaa33, 150, 45); 
        // ç¨å¾®å¾€å¤–ç§»ä¸€ç‚¹ç‚¹ï¼Œä¸è¦å®Œå…¨åœ¨æ ‘å¹²ä¸­å¿ƒ
        innerLight.position.set(5 * Math.sin(i), i * 12, 5 * Math.cos(i)); 
        g.add(innerLight);
    }

    // --- ğŸŒŸ 5. æ ‘é¡¶æ˜Ÿæ˜Ÿ (ä¿®å¤ç‰ˆï¼šæ— ç¼ºå£) ---
    const starShape = new THREE.Shape();
    const pts = 5;
    const outerR = 4.2; 
    const innerR = 2.0; 
    // ä»æ­£ä¸Šæ–¹å¼€å§‹ç”» (Angle = -PI/2)
    for (let i = 0; i < pts * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const a = (i / 10) * Math.PI * 2 - Math.PI/2;
        if(i===0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    starShape.closePath();

    // å‡å° bevel é˜²æ­¢è‡ªç›¸äº¤ç¼ºå£
    const starGeo = new THREE.ExtrudeGeometry(starShape, { 
        depth: 1.0, 
        bevelEnabled: true, 
        bevelThickness: 0.1, 
        bevelSize: 0.1, 
        bevelSegments: 1 
    });
    starGeo.center();
    
    const star = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffeb3b, fog: false }));
    star.position.set(0, treeTopY + 3.5, 0);
    star.userData = { type: 'star' }; 
    emissives.push(star); 
    g.add(star);
    
    scene.add(g);
}

function createGift(x,z) {
    const b=new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({color:Math.random()*0xffffff}));
    b.position.set(x,0.75,z); b.rotation.y=Math.random(); b.castShadow=true; scene.add(b);
}
function createSnowman(x,z) {
    const g=new THREE.Group(); g.position.set(x,0,z);
    const m=new THREE.MeshStandardMaterial({color:0xffffff});
    const b1=new THREE.Mesh(new THREE.SphereGeometry(1.2), m); b1.position.y=1;
    const b2=new THREE.Mesh(new THREE.SphereGeometry(0.8), m); b2.position.y=2.5;
    g.add(b1,b2); scene.add(g);
}
function createLamp(x,z) {
    const g=new THREE.Group(); g.position.set(x,0,z);
    const p=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,7), new THREE.MeshStandardMaterial({color:0x111})); p.position.y=3.5;
    
    // [ä¿®å¤] ä½¿ç”¨ BasicMaterial + fog:falseï¼Œå¹¶å®šä¹‰ baseCol
    const col = 0xffaa00;
    const b=new THREE.Mesh(
        new THREE.SphereGeometry(0.5), 
        new THREE.MeshBasicMaterial({color:col, fog:false}) // å…³é”®ï¼šfog:false
    );
    b.position.y=7; 
    
    // [å…³é”®] å¿…é¡»å®šä¹‰ baseColï¼Œå¦åˆ™ animate ä¼šå´©æºƒ
    b.userData={type:'bulb', phase: Math.random()*Math.PI, baseCol: new THREE.Color(col)}; 
    
    emissives.push(b); g.add(p,b); scene.add(g);
}

// ============================
// ğŸš‚ ç«è½¦ç³»ç»Ÿ
// ============================
class Train {
    constructor(sc, curve) {
        this.grp=new THREE.Group(); sc.add(this.grp);
        this.curve=curve; this.prog=0; this.wheels=[]; this.smokes=[];
        
        // Glare
        const cv=document.createElement('canvas'); cv.width=64;cv.height=64;
        const cx=cv.getContext('2d'); const gr=cx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#fff'); gr.addColorStop(1,'transparent'); cx.fillStyle=gr; cx.fillRect(0,0,64,64);
        this.glare=new THREE.CanvasTexture(cv);

        this.loco=this.mkLoco(); this.grp.add(this.loco);
        this.cars=[]; for(let i=1;i<=12;i++) { const c=this.mkCar(i); this.grp.add(c); this.cars.push(c); }
        this.gap();
    }
    gap() { this.cars.forEach((c,i)=>c.userData.off=(i+1)*(0.0075+CFG.carriageGap*0.2)); }
    
    mkLoco() {
        const g=new THREE.Group();
        const red=new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.3});
        const blk=new THREE.MeshStandardMaterial({color:0x111});
        const boil=new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,5,16), red); boil.rotation.x=Math.PI/2; boil.position.set(0,3.6,1);
        const cab=new THREE.Mesh(new THREE.BoxGeometry(3.8,5.2,3.2), red); cab.position.set(0,4.1,-2.5);
        this.chim=new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.6,2.5), blk); this.chim.position.set(0,4.8,2.5);
        const cow=new THREE.Mesh(new THREE.ConeGeometry(2,1.5,4), blk); cow.rotation.set(-Math.PI/2,Math.PI/4,0); cow.scale.set(1,0.5,1); cow.position.set(0,1,4.5);
        
        const aw=(z,r)=>{
            const w=new THREE.Mesh(new THREE.CylinderGeometry(r,r,0.5,16).rotateZ(Math.PI/2), blk);
            w.position.set(1.9,r,z); const w2=w.clone(); w2.position.set(-1.9,r,z);
            g.add(w,w2); this.wheels.push(w,w2);
        };
        aw(0,1.3); aw(2.2,1.3); aw(-1.5,1.3); aw(4.0,0.8);
        
        const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:this.glare, color:0xffdd88, blending:THREE.AdditiveBlending}));
        sp.position.set(0,5.2,4); sp.scale.set(10,10,1);
        const sl=new THREE.SpotLight(0xffccaa, CFG.lightPow, 150, 0.8, 0.5);
        sl.position.set(0,5.2,3.8); sl.target.position.set(0,-5,30); sl.castShadow=true;
        sl.userData={type:'headlight'};
        g.add(boil,cab,this.chim,cow,sp,sl,sl.target);
        return g;
    }

    mkCar(i) {
        const g = new THREE.Group();
        // ç»å…¸çš„åœ£è¯ç‰¹å¿«é…è‰²ï¼šæ·±çº¢ã€å¢¨ç»¿ã€æµ·å†›è“
        const cols = [0x8b0000, 0x004d26, 0x003366, 0xb8860b];
        const col = cols[(i - 1) % 4];
        
        const matBody = new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.2 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 }); // é‡‘è‰²æè´¨
        const matRoof = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });

        // 1. è½¦èº«ä¸»ä½“
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.4, 3.8, 7.8), matBody);
        body.position.y = 3.3;
        
        // 2. é‡‘è‰²è£…é¥°è…°çº¿ (æ–°åŠ ç»†èŠ‚)
        const goldBand = new THREE.Mesh(new THREE.BoxGeometry(3.45, 0.2, 7.85), matGold);
        goldBand.position.y = 3.0; // ä½äºè½¦çª—ä¸‹æ–¹
        g.add(goldBand);
        
        // 3. è½¦é¡¶ (æ”¹ä¸ºç¨å¾®æ‰å¹³ä¸€ç‚¹çš„åœ†å¼§ï¼Œæ›´åƒç«è½¦ç«™)
        // ä½¿ç”¨ scale å‹æ‰åœ†æŸ±
        const roof = new THREE.Mesh(
            new THREE.CylinderGeometry(2.05, 2.05, 13, 13, 1, false, 0, Math.PI), 
            new THREE.MeshStandardMaterial({color:0x222, roughness:0.9}) // é»‘è‰²ç£¨ç ‚é¡¶
        );
        roof.rotation.set(0, Math.PI/2, Math.PI/2); 
        roof.scale.set(1, 0.65, 1); // ç¨å¾®å‹æ‰ä¸€ç‚¹ç‚¹ï¼Œæ›´åƒè½¦é¡¶
        roof.position.set(0, 5.1, 0); // ç¨å¾®æä¸€ç‚¹é«˜åº¦

        // [å·²åˆ é™¤] è½¦é¡¶ç¤¼ç‰©ç›’ç”Ÿæˆä»£ç 

        // 4. è½¦çª— (Basicæè´¨é˜²é®ç½©)
        const winGeo = new THREE.PlaneGeometry(1.3, 1.6);
        const winMat = new THREE.MeshBasicMaterial({ color: 0xffccaa, fog: false }); 
        
        for (let side = -1; side <= 1; side += 2) {
            for (let k = 0; k < 3; k++) {
                const w = new THREE.Mesh(winGeo, winMat);
                // çª—æˆ·å¸¦ä¸€ç‚¹é‡‘è‰²è¾¹æ¡†? è¿™é‡Œçš„ scale ç¨å¾®å¤§ä¸€ç‚¹åšè¾¹æ¡†
                const border = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 1.7), matGold);
                
                w.position.set(1.76 * side, 3.8, -2.5 + k * 2.5);
                w.rotation.y = side * Math.PI / 2;
                
                border.position.copy(w.position);
                border.position.x -= 0.01 * side; // å¾€é‡Œä¸€ç‚¹
                border.rotation.copy(w.rotation);
                
                g.add(border);
                g.add(w);
            }
        }

        // 5. è¿æ¥å¤„ & è½®å­ (ä¿æŒä¸å˜)
        const gw = new THREE.Mesh(new THREE.BoxGeometry(2.4, 2.8, 1.2), new THREE.MeshStandardMaterial({ color: 0x111 }));
        gw.position.set(0, 3, 4.2);

        const ab = z => {
            const gr = new THREE.Group(); gr.position.set(0, 0, z);
            const w = new THREE.Mesh(new THREE.CylinderGeometry(0.65, 0.65, 0.4, 12).rotateZ(Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x111 }));
            w.position.set(1.6, 0.65, 0);
            const w2 = w.clone(); w2.position.set(-1.6, 0.65, 0);
            gr.add(w, w2); g.add(gr); this.wheels.push(w, w2);
        };
        ab(2.8); ab(-2.8);

        g.add(body, roof, gw);
        return g;
    }

    update(dt, speed) {
        audio.chug(speed);
        
        const dist = speed * dt * 0.2;
        this.prog = (this.prog + dist) % 1;
        
        this.place(this.loco, this.prog);
        this.cars.forEach(c => {
            let t = this.prog - c.userData.off; if(t<0) t+=1;
            this.place(c, t);
        });
        
        this.wheels.forEach(w => w.rotation.x -= dist * 150 * CFG.wheelMult);

        // ğŸš‚ çƒŸé›¾ç”Ÿæˆé€»è¾‘ä¼˜åŒ–
        // 1. é€Ÿåº¦è¶Šå¿«ï¼Œå–·çƒŸé¢‘ç‡è¶Šé«˜
        // 2. å³ä½¿é™æ­¢ï¼Œä¹Ÿä¼šå¶å°”å†’ä¸€ç‚¹ç‚¹çƒŸ
        const smokeProb = speed > 0.01 ? (0.2 + speed * 2.5) : 0.02;
        
        if(Math.random() < smokeProb) {
            vec3.setFromMatrixPosition(this.chim.matrixWorld); 
            // ä¿®æ­£çƒŸé›¾å‡ºç”Ÿç‚¹é«˜åº¦ï¼Œç¨å¾®ä½ä¸€ç‚¹ï¼Œä»çƒŸå›±å£å†…éƒ¨å‡ºæ¥
            vec3.y += 0.4; 
            this.spawnSmoke(vec3, speed);
        }
        
        this.updateSmoke();
    }

    spawnSmoke(pos, trainSpeed) {
        // 1. å‡ ä½•ä½“ï¼šéšæœºå¤§å°
        const size = 0.3 + Math.random() * 0.3;
        const m = new THREE.Mesh(
            new THREE.IcosahedronGeometry(size, 0), 
            new THREE.MeshStandardMaterial({
                color: 0xdddddd, 
                transparent: true, 
                opacity: 0.8, // åˆå§‹ä¸é€æ˜åº¦é«˜
                depthWrite: false,
                roughness: 1
            })
        );
        m.position.copy(pos);
        m.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
        
        // 2. ç‰©ç†æ ¸å¿ƒï¼šè®¡ç®—åˆé€Ÿåº¦å‘é‡
        // è·å–ç«è½¦å½“å‰æœå‘ (Forward Vector)
        const trainDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.loco.quaternion).normalize();
        
        // A. å‚ç›´å–·å°„åŠ› (Burst): åŸºç¡€å–·å°„ + éšè½¦é€Ÿå¢åŠ çš„å‹åŠ›
        const upForce = 0.3 + Math.random() * 0.3 + (trainSpeed * 0.5);
        const upVel = new THREE.Vector3(0, 1, 0).multiplyScalar(upForce);
        
        // B. æ°´å¹³æƒ¯æ€§ (Inertia): çƒŸé›¾åˆšå‡ºæ¥æ—¶ï¼Œå¸¦æœ‰ç«è½¦çš„é€Ÿåº¦
        const forwardVel = trainDir.clone().multiplyScalar(trainSpeed * 1.5); // *1.5 æ˜¯ä¸ºäº†è®©è§†è§‰ä¸Šæ›´ç¬¦åˆâ€œå–·å‡ºâ€çš„æ„Ÿè§‰
        
        // åˆæˆåˆé€Ÿåº¦
        const velocity = upVel.add(forwardVel);

        // éšæœºæ‰°åŠ¨ (Turbulence)
        velocity.x += (Math.random() - 0.5) * 0.1;
        velocity.z += (Math.random() - 0.5) * 0.1;

        scene.add(m); 
        this.smokes.push({
            m, 
            vel: velocity, // å­˜å‚¨é€Ÿåº¦å‘é‡
            life: 1.0 + Math.random() * 0.5, // å¯¿å‘½
            initScale: size
        });
    }

    updateSmoke() {
        for(let i = this.smokes.length - 1; i >= 0; i--) {
            const s = this.smokes[i];
            
            // 1. è¿åŠ¨æ›´æ–°
            s.m.position.add(s.vel);
            
            // 2. ç‰©ç†æ¨¡æ‹Ÿ
            // ç©ºæ°”é˜»åŠ› (Drag): æ¨¡æ‹Ÿæ’å‡»ç©ºæ°”ï¼Œé€Ÿåº¦è¿…é€Ÿè¡°å‡
            // å°¤å…¶æ˜¯æ°´å¹³æ–¹å‘ï¼ŒçƒŸé›¾åº”è¯¥å¾ˆå¿«â€œåœâ€åœ¨åŸåœ°ï¼Œè¢«ç«è½¦ç”©åœ¨åé¢
            s.vel.multiplyScalar(0.92); 
            
            // æµ®åŠ› (Buoyancy): é€Ÿåº¦è¡°å‡åï¼Œçƒ­æ°”è‡ªç„¶ä¸Šå‡
            s.vel.y += 0.008; 

            // 3. è§†è§‰å˜åŒ–
            s.life -= 0.012; // è¡°å‡
            
            // è†¨èƒ€ (Expansion): çƒŸé›¾éšæ—¶é—´å˜å¤§
            const scale = s.initScale * (1 + (1.5 - s.life) * 3.0);
            s.m.scale.set(scale, scale, scale);
            
            // æ—‹è½¬
            s.m.rotation.x += 0.03;
            s.m.rotation.z += 0.01;
            
            // é€æ˜åº¦æ·¡å‡º
            s.m.material.opacity = s.life * 0.6;
            
            if(s.life <= 0) {
                scene.remove(s.m);
                this.smokes.splice(i, 1);
            }
        }
    }
    place(o, t) {
        const p=this.curve.getPointAt(t), tan=this.curve.getTangentAt(t);
        o.position.copy(p); o.lookAt(p.clone().add(tan));
    }
}

// ============================
// ğŸ† ç‰¹æ•ˆ
// ============================
class Fireworks {
    constructor(sc) {
        this.sc = sc; 
        this.r = []; // å‡ç©ºçš„ç«ç®­æ•°ç»„
        this.s = []; // ç‚¸å¼€çš„ç²’å­æ•°ç»„
        
        // çº¹ç† (ä¿æŒ 32x32 æé€Ÿç‰ˆ)
        const c = document.createElement('canvas'); c.width = 32; c.height = 32;
        const x = c.getContext('2d'); 
        const g = x.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent'); 
        x.fillStyle = g; x.fillRect(0,0,32,32);
        this.tex = new THREE.CanvasTexture(c);
        this.cols = [[0xff0000,0xffaa00],[0x00ffff,0x0000ff],[0xff00ff,0xffaaaa],[0x00ff00,0xffff00]];
    }

    launch(pos) {
        // [ğŸ›‘ æ ¸å¿ƒä¿®å¤] åŒå±æ•°é‡é™åˆ¶
        // å¦‚æœå½“å‰æ­£åœ¨é£çš„ç«ç®­ + æ­£åœ¨ç‚¸çš„çƒŸèŠ±æ€»æ•°è¶…è¿‡ 8 ä¸ªï¼Œ
        // ç›´æ¥å¿½ç•¥æœ¬æ¬¡å‘å°„è¯·æ±‚ã€‚è¿™èƒ½å½»åº•é˜²æ­¢å¡æ­»ã€‚
        if (this.r.length + this.s.length >= 8) return;

        // ä½ç½®è®¡ç®—
        if(!pos) {
            // è‡ªåŠ¨æ¨¡å¼ï¼šå›ºå®šåœ¨åœ°å›¾ä¸­å¿ƒåŒºåŸŸéšæœºï¼Œä¸è·Ÿéšç›¸æœº
            const range = 100;
            pos = new THREE.Vector3(
                (Math.random() - 0.5) * 2 * range, 
                -5, 
                (Math.random() - 0.5) * 2 * range
            );
        }
        
        const ty = pos.y + 60 + Math.random()*40;
        const pal = this.cols[Math.floor(Math.random()*this.cols.length)];
        
        // åˆ›å»ºç«ç®­ç²’å­
        const m = new THREE.Points(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]), 
            new THREE.PointsMaterial({color:0xffddaa, size:4, map:this.tex, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true})
        );
        m.position.copy(pos); 
        this.sc.add(m);
        
        this.r.push({
            m, pos: pos.clone(), 
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.sqrt(2*0.02*(ty-pos.y)), (Math.random()-0.5)*0.5), 
            pal
        });
    }

    update() {
        // æ›´æ–°ç«ç®­
        for(let i = this.r.length - 1; i >= 0; i--) {
            const r = this.r[i]; 
            r.pos.add(r.vel); 
            r.vel.y -= 0.02; 
            r.m.position.copy(r.pos);
            if(r.vel.y <= 0.5) { 
                this.sc.remove(r.m); 
                this.explode(r.pos, r.pal); 
                this.r.splice(i, 1); 
            }
        }
        
        // æ›´æ–°çˆ†ç‚¸ç²’å­
        for(let i = this.s.length - 1; i >= 0; i--) {
            const s = this.s[i]; 
            s.life -= 0.015;
            const p = s.geo.attributes.position.array;
            
            for(let k = 0; k < s.count; k++) {
                const idx = k * 3;
                p[idx] += s.vels[idx]; 
                p[idx+1] += s.vels[idx+1]; 
                p[idx+2] += s.vels[idx+2];
                s.vels[idx] *= 0.93; 
                s.vels[idx+1] *= 0.93; 
                s.vels[idx+2] *= 0.93; 
                s.vels[idx+1] -= 0.015;
            }
            s.geo.attributes.position.needsUpdate = true; 
            s.mat.opacity = s.life;
            if(s.l) s.l.intensity = s.life * 20;
            
            if(s.life <= 0) { 
                this.sc.remove(s.m); 
                if(s.l) this.sc.remove(s.l); 
                this.s.splice(i, 1); 
            }
        }
    }

    explode(pos, pal) {
        audio.explode();
        const cnt = 80; // ä¿æŒä½ç²’å­æ•°
        const posA = new Float32Array(cnt * 3); 
        const colA = new Float32Array(cnt * 3); 
        const vels = [];
        const c = new THREE.Color();

        for(let i = 0; i < cnt; i++) {
            posA[i*3] = pos.x; posA[i*3+1] = pos.y; posA[i*3+2] = pos.z;
            const speed = 0.5 + Math.random() * 2.8; 
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            vels.push(speed * Math.sin(phi) * Math.cos(theta), speed * Math.sin(phi) * Math.sin(theta), speed * Math.cos(phi));
            c.setHex(pal[Math.floor(Math.random() * pal.length)]); 
            colA[i*3] = c.r; colA[i*3+1] = c.g; colA[i*3+2] = c.b;
        }

        const geo = new THREE.BufferGeometry(); 
        geo.setAttribute('position', new THREE.BufferAttribute(posA, 3)); 
        geo.setAttribute('color', new THREE.BufferAttribute(colA, 3));
        const mat = new THREE.PointsMaterial({
            size: 3.5, map: this.tex, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true
        });
        
        const m = new THREE.Points(geo, mat); this.sc.add(m);
        const l = new THREE.PointLight(pal[0], 20, 60); l.position.copy(pos); this.sc.add(l);
        this.s.push({m, geo, mat, vels, l, count: cnt, life: 1.5});
    }
}

// ============================
// Snow (åŸºäºæ—¶é—´æ›´æ–°ï¼ŒåŒ€é€Ÿä¸‹è½ + å¾®é£å¹²æ‰°)
// ============================
class Snow {
    constructor(sc) {
        const count = 4000;
        const pos = [];
        // åˆå§‹åŒ–åˆ†å¸ƒï¼šYè½´èŒƒå›´æ‹‰å¤§åˆ° 600ï¼Œé˜²æ­¢é‡ç½®æ—¶å‡ºç°æ–­å±‚
        for(let i=0; i<count; i++) {
            pos.push(
                Math.random()*800-400, 
                Math.random()*600, // 0~600 é«˜åº¦
                Math.random()*800-400
            );
        }
        const g = new THREE.BufferGeometry(); 
        g.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        
        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); cx.fillStyle='#fff'; cx.beginPath(); cx.arc(16,16,16,0,Math.PI*2); cx.fill();
        
        this.m = new THREE.Points(g, new THREE.PointsMaterial({
            color: 0xeeeeee, 
            map: new THREE.CanvasTexture(cv), 
            transparent: true, 
            opacity: 0.8, 
            size: 0.8, 
            depthWrite: false, 
            blending: THREE.AdditiveBlending
        }));
        sc.add(this.m);
    }
    
    // æ¥æ”¶ dt å‚æ•°ï¼Œä¿è¯ä¸åŒå¸§ç‡ä¸‹é€Ÿåº¦ä¸€è‡´
    update(dt) {
        const p = this.m.geometry.attributes.position.array;
        const fallSpeed = 35.0; // æ¯ç§’ä¸‹è½å•ä½
        
        for(let i=1; i<p.length; i+=3) {
            // Yè½´ä¸‹è½
            p[i] -= fallSpeed * dt;
            
            // Xè½´å¾®é£æ‘‡æ‘† (æ¨¡æ‹Ÿé£˜é›ª)
            // åˆ©ç”¨é«˜åº¦ p[i] ä½œä¸ºå™ªå£°è¾“å…¥
            p[i-1] -= Math.sin(p[i] * 0.05) * 10 * dt;

            // å¾ªç¯é‡ç½®
            if(p[i] < 0) {
                p[i] = 600; 
                // é‡ç½®æ—¶éšæœºX/Zï¼Œé˜²æ­¢å½¢æˆæ˜æ˜¾çš„å¾ªç¯çº¹ç†
                // p[i-1] = Math.random()*800-400; // å¯é€‰ï¼šå¦‚æœè§‰å¾—é›ªå¤ªè§„å¾‹å¯ä»¥è§£å¼€è¿™è¡Œ
            }
        }
        this.m.geometry.attributes.position.needsUpdate = true;
    }
}

// ============================
// âš™ï¸ äº¤äº’æ§åˆ¶
// ============================
function setupControls() {
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 15; controls.maxDistance = 400;
    controls.addEventListener('start', () => STATE.interacting = true);
    controls.addEventListener('end', () => STATE.interacting = false);
}

// ============================
// setupUI å‡½æ•°
// ============================
function setupUI() {
    const btn = document.getElementById('start-btn');
    
    btn.onclick = () => {
        STATE.started = true;
        STATE.running = true;
        audio.init(); 
        audio.whistle(); 
        audio.playBGM(); 

        document.getElementById('start-screen').style.opacity = 0;
        setTimeout(() => document.getElementById('start-screen').style.display = 'none', 800);
        document.getElementById('hud').style.opacity = 1;
        document.getElementById('settings-btn').style.opacity = 1;

        // å¯åŠ¨è¿é•œ
        const start = camera.position.clone();
        const back = new THREE.Vector3(0, 0, -1).applyQuaternion(train.loco.quaternion).normalize();
        const end = train.loco.position.clone().add(back.multiplyScalar(40)).add(new THREE.Vector3(0, CFG.camHeight, 0));
        let t = 0;
        const iv = setInterval(() => {
            t += 0.015;
            if (t >= 1) { clearInterval(iv); STATE.viewMode = 'FOLLOW'; }
            else {
                const k = 1 - Math.pow(1 - t, 3);
                camera.position.lerpVectors(start, end, k);
                camera.lookAt(train.loco.position);
            }
        }, 16);
    };

    const set = document.getElementById('settings-btn'), mod = document.getElementById('settings-modal'), over = document.getElementById('modal-overlay');
    const tog = () => { STATE.settings = !STATE.settings; const d = STATE.settings ? 'block' : 'none'; mod.style.display = d; over.style.display = d; };
    set.onclick = tog; over.onclick = tog;

    gui = new GUI({ container: mod, width: '100%' });
    gui.title('ğŸ„ æ§åˆ¶ä¸­å¿ƒ');

    const fSound = gui.addFolder('ğŸ”Š éŸ³é¢‘è®¾ç½®');
    fSound.add(audio.vol, 'master', 0, 1).name('æ€»éŸ³é‡').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'bgm', 0, 1).name('èƒŒæ™¯éŸ³ä¹').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'train', 0, 1).name('ç«è½¦éŸ³æ•ˆ').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'firework', 0, 1).name('çƒŸèŠ±éŸ³æ•ˆ').onChange(() => audio.updateVols());

    const fCam = gui.addFolder('ğŸ¥ é•œå¤´ä¸ç‰©ç†');
    fCam.add(CFG, 'camHeight', 5, 40).name('è§†è§’é«˜åº¦');
    fCam.add(CFG, 'camSmooth', 0.01, 0.1).name('è·ŸéšæŸ”å’Œåº¦');
    fCam.add(CFG, 'maxSpeed', 0.1, 0.4).name('ç«è½¦æé€Ÿ');

    const fEnv = gui.addFolder('ğŸ’¡ ç¯å…‰ä¸ç¯å¢ƒ');
    fEnv.add(CFG, 'moonInt', 0, 5).name('æœˆå…‰äº®åº¦').onChange(v => lights.moon.intensity = v);
    fEnv.add(CFG, 'fogDen', 0, 0.005).name('å¤§é›¾æµ“åº¦').onChange(v => scene.fog.density = v);
    fEnv.add(CFG, 'bloomStr', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
    fEnv.add(CFG, 'bloomThr', 0, 1).name('è¾‰å…‰é˜ˆå€¼').onChange(v => bloomPass.threshold = v);
    fEnv.add(CFG, 'lightPow', 0, 200).name('è½¦ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'headlight') o.intensity = v }));
    fEnv.add(CFG, 'bulbBri', 0, 50).name('å½©ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'bulb') o.material.emissiveIntensity = v }));

    const fFw = gui.addFolder('ğŸ† çƒŸèŠ±æ§åˆ¶');
    
    // [ä¿®å¤] æ‰¹é‡å‘å°„å‡½æ•°ï¼šå¢åŠ é¡µé¢å¯è§æ€§æ£€æŸ¥
    const launchBatch = () => {
        // å¦‚æœæ¸¸æˆæ²¡å¼€å§‹ï¼Œæˆ–è€…é¡µé¢åœ¨åå°(ä¸å¯è§)ï¼Œåˆ™ä¸ç”ŸæˆçƒŸèŠ±
        // è¿™å½»åº•è§£å†³äº†â€œåˆ‡åå°å›æ¥å¡æ­»â€çš„é—®é¢˜
        if(!STATE.started || document.visibilityState === 'hidden') return;
        
        const count = 2 + Math.floor(Math.random() * 4); 
        for(let i=0; i<count; i++) {
            const delay = i * 300 + Math.random() * 200;
            setTimeout(() => fwMgr.launch(), delay);
        }
    };

    fFw.add(CFG, 'autoFw').name('è‡ªåŠ¨ç‡ƒæ”¾').onChange(v => {
        if (autoTimer) clearInterval(autoTimer);
        if (v) { 
            launchBatch(); 
            autoTimer = setInterval(launchBatch, CFG.fwRate * 1000); 
        }
    });
    fFw.add(CFG, 'fwRate', 3, 12).name('æ³¢æ¬¡é—´éš”(ç§’)').onChange(v => {
        if (CFG.autoFw) {
            clearInterval(autoTimer);
            autoTimer = setInterval(launchBatch, v * 1000);
        }
    });

    const cvs = document.getElementById('canvas-container');
    cvs.addEventListener('pointerdown', () => STATE.clickTime = Date.now());
    cvs.addEventListener('pointerup', (e) => {
        if (Date.now() - STATE.clickTime < 200 && STATE.started && !STATE.settings) {
            mouse.x = (e.clientX / innerWidth) * 2 - 1; mouse.y = -(e.clientY / innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, camera);

            const hitTrain = ray.intersectObjects(train.grp.children, true);
            if (hitTrain.length > 0) {
                STATE.running = !STATE.running;
                const d = document.getElementById('d-status'), t = document.getElementById('t-status');
                if (STATE.running) {
                    audio.whistle(); 
                    d.classList.remove('stop'); t.innerText = "æ™ºèƒ½é©¾é©¶æ¨¡å¼ (åŠ é€Ÿä¸­)"; STATE.viewMode = 'FOLLOW';
                } else {
                    d.classList.add('stop'); t.innerText = "æƒ¯æ€§æ»‘è¡Œä¸­ (å‡é€Ÿ)";
                }
                return;
            }
            const hitG = ray.intersectObject(ground);
            if (hitG.length > 0) { const p = hitG[0].point; p.y += 2; fwMgr.launch(p); }
            else fwMgr.launch();
        }
    });
}

window.onresize = () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
};

init();
</script>
    </body>
</html>