<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Express - Perfect View</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020408; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* ÂêØÂä®È°µ */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white; transition: opacity 0.6s ease-out;
        }
        h1 { 
            font-size: 36px; color: #ffd700; margin-bottom: 30px; letter-spacing: 3px; 
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); text-align: center;
        }
        #start-btn {
            background: linear-gradient(135deg, #c62828, #b71c1c);
            color: white; border: none; padding: 16px 60px; font-size: 20px; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px rgba(198, 40, 40, 0.6);
            border: 1px solid rgba(255,255,255,0.2); transition: transform 0.1s;
        }
        #start-btn:active { transform: scale(0.96); }
        .tips { margin-top: 30px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.8; }
        .highlight { color: #4fc3f7; font-weight: bold; }

        /* HUD */
        #hud { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s; }
        .tag { background: rgba(0,0,0,0.6); color: #fff; padding: 6px 12px; border-radius: 20px; font-size: 14px; border: 1px solid #ffffff33; backdrop-filter: blur(4px); display: inline-block; }
        
        /* ËÆæÁΩÆÊåâÈíÆ */
        #settings-btn {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 44px; height: 44px; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            border-radius: 50%; border: 1px solid rgba(255,255,255,0.3);
            color: white; font-size: 20px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; opacity: 0; transition: opacity 1s;
        }

        /* ËÆæÁΩÆÂºπÁ™ó */
        #settings-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; display: none; width: 300px; }
        #modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 25; display: none; background: rgba(0,0,0,0.5); }
        
        #loading { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); color: #666; font-size: 12px; letter-spacing: 1px; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>üéÑ ÊûÅÂú∞ÁâπÂø´</h1>
        <button id="start-btn">ÂºÄÂßãÊóÖÁ®ã</button>
        <div class="tips">
            <span class="highlight">ÂèåÂáªÂ±èÂπï</span> ÂàáÊç¢ ‰∏äÂ∏ù/Ë∑üÈöè ËßÜËßí<br>
            <span class="highlight">ÊªëÂä®/ÊªöËΩÆ</span> Ëá™Áî±Ë∞ÉËäÇË∑üÈöèË∑ùÁ¶ª
        </div>
    </div>

    <div id="hud"><div class="tag" id="view-tag">üé• Êô∫ËÉΩË∑üÈöèËßÜËßí</div></div>
    <div id="settings-btn">‚öôÔ∏è</div>

    <div id="modal-overlay"></div>
    <div id="settings-modal"></div>
    
    <div id="loading">Ê≠£Âú®Ê∏ÖÁêÜÁßØÈõ™ËΩ®ÈÅì...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- ÂÖ®Â±ÄÈÖçÁΩÆ ---
        const STATE = { started: false, viewMode: 'FOLLOW', settingsOpen: false };
        const PARAMS = {
            trainSpeed: 0.12,
            moonIntensity: 1.8,
            fogDensity: 0.002,
            bulbBrightness: 12.0,
            trainLightPower: 60.0,
            bloomStrength: 0.9,
            bloomThreshold: 1.05,
        };

        let scene, camera, renderer, composer, controls, gui;
        let train, fireworkMgr, snowSystem;
        let lights = {}, bloomPass;
        let emissiveObjects = [];
        let trackCurve, trackPointsSample = [];
        const clock = new THREE.Clock();
        const _vec3 = new THREE.Vector3();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            scene.fog = new THREE.FogExp2(0x020408, PARAMS.fogDensity);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 100, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupLights();
            generateTrack();
            createTrackMesh();
            createEnvironment(); // ÈÅøÈöúÁîüÊàê

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = PARAMS.bloomThreshold;
            bloomPass.strength = PARAMS.bloomStrength;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            train = new TrainSystem(scene, trackCurve);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupControls();
            setupUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupLights() {
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-80, 120, -80);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(1024, 1024);
            lights.moon.shadow.camera.left = -200; lights.moon.shadow.camera.right = 200;
            lights.moon.shadow.camera.top = 200; lights.moon.shadow.camera.bottom = -200;
            scene.add(lights.moon);

            const ambient = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambient);

            const ground = new THREE.Mesh(new THREE.CircleGeometry(600, 64), new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 1.0, metalness: 0.0 }));
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true;
            scene.add(ground);
        }

        function generateTrack() {
            // ‰∏âÂè∂ËçâÂ§çÊùÇÈó≠ÁéØ
            const s = 1.4;
            const points = [
                new THREE.Vector3(10*s, 0, 20*s), new THREE.Vector3(50*s, 2, 50*s), new THREE.Vector3(90*s, 0, 0),
                new THREE.Vector3(50*s, 0, -50*s), new THREE.Vector3(10*s, 0, -20*s), new THREE.Vector3(-20*s, 0, -20*s),
                new THREE.Vector3(-50*s, 3, -70*s), new THREE.Vector3(-90*s, 0, -50*s), new THREE.Vector3(-60*s, 0, -10*s),
                new THREE.Vector3(-60*s, 0, 10*s), new THREE.Vector3(-90*s, 0, 50*s), new THREE.Vector3(-50*s, 3, 70*s),
                new THREE.Vector3(-20*s, 0, 20*s), new THREE.Vector3(0, 0, 0)
            ];
            trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            trackPointsSample = trackCurve.getPoints(600);
        }

        function createTrackMesh() {
            const divisions = 600;
            // Ë∑ØÂü∫
            const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divisions, 3.5, 8, true), new THREE.MeshStandardMaterial({color: 0x080808, roughness: 1}));
            bed.position.y = -0.2; bed.scale.y = 0.1; scene.add(bed);
            // ÊûïÊú®
            const plankGeo = new THREE.BoxGeometry(5.5, 0.3, 1.2);
            const plankMat = new THREE.MeshStandardMaterial({color: 0x3e2723});
            const planks = new THREE.InstancedMesh(plankGeo, plankMat, divisions);
            const dummy = new THREE.Object3D();
            for(let i=0; i<divisions; i++) {
                const t = i/divisions;
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t);
                dummy.position.copy(pos); dummy.lookAt(pos.clone().add(tangent)); dummy.updateMatrix();
                planks.setMatrixAt(i, dummy.matrix);
            }
            planks.receiveShadow = true; scene.add(planks);
        }

        function isSafePosition(x, z) {
            // Êâ©Â§ßÈÅøÈöúÂçäÂæÑÂà∞ 18ÔºåÁ°Æ‰øùËßÜÈáé‰∏çË¢´ÈÅÆÊå°
            const safeDistSq = 18 * 18; 
            for(let i=0; i<trackPointsSample.length; i+=3) {
                const dx = trackPointsSample[i].x - x;
                const dz = trackPointsSample[i].z - z;
                if ((dx*dx + dz*dz) < safeDistSq) return false;
            }
            return true;
        }

        function createEnvironment() {
            createHeroTree(60, 0, 1.5, 0xff0000); 
            createHeroTree(-70, 50, 1.3, 0x00ff00);
            createHeroTree(-70, -50, 1.4, 0xffcc00);
            
            // Ê£ÆÊûó
            const treeGeo = new THREE.ConeGeometry(1, 1, 8); 
            let planted = 0, attempts = 0;
            while(planted < 150 && attempts < 4000) {
                attempts++;
                const r = 35 + Math.random() * 180;
                const a = Math.random() * 6.28;
                const x = Math.cos(a)*r; const z = Math.sin(a)*r;
                if(isSafePosition(x, z)) {
                    createNatureTree(x, z); planted++;
                }
            }
            for(let i=0; i<40; i++) {
                const x = (Math.random()-0.5)*350; const z = (Math.random()-0.5)*350;
                if(isSafePosition(x, z)) {
                    const r = Math.random();
                    if(r<0.3) createGift(x, z); else if(r<0.6) createSnowman(x, z); else createLamp(x, z);
                }
            }
        }

        function createHeroTree(x, z, s, c) {
            const g = new THREE.Group(); g.position.set(x, 0, z); g.scale.set(s,s,s);
            const t = new THREE.Mesh(new THREE.CylinderGeometry(1,2,4,8), new THREE.MeshStandardMaterial({color:0x3e2723})); t.position.y=2; g.add(t);
            const lm = new THREE.MeshStandardMaterial({color:0x0f4d0f, roughness:0.8});
            for(let i=0;i<4;i++){
                const cone=new THREE.Mesh(new THREE.ConeGeometry(10-i*2,6,10),lm); cone.position.y=4+i*3.5; cone.castShadow=true; g.add(cone);
                for(let k=0;k<6+i;k++){
                    const a=(k/(6+i))*6.28+i; const br=10-i*2-0.5;
                    const b=new THREE.Mesh(new THREE.SphereGeometry(0.35,4,4),new THREE.MeshStandardMaterial({color:0,emissive:Math.random()>0.5?c:0xffffff,emissiveIntensity:PARAMS.bulbBrightness}));
                    b.position.set(Math.cos(a)*br,4+i*3.5-2.5,Math.sin(a)*br); b.userData={type:'bulb'}; emissiveObjects.push(b); g.add(b);
                }
            }
            const st=new THREE.Mesh(new THREE.OctahedronGeometry(1.5),new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffaa00,emissiveIntensity:20})); st.position.y=20; st.userData={type:'star'}; emissiveObjects.push(st); g.add(st);
            const pl=new THREE.PointLight(c,2,30); pl.position.y=5; g.add(pl); scene.add(g);
        }

        function createNatureTree(x, z) {
            const g=new THREE.Group(); g.position.set(x,0,z); const s=0.8+Math.random()*0.8; g.scale.set(s,s,s);
            const t=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.8,3,5),new THREE.MeshStandardMaterial({color:0x3e2723})); t.position.y=1.5; g.add(t);
            const m=new THREE.MeshStandardMaterial({color:0x1b3e20});
            for(let i=0;i<3;i++){
                const c=new THREE.Mesh(new THREE.ConeGeometry(4-i,5,7),m); c.position.y=3.5+i*3; c.castShadow=true; g.add(c);
            }
            scene.add(g);
        }

        function createGift(x, z) {
            const g=new THREE.Group(); g.position.set(x,0,z); g.rotation.y=Math.random();
            const b=new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5),new THREE.MeshStandardMaterial({color:Math.random()*0xffffff})); b.position.y=0.75; b.castShadow=true; g.add(b); scene.add(g);
        }
        function createSnowman(x, z) {
            const g=new THREE.Group(); g.position.set(x,0,z); g.rotation.y=Math.random();
            const m=new THREE.MeshStandardMaterial({color:0xffffff});
            const b1=new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8),m); b1.position.y=1; g.add(b1);
            const b2=new THREE.Mesh(new THREE.SphereGeometry(0.8,8,8),m); b2.position.y=2.5; g.add(b2);
            scene.add(g);
        }
        function createLamp(x, z) {
            const g=new THREE.Group(); g.position.set(x,0,z);
            const p=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,7),new THREE.MeshStandardMaterial({color:0x111})); p.position.y=3.5; g.add(p);
            const b=new THREE.Mesh(new THREE.SphereGeometry(0.5),new THREE.MeshStandardMaterial({color:0xffaa00,emissive:0xffaa00,emissiveIntensity:10}));
            b.position.y=7; b.userData={type:'bulb'}; emissiveObjects.push(b); g.add(b); scene.add(g);
        }

        // ============================
        // üöÇ ÁÅ´ËΩ¶Á≥ªÁªü (Êó†ÁºùËøûÊé•‰øÆÊ≠£Áâà)
        // ============================
        class TrainSystem {
            constructor(scene, curve) {
                this.scene = scene; this.curve = curve;
                this.group = new THREE.Group();
                this.smokes = [];
                this.progress = 0;
                
                this.loco = this.createLoco();
                this.group.add(this.loco);
                this.cars = [];
                
                // Á≤æÁ°ÆËÆ°ÁÆóÈó¥Ë∑ùÈò≤Ê≠¢ËÑ±ËäÇ (Âü∫‰∫éËΩ®ÈÅìÈïøÂ∫¶ÂíåËΩ¶Ë∫´)
                const gapStep = 0.0128; 
                
                for(let i=1; i<=8; i++) {
                    const car = this.createCar(i);
                    car.userData.tOffset = i * gapStep; 
                    this.group.add(car);
                    this.cars.push(car);
                }
                scene.add(this.group);
            }

            createLoco() {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.4});
                const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 4, 6), mat); body.position.y=3.2; g.add(body);
                this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.4,1.8), new THREE.MeshStandardMaterial({color:0x111}));
                // ‰øÆÊ≠£ÔºöÁÉüÂõ±Âú®ZÊ≠£ÊñπÂêë (ËΩ¶Â§¥)
                this.chimney.position.set(0,4.2,2); g.add(this.chimney);
                
                // ËΩ¶ÁÅØ
                const l=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.2),new THREE.MeshStandardMaterial({color:0,emissive:0xffdd88,emissiveIntensity:PARAMS.trainLightPower}));
                l.rotation.x=-1.57; l.position.set(0,3,3.1); l.userData={type:'headlight'}; emissiveObjects.push(l); g.add(l);
                const s=new THREE.SpotLight(0xffdd88,30,60,0.6,0.5); s.position.set(0,3.5,4); s.target.position.set(0,0,20); g.add(s); g.add(s.target);
                
                // ÂêéËøûÊé•ÊùÜ (Èïø‰∏ÄÁÇπÔºåÊèíÂÖ•ÂêéËΩ¶)
                const coup = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 2.5), new THREE.MeshStandardMaterial({color:0x111}));
                coup.position.set(0, 2, -3.5); g.add(coup);

                return g;
            }

            createCar(i) {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: i%2===0?0x1565c0:0x2e7d32});
                const b = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.2, 4.5), mat); b.position.y=2.8; g.add(b);
                const gf = new THREE.Mesh(new THREE.BoxGeometry(2,1.2,2), new THREE.MeshStandardMaterial({color:0xffd54f})); gf.position.y=5; g.add(gf);
                
                // ËøûÊé•ÊùÜÔºöÂâçÂêéÈÉΩÊúâÔºåÂä†ÈïøÈáçÂè†ÔºåÈò≤Ê≠¢ÂºØÈÅìÈú≤È¶Ö
                const cMat = new THREE.MeshStandardMaterial({color:0x111});
                const fc = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.7, 1.5), cMat); fc.position.set(0,2,2.5); g.add(fc);
                const bc = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.7, 2.0), cMat); bc.position.set(0,2,-3.0); g.add(bc);
                
                return g;
            }

            update(delta) {
                const speed = PARAMS.trainSpeed * delta * 0.2;
                this.progress = (this.progress + speed) % 1;
                this.place(this.loco, this.progress);
                this.cars.forEach(c => {
                    let t = this.progress - c.userData.tOffset;
                    if(t < 0) t += 1;
                    this.place(c, t);
                });
                if(Math.random()>0.9) { _vec3.setFromMatrixPosition(this.chimney.matrixWorld); _vec3.y+=0.5; this.spawnSmoke(_vec3); }
                this.updateSmoke();
            }

            place(obj, t) {
                const pos = this.curve.getPointAt(t);
                const tangent = this.curve.getTangentAt(t);
                obj.position.copy(pos);
                // ‰øÆÊ≠£ÔºölookAt(pos + tangent) ‰ºöËÆ©Â±ÄÈÉ® -Z ÊåáÂêë tangent„ÄÇ
                // Êàë‰ª¨ÁöÑÊ®°ÂûãÔºöËΩ¶Â§¥Âú® +Z (Chimney)ÔºåËΩ¶Â∞æÂú® -Z (Coupler)„ÄÇ
                // ÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅËÆ© +Z ÊåáÂêë tangent„ÄÇ
                // ‰øÆÊ≠£ lookAt ‰∏∫ (pos - tangent) ? ‰∏çÔºåËøôÊ†∑ÊòØÂèçÁöÑ„ÄÇ
                // ‰øÆÊ≠£ÊñπÊ≥ïÔºö‰ΩøÁî® lookAt(pos + tangent) ÂêéÔºåÊ®°ÂûãÊòØÂÄíÁùÄËµ∞ÁöÑ (+Z ÊúùÂêé)„ÄÇ
                // ÊâÄ‰ª•Êàë‰ª¨ËÆ©Ê®°ÂûãÊú¨Ë∫´ÊóãËΩ¨ 180Â∫¶ÔºåÊàñËÄÖÊõ¥ÁÆÄÂçïÁöÑÔºölookAt(pos - tangent) Á°ÆÂÆû‰ºöËÆ© +Z ÊúùÂâç„ÄÇ
                // ËÆ©Êàë‰ª¨ËØïËØï lookAt(pos - tangent) -> Ëøô‰ºöËÆ©Â±ÄÈÉ® -Z ÊåáÂêë (pos-tangent)ÔºåÂç≥Â±ÄÈÉ® +Z ÊåáÂêë tangent (ÂâçÊñπ)„ÄÇ
                // ÂÆåÁæé„ÄÇ
                obj.lookAt(pos.clone().add(tangent)); 
                // ÂìéÂëÄ‰∏çÂØπÔºåThreejs lookAt ÊòØËÆ© local -Z ÊåáÂêë target„ÄÇ
                // ÁõÆÊ†áÊòØÂâçÊñπ (tangent)„ÄÇÊâÄ‰ª• local -Z ÊåáÂêëÂâçÊñπ„ÄÇ
                // ÊàëÁöÑÊ®°ÂûãÔºöChimney ÊòØ +Z„ÄÇÊâÄ‰ª• Chimney ÊåáÂêëÂêéÊñπ„ÄÇ
                // ÁªìËÆ∫ÔºöÊ®°ÂûãÊòØÂèçÁöÑ„ÄÇ
                // ‰øÆÊ≠£ÔºöÊóãËΩ¨Ê®°Âûã Math.PI ? ‰∏çË°åÔºåGroup ÊóãËΩ¨‰ºöÈ∫ªÁÉ¶„ÄÇ
                // ÊúÄÁÆÄÂçïÁöÑ‰øÆÊ≠£Ôºöobj.lookAt(pos.clone().sub(tangent)) -> ËÆ© local -Z ÊåáÂêëÂêéÊñπ -> local +Z ÊåáÂêëÂâçÊñπ„ÄÇ
                // ËøôÊ†∑ Chimney (+Z) Â∞±‰ºöÊåáÂêëÂâçÊñπ„ÄÇ
                obj.lookAt(pos.clone().sub(tangent)); 
            }

            spawnSmoke(pos) {
                const m = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4+Math.random()*0.4, 0), new THREE.MeshStandardMaterial({color:0xcccccc, transparent:true, opacity:0.4}));
                m.position.copy(pos); this.scene.add(m); this.smokes.push({m, life:1.2});
            }
            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i]; s.life-=0.02; s.m.position.y+=0.06; s.m.scale.multiplyScalar(1.02); s.m.material.opacity=s.life*0.3;
                    if(s.life<=0){ this.scene.remove(s.m); this.smokes.splice(i,1); }
                }
            }
        }

        class FireworkManager {
            constructor(s){this.s=s;this.l=[];const c=document.createElement('canvas');c.width=32;c.height=32;const x=c.getContext('2d');const g=x.createRadialGradient(16,16,0,16,16,16);g.addColorStop(0,'#fff');g.addColorStop(1,'transparent');x.fillStyle=g;x.fillRect(0,0,32,32);this.t=new THREE.CanvasTexture(c);}
            launch(){
                _vec3.set(0,0,-40).applyQuaternion(camera.quaternion).add(camera.position);
                const pos = _vec3.clone().add(new THREE.Vector3((Math.random()-0.5)*50, -20, (Math.random()-0.5)*50));
                const c = new THREE.Color().setHSL(Math.random(),1,0.6);
                this.l.push({ph:'up',p:pos,v:new THREE.Vector3(0,1.2+Math.random(),0),dy:pos.y+40+Math.random()*20,c:c,tr:new THREE.Mesh(new THREE.SphereGeometry(0.4),new THREE.MeshBasicMaterial({color:c})),pt:null});
                this.s.add(this.l[this.l.length-1].tr);
            }
            update(){
                for(let i=this.l.length-1;i>=0;i--){
                    const f=this.l[i];
                    if(f.ph==='up'){f.p.add(f.v);f.v.y*=0.98;f.tr.position.copy(f.p);if(f.v.y<0.1||f.p.y>f.dy){this.s.remove(f.tr);f.ph='pop';this.exp(f);}}
                    else{const p=f.pt.geometry.attributes.position.array;f.li-=0.015;for(let k=0;k<p.length/3;k++){p[k*3]+=f.vs[k*3];p[k*3+1]+=f.vs[k*3+1];p[k*3+2]+=f.vs[k*3+2];f.vs[k*3+1]-=0.005;}f.pt.geometry.attributes.position.needsUpdate=true;f.pt.material.opacity=f.li;if(f.li<=0){this.s.remove(f.pt);this.l.splice(i,1);}}
                }
            }
            exp(f){const cnt=100;const p=[],v=[];for(let i=0;i<cnt;i++){p.push(f.p.x,f.p.y,f.p.z);const s=0.2+Math.random()*0.3,th=Math.random()*6.28,ph=Math.acos(2*Math.random()-1);v.push(Math.sin(ph)*Math.cos(th)*s,Math.sin(ph)*Math.sin(th)*s,Math.cos(ph)*s);}const g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));const m=new THREE.PointsMaterial({color:f.c,size:2,map:this.t,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false});f.pt=new THREE.Points(g,m);f.li=1.0;f.vs=v;this.s.add(f.pt);}
        }
        class SnowSystem {
            constructor(s){const p=[];for(let i=0;i<3000;i++)p.push(Math.random()*600-300,Math.random()*200,Math.random()*600-300);const g=new THREE.BufferGeometry();g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));this.m=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.7}));s.add(this.m);}
            update(){const p=this.m.geometry.attributes.position.array;for(let i=1;i<p.length;i+=3){p[i]-=0.25;if(p[i]<0)p[i]=200;}this.m.geometry.attributes.position.needsUpdate=true;}
        }

        // ============================
        // ‰∫§‰∫í‰∏éÂä®Áîª
        // ============================
        function setupUI() {
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                STATE.started = true;
                document.getElementById('start-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 600);
                document.getElementById('hud').style.opacity = '1';
                document.getElementById('settings-btn').style.opacity = '1';
            });

            // ËÆæÁΩÆÁõ∏ÂÖ≥
            const btn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const overlay = document.getElementById('modal-overlay');
            const toggle = () => { STATE.settingsOpen = !STATE.settingsOpen; modal.style.display = STATE.settingsOpen ? 'block':'none'; overlay.style.display = STATE.settingsOpen ? 'block':'none'; };
            btn.addEventListener('click', toggle); overlay.addEventListener('click', toggle);

            // GUI
            gui = new GUI({ container: modal, width: '100%' });
            gui.title('üîß Ë∞ÉËØïÊéßÂà∂Âè∞');
            const f1 = gui.addFolder('üé• ÊëÑÂÉèÊú∫');
            f1.add(PARAMS, 'trainSpeed', 0, 0.4).name('ÂàóËΩ¶ÈÄüÂ∫¶');
            
            const f2 = gui.addFolder('üí° ÂÖâÂΩ±');
            f2.add(PARAMS, 'moonIntensity', 0, 5).name('ÊúàÂÖâ');
            f2.add(PARAMS, 'bloomStrength', 0, 2).name('ËæâÂÖâ');
            const updateEmis = () => emissiveObjects.forEach(o => {
                if(o.userData.type==='bulb') o.material.emissiveIntensity=PARAMS.bulbBrightness;
                if(o.userData.type==='headlight') o.material.emissiveIntensity=PARAMS.trainLightPower;
            });
            f2.add(PARAMS, 'bulbBrightness', 1, 30).onChange(updateEmis);

            window.addEventListener('pointerdown', () => { if(STATE.started && !STATE.settingsOpen) fireworkMgr.launch(); });
            window.addEventListener('dblclick', () => {
                if(!STATE.started) return;
                STATE.viewMode = STATE.viewMode === 'FOLLOW' ? 'GOD' : 'FOLLOW';
                document.getElementById('view-tag').innerText = STATE.viewMode === 'FOLLOW' ? "üé• Êô∫ËÉΩË∑üÈöè" : "‚òÅÔ∏è ‰∏äÂ∏ù‰øØÁû∞";
                if(STATE.viewMode === 'GOD') controls.target.set(0,0,0);
            });
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();

            if (STATE.started && STATE.viewMode === 'FOLLOW' && train) {
                const locoPos = train.loco.position;
                const locoQuat = train.loco.quaternion;
                controls.target.copy(locoPos);

                // Ê†∏ÂøÉÔºöÂä®ÊÄÅË∑üÈöèËÆ°ÁÆó
                // Êàë‰ª¨‰∏çÂº∫Âà∂ set camera positionÔºåËÄåÊòØÂü∫‰∫éÂΩìÂâçË∑ùÁ¶ªÈáçÊñ∞ËÆ°ÁÆóÁêÜÊÉ≥‰ΩçÁΩÆÔºåÁÑ∂Âêé lerp ËøáÂéª
                // ËøôÊ†∑Êó¢‰øùÁïô‰∫Ü OrbitControls ÁöÑÁº©ÊîæËÉΩÂäõÔºåÂèàÂÆûÁé∞‰∫ÜËá™Âä®ËΩ¨Âêë
                
                // 1. Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ËÆæÂÆöÁöÑË∑ùÁ¶ª (Zoom)
                const currentDist = camera.position.distanceTo(locoPos);
                
                // 2. ËÆ°ÁÆóÁêÜÊÉ≥ËßíÂ∫¶ÔºöÊ∞∏ËøúÂú®ÁÅ´ËΩ¶Â±ÅËÇ°ÂêéÈù¢
                // ËΩ¶Â§¥ÊúùÂêëÊòØ +Z (‰øÆÊ≠£Âêé)ÔºåÊâÄ‰ª•ËΩ¶Â±ÅËÇ°ÊñπÂêëÊòØ -Z
                const backDir = new THREE.Vector3(0, 0, -1).applyQuaternion(locoQuat).normalize();
                
                // 3. ËÆ°ÁÆóÁêÜÊÉ≥‰ΩçÁΩÆÔºöÂü∫‰∫éÂΩìÂâçË∑ùÁ¶ª + Âõ∫ÂÆöÈ´òÂ∫¶Ë°•ÂÅø
                // ‰øùÊåÅÁî®Êà∑ËÆæÂÆöÁöÑÊ∞¥Âπ≥Ë∑ùÁ¶ªÔºå‰ΩÜÁ®çÂæÆÊä¨È´ò‰∏ÄÁÇπËßÜËßíÊñπ‰æøÁúãË∑Ø
                const idealPos = locoPos.clone()
                    .add(backDir.multiplyScalar(currentDist)) // ‰øùÊåÅË∑ùÁ¶ª
                    .add(new THREE.Vector3(0, currentDist * 0.4, 0)); // È´òÂ∫¶ÈöèË∑ùÁ¶ªËá™ÈÄÇÂ∫î
                
                // 4. ÊüîÂíåÊèíÂÄºÔºöÂè™‰øÆÊ≠£ËßíÂ∫¶Ôºå‰∏ç‰øÆÊ≠£Ë∑ùÁ¶ª (Ë∑ùÁ¶ªÁî± OrbitControls Êé•ÁÆ°)
                // ËøôÈáåÁöÑ trick ÊòØÔºöÊàë‰ª¨Â∏åÊúõ camera ÊÖ¢ÊÖ¢ËΩ¨Âà∞ËΩ¶Â±ÅËÇ°ÂêéÈù¢Ôºå‰ΩÜ‰∏çË¶ÅÊîπÂèòË∑ùÁ¶ª
                // ÊâÄ‰ª•Êàë‰ª¨ lerp ÁöÑÊòØ position„ÄÇ
                // 0.03 ÁöÑÁ≥ªÊï∞ÂÜ≥ÂÆö‰∫ÜÂõûÊ≠£ÁöÑÈÄüÂ∫¶„ÄÇË∂äÂ∞èË∂äÊªëÔºåË∂äÂ§ßË∂äÁ°¨„ÄÇ
                camera.position.lerp(idealPos, 0.03);
            } else if (!STATE.started) {
                const t = Date.now() * 0.0001;
                camera.position.set(Math.sin(t)*200, 120, Math.cos(t)*200);
                camera.lookAt(0,0,0);
            }

            controls.update();
            composer.render();
        }

        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
