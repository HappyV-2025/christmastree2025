<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Express - Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* --- å¯åŠ¨é¡µæ ·å¼ --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white; transition: opacity 0.6s ease-out;
        }
        h1 { 
            font-size: 36px; color: #ffb300; margin-bottom: 20px; letter-spacing: 4px; 
            text-shadow: 0 0 30px rgba(255, 165, 0, 0.5); text-transform: uppercase; text-align: center;
        }
        .intro-card {
            background: rgba(255,255,255,0.05); padding: 30px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); text-align: center; max-width: 90%; width: 400px;
        }
        .tips { color: #ccc; font-size: 14px; line-height: 2.2; margin-bottom: 30px; text-align: left; }
        .key { color: #4fc3f7; font-weight: bold; margin-right: 8px; border-bottom: 1px dashed #4fc3f7; }
        
        #start-btn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            color: white; border: none; padding: 15px 80px; font-size: 20px; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px rgba(211, 47, 47, 0.4);
            transition: transform 0.1s; border: 1px solid rgba(255,255,255,0.2);
        }
        #start-btn:active { transform: scale(0.95); }

        /* --- æ¸¸æˆå†… UI --- */
        #hud { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            pointer-events: none; opacity: 0; transition: opacity 1s; 
        }
        .tag { 
            background: rgba(0,0,0,0.6); color: #fff; padding: 8px 16px; 
            border-radius: 30px; font-size: 14px; border: 1px solid #ffffff22; 
            backdrop-filter: blur(4px); display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 8px; height: 8px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 5px #00ff00; }

        #settings-btn {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 44px; height: 44px; background: rgba(255,255,255,0.1); 
            backdrop-filter: blur(10px); border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
            color: white; font-size: 22px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; opacity: 0; transition: opacity 1s;
        }
        
        /* --- è®¾ç½®å¼¹çª— --- */
        #settings-modal { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            z-index: 30; display: none; width: 340px; 
        }
        #modal-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 25; display: none; background: rgba(0,0,0,0.5); 
        }
        
        #loading { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #666; font-size: 12px; letter-spacing: 2px; }
    </style>
</head>
<body>

    <!-- å¯åŠ¨é¡µ -->
    <div id="start-screen">
        <div class="intro-card">
            <h1>åœ£è¯èŠ‚ğŸš‚å°ç«è½¦</h1>
            <div class="tips">
                <div><span class="key">ğŸ† ç‚¹å‡»å±å¹•</span> ç‡ƒæ”¾èŠ‚æ—¥çƒŸèŠ±</div>
                <div><span class="key">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾</span> è°ƒæ•´è·Ÿéšè·ç¦» (è·ç¦»è®°å¿†)</div>
                <div><span class="key">ğŸ‘† å•æŒ‡æ‹–åŠ¨</span> 360Â° è§‚å¯Ÿåˆ—è½¦ (æ¾æ‰‹å›æ­£)</div>
                <div><span class="key">âš¡ åŒå‡»å±å¹•</span> åˆ‡æ¢ ä¸Šå¸/é©¾é©¶ è§†è§’</div>
            </div>
            <button id="start-btn">å¼€å§‹æ—…ç¨‹</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="tag">
            <div class="dot"></div>
            <span id="view-text">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span>
        </div>
    </div>
    <div id="settings-btn">âš™ï¸</div>

    <div id="modal-overlay"></div>
    <div id="settings-modal"></div>
    
    <div id="loading">æ­£åœ¨è£…è½½çƒŸèŠ±ä¸ç¤¼ç‰©...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- æ ¸å¿ƒå‚æ•° ---
        const PARAMS = {
            // ğŸš‚ åˆ—è½¦
            trainSpeed: 0.15,
            carriageGap: 0.009, 
            wheelSpeed: 2.0,
            
            // ğŸ¥ ç›¸æœº
            camFollowDist: 2.0,  
            camHeightOffset: 40.0, 
            camSmooth: 0.02,      
            
            // ğŸ’¡ ç¯å¢ƒ
            moonIntensity: 1.8,
            fogDensity: 0.002,
            bloomStrength: 0.8,
            bloomThreshold: 1.0,
            
            // âœ¨ ç¯å…‰
            trainLightPower: 60.0,
            bulbBrightness: 15.0,
            starBrightness: 25.0,
            
            // ğŸ† çƒŸèŠ±æ§åˆ¶
    		autoFireworks: false,   // è‡ªåŠ¨å¼€å…³
    		fwInterval: 5.0,        // å‘å°„é—´éš”(ç§’)
        };

        const STATE = { 
            started: false, 
            viewMode: 'FOLLOW', 
            settingsOpen: false,
            isUserInteracting: false 
        };

        let scene, camera, renderer, composer, controls, gui;
        let train, fireworkMgr, snowSystem;
        let lights = {}, bloomPass;
        let groundMesh;
        let emissiveObjects = []; 
        let trackCurve, trackPointsSample = [];
        let autoFwTimer = null; // ç”¨äºå­˜å‚¨å®šæ—¶å™¨ID
        const clock = new THREE.Clock();
        const _vec3 = new THREE.Vector3();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            scene.fog = new THREE.FogExp2(0x020408, PARAMS.fogDensity);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 25, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ¨¡å—åˆå§‹åŒ– (å°†åœ¨åç»­éƒ¨åˆ†å®šä¹‰)
            setupLights();
            generateTrack();
            createTrackMesh();
            createEnvironment(); 

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 1.0;
            bloomPass.strength = PARAMS.bloomStrength;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            train = new TrainSystem(scene, trackCurve);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupControls();
            setupUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }
        
        // (Part 1 ç»“æŸï¼Œè¯·å›å¤ "2" ç»§ç»­)
// (æ¥ Part 1)

        // ============================
        // ğŸŒ ä¸–ç•Œæ„å»ºç³»ç»Ÿ
        // ============================
        function setupLights() {
            // æœˆå…‰ (HDR)
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-80, 120, -80);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(2048, 2048);
            lights.moon.shadow.camera.left = -200; lights.moon.shadow.camera.right = 200;
            lights.moon.shadow.camera.top = 200; lights.moon.shadow.camera.bottom = -200;
            scene.add(lights.moon);

            // ç¯å¢ƒå…‰
            const ambient = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambient);

            // åœ°é¢
            groundMesh = new THREE.Mesh(
    			new THREE.CircleGeometry(600, 64), 
    			new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 1.0, metalness: 0.0 })
			);
			groundMesh.rotation.x = -Math.PI / 2; 
			groundMesh.receiveShadow = true;
			scene.add(groundMesh); // 2. è¿™é‡Œä¹Ÿè¦æ”¹æˆ groundMesh
        }

        function generateTrack() {
            // ç”Ÿæˆå¤æ‚çš„â€œä¸‰å¶è‰â€é—­åˆå›è·¯
            const s = 1.4; // ç¼©æ”¾ç³»æ•°
            const points = [
                new THREE.Vector3(10*s, 0, 20*s), new THREE.Vector3(50*s, 2, 50*s), new THREE.Vector3(90*s, 0, 0),
                new THREE.Vector3(50*s, 0, -50*s), new THREE.Vector3(10*s, 0, -20*s), new THREE.Vector3(-20*s, 0, -20*s),
                new THREE.Vector3(-50*s, 3, -70*s), new THREE.Vector3(-90*s, 0, -50*s), new THREE.Vector3(-60*s, 0, -10*s),
                new THREE.Vector3(-60*s, 0, 10*s), new THREE.Vector3(-90*s, 0, 50*s), new THREE.Vector3(-50*s, 3, 70*s),
                new THREE.Vector3(-20*s, 0, 20*s), new THREE.Vector3(0, 0, 0)
            ];
            trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            // é‡‡æ ·600ä¸ªç‚¹ç”¨äºé¿éšœè®¡ç®—
            trackPointsSample = trackCurve.getPoints(600);
        }

        function createTrackMesh() {
            const divisions = 600;
            // 1. è·¯åŸº (é»‘è‰²é˜²ç©¿å¸®)
            const bed = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, divisions, 3.5, 8, true), 
                new THREE.MeshStandardMaterial({color: 0x080808, roughness: 1})
            );
            bed.position.y = -0.2; bed.scale.y = 0.1; 
            scene.add(bed);

            // 2. æ•æœ¨ (InstanceMesh ä¼˜åŒ–æ€§èƒ½)
            const plankGeo = new THREE.BoxGeometry(5.5, 0.3, 1.2);
            const plankMat = new THREE.MeshStandardMaterial({color: 0x3e2723});
            const planks = new THREE.InstancedMesh(plankGeo, plankMat, divisions);
            const dummy = new THREE.Object3D();
            
            for(let i=0; i<divisions; i++) {
                const t = i/divisions;
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t);
                dummy.position.copy(pos); 
                dummy.lookAt(pos.clone().add(tangent)); 
                dummy.updateMatrix();
                planks.setMatrixAt(i, dummy.matrix);
            }
            planks.receiveShadow = true; 
            scene.add(planks);
        }

        // ğŸ›¡ï¸ æ ¸å¿ƒé¿éšœç®—æ³•ï¼šæ£€æŸ¥åæ ‡æ˜¯å¦å®‰å…¨
        function isSafePosition(x, z) {
            const safeDistSq = 18 * 18; // 18ç±³å®‰å…¨è·ç¦»
            for(let i=0; i<trackPointsSample.length; i+=3) { // æ­¥è¿›3ä¼˜åŒ–æ€§èƒ½
                const dx = trackPointsSample[i].x - x;
                const dz = trackPointsSample[i].z - z;
                if ((dx*dx + dz*dz) < safeDistSq) return false;
            }
            return true;
        }

        function createEnvironment() {
            // 1. æ”¾ç½®åœ°æ ‡å·¨æ ‘ (ä½äºç¯è·¯ä¸­å¿ƒ)
            createHeroTree(60, 0, 2.5); 
            createHeroTree(-70, 50, 1.1);
            createHeroTree(-70, -50, 1.4);
            
            // 2. ç”Ÿæˆæ£®æ—èƒŒæ™¯ (è‡ªåŠ¨é¿éšœ)
            let planted = 0, attempts = 0;
            while(planted < 150 && attempts < 4000) {
                attempts++;
                const r = 35 + Math.random() * 180;
                const a = Math.random() * 6.28;
                const x = Math.cos(a)*r; const z = Math.sin(a)*r;
                
                if(isSafePosition(x, z)) {
                    createNatureTree(x, z);
                    planted++;
                }
            }

            // 3. ç”Ÿæˆè£…é¥°å“ (ç¤¼ç‰©/é›ªäºº/è·¯ç¯)
            for(let i=0; i<40; i++) {
                const x = (Math.random()-0.5)*350; 
                const z = (Math.random()-0.5)*350;
                if(isSafePosition(x, z)) {
                    const r = Math.random();
                    if(r < 0.3) createGift(x, z);
                    else if(r < 0.6) createSnowman(x, z);
                    else createLamp(x, z);
                }
            }
        }

        // --- ç‰©ä½“å·¥å‚å‡½æ•° ---

        function createHeroTree(x, z, scaleFactor) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            // åŸºç¡€ç¼©æ”¾ï¼šåŸæœ¬æ˜¯ 1.5ï¼Œç°åœ¨å»ºè®®ç»™ 4.0 ä»¥ä¸Š
            group.scale.set(scaleFactor, scaleFactor, scaleFactor);

            // 1. æ ‘å¹² (ç²—å£®)
            const trunkGeo = new THREE.CylinderGeometry(2, 2.5, 12, 16);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x3e2723, 
                roughness: 0.9 
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 6;
            group.add(trunk);

            // 2. æ ‘å¶ (7å±‚ç»“æ„ï¼Œæ›´èŒ‚å¯†)
            const leafMat = new THREE.MeshStandardMaterial({
                color: 0x0f5515, // æ›´æ·±é‚ƒçš„æ¾ç»¿è‰²
                roughness: 0.7,
                flatShading: true // ä½å¤šè¾¹å½¢é£æ ¼ï¼Œæ£±è§’åˆ†æ˜æ›´æœ‰è´¨æ„Ÿ
            });
            
            const layers = 7;
            const treeHeight = 55; // æ ‘æ€»é«˜
            
            for(let i=0; i<layers; i++) {
                // è¶Šå¾€ä¸Šè¶Šçª„
                const radius = 18 - i * 2.2; 
                // æ¯ä¸€å±‚çš„é«˜åº¦
                const h = 12; 
                const y = 10 + i * 6.5; 
                
                const cone = new THREE.Mesh(new THREE.ConeGeometry(radius, h, 16), leafMat);
                cone.position.y = y;
                cone.castShadow = true;
                cone.receiveShadow = true;
                group.add(cone);

                // --- å¢åŠ è£…é¥°çƒ (ä¸å‘å…‰ï¼Œåªåå…‰) ---
                if (i < layers - 1) { // é¡¶å±‚ä¸æŒ‚çƒ
                    const orbCount = 6 + i;
                    for(let k=0; k<orbCount; k++) {
                        const angle = (k / orbCount) * Math.PI * 2 + (i * 0.5);
                        const r = radius - 0.5; // æŒ‚åœ¨è¾¹ç¼˜
                        const bx = Math.cos(angle) * r;
                        const bz = Math.sin(angle) * r;
                        
                        // éšæœºçº¢é‡‘è“é…è‰²
                        const cols = [0xff0000, 0xffd700, 0x0044ff]; 
                        const orbCol = cols[Math.floor(Math.random()*cols.length)];
                        
                        const ball = new THREE.Mesh(
                            new THREE.SphereGeometry(0.6, 8, 8), 
                            new THREE.MeshStandardMaterial({
                                color: orbCol, 
                                metalness: 0.7, 
                                roughness: 0.2 
                            })
                        );
                        ball.position.set(bx, y - h/2 + 0.5, bz);
                        group.add(ball);
                    }
                }
            }

            // 3. èºæ—‹ç¯å¸¦ (æ•°å­¦ç¾æ„Ÿ)
            // ä½¿ç”¨èºæ—‹çº¿å…¬å¼ç”Ÿæˆç¯æ³¡ä½ç½®
            const lightCount = 120; // ç¯æ³¡æ•°é‡
            const spiralTurns = 6.0; // ç¼ ç»•åœˆæ•°
            const heightRange = 45;  // ç¼ ç»•é«˜åº¦èŒƒå›´
            
            for(let i=0; i<lightCount; i++) {
                const t = i / lightCount; // 0 åˆ° 1 çš„è¿›åº¦
                
                // é«˜åº¦ä»ä¸‹å¾€ä¸Š
                const ly = 12 + t * heightRange;
                
                // åŠå¾„éšé«˜åº¦å˜å° (é”¥å½¢èºæ—‹)
                const currentRadius = 18 * (1 - t) + 1.0; 
                
                // è§’åº¦èºæ—‹ä¸Šå‡
                const angle = t * Math.PI * 2 * spiralTurns;
                
                const lx = Math.cos(angle) * currentRadius;
                const lz = Math.sin(angle) * currentRadius;

                const bulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffff00,
                        emissive: 0xffaa00,
                        emissiveIntensity: PARAMS.bulbBrightness // ç»‘å®šå…¨å±€å‚æ•°
                    })
                );
                bulb.position.set(lx, ly, lz);
                bulb.userData = { type: 'bulb' }; // ç”¨äºGUIæ§åˆ¶äº®åº¦
                emissiveObjects.push(bulb);
                group.add(bulb);
            }

            // 4. æ ‘é¡¶å·¨æ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(3.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Basicæè´¨ä¸å—å…‰ç…§å½±å“ï¼Œæ°¸è¿œäº®
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = treeHeight + 2;
            
            // ç»™æ˜Ÿæ˜ŸåŠ ä¸€å±‚è¾‰å…‰å¤–å£³
            const glow = new THREE.Mesh(
                new THREE.OctahedronGeometry(5.0, 0),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffdd00, 
                    transparent: true, 
                    opacity: 0.3, 
                    blending: THREE.AdditiveBlending 
                })
            );
            star.add(glow);
            
            // æ˜Ÿæ˜Ÿä½œä¸ºå‘å…‰ç‰©ä½“åŠ å…¥ç®¡ç†
            star.userData = { type: 'star' }; // è¿™é‡Œæ ‡è®°ä¸€ä¸‹ï¼Œè™½ç„¶å®ƒç”¨äº†Basicæè´¨
            // æ·»åŠ ç‚¹å…‰æºç…§äº®æ ‘é¡¶
            const topLight = new THREE.PointLight(0xffaa00, 100, 100);
            topLight.position.set(0, 5, 0);
            star.add(topLight);

            emissiveObjects.push(star); 
            group.add(star);

            scene.add(group);
        }

        function createNatureTree(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); 
            const s = 0.8 + Math.random()*0.8; g.scale.set(s,s,s);
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.8,3,5), new THREE.MeshStandardMaterial({color:0x3e2723})); 
            t.position.y=1.5; g.add(t);
            const m = new THREE.MeshStandardMaterial({color:0x1b3e20});
            for(let i=0;i<3;i++){
                const c = new THREE.Mesh(new THREE.ConeGeometry(4-i, 5, 7), m); 
                c.position.y = 3.5 + i*3; c.castShadow = true; g.add(c);
            }
            scene.add(g);
        }

        function createGift(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); g.rotation.y = Math.random();
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({color:Math.random()*0xffffff}));
            b.position.y = 0.75; b.castShadow = true; g.add(b); scene.add(g);
        }

        function createSnowman(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); g.rotation.y = Math.random();
            const m = new THREE.MeshStandardMaterial({color:0xffffff});
            const b1 = new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), m); b1.position.y=1; g.add(b1);
            const b2 = new THREE.Mesh(new THREE.SphereGeometry(0.8,8,8), m); b2.position.y=2.5; g.add(b2);
            scene.add(g);
        }

        function createLamp(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,7), new THREE.MeshStandardMaterial({color:0x111})); 
            p.position.y=3.5; g.add(p);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({
                color:0xffaa00, emissive:0xffaa00, emissiveIntensity:10
            }));
            b.position.y=7; b.userData={type:'bulb'}; emissiveObjects.push(b); g.add(b); 
            scene.add(g); 
        }

        // (Part 2 ç»“æŸï¼Œè¯·å›å¤ "3" ç»§ç»­)
      
      // (æ¥ Part 2)

        // ============================
// ğŸš‚ ç«è½¦ç³»ç»Ÿ (ä¿®æ­£ç‰ˆï¼šQç‰ˆæ¯”ä¾‹ + ç´§å¯†è¿æ¥ + 12èŠ‚é•¿ç¼–ç»„)
// ============================
class TrainSystem {
    constructor(scene, curve) {
        this.scene = scene; 
        this.curve = curve;
        this.group = new THREE.Group();
        this.smokes = []; 
        this.progress = 0;
        this.wheels = []; 
        
        // 0. å…‰æ™•è´´å›¾ (ä¿æŒä¹‹å‰çš„å¥½æ•ˆæœ)
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');     
        gradient.addColorStop(0.2, 'rgba(255, 220, 100, 0.8)'); 
        gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.3)');   
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');           
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        this.glareTexture = new THREE.CanvasTexture(canvas);

        // 1. åˆ›å»ºè½¦å¤´ (ç¼©çŸ­)
        this.loco = this.createDetailedLoco();
        this.group.add(this.loco);
        
        // 2. åˆ›å»ºè½¦å¢ (å¢åŠ åˆ° 12 èŠ‚ï¼)
        this.cars = [];
        for(let i=1; i<=12; i++) {
            const car = this.createDetailedCar(i);
            this.group.add(car);
            this.cars.push(car);
        }
        
        // 3. åˆå§‹åŒ–é—´è·
        this.refreshGap();
        scene.add(this.group);
    }

    // --- é—´è·æ ¸å¿ƒä¿®æ­£ ---
    refreshGap() { 
        this.cars.forEach((c, i) => {
            // å…³é”®è°ƒæ•´ï¼š
            // è½¦èº«ç°åœ¨çº¦ 5ä¸ªå•ä½é•¿ã€‚è½¨é“æ€»é•¿çº¦ 600-700ã€‚
            // 0.007 æ˜¯ç»è¿‡è®¡ç®—åŒ¹é…çŸ­è½¦èº«çš„æœ€ä½³é—´è·ï¼Œä¿è¯è¿æ¥æ†æ­£å¥½æ¥è§¦
            const gapStep = 0.0075 + (PARAMS.carriageGap * 0.2); 
            c.userData.tOffset = (i + 1) * gapStep;
        }); 
    }
    
    createDetailedLoco() {
        const g = new THREE.Group();
        
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xb71c1c, roughness: 0.3, metalness: 0.6,
            emissive: 0x550000, emissiveIntensity: 0.4
        });
        const blackMat = new THREE.MeshStandardMaterial({color:0x111111, roughness:0.7});
        const goldMat = new THREE.MeshStandardMaterial({color:0xffb300, roughness:0.2, metalness:0.8});

        // 1. é”…ç‚‰ (ç¼©çŸ­åˆ° 5.0ï¼Œæ¯”ä¾‹æ›´åè°ƒ)
        const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 5.0, 16), bodyMat);
        boiler.rotation.x = Math.PI/2; boiler.position.set(0, 3.6, 1.0); g.add(boiler);

        // é©¾é©¶å®¤
        const cab = new THREE.Mesh(new THREE.BoxGeometry(3.8, 5.2, 3.2), bodyMat);
        cab.position.set(0, 4.1, -2.5); g.add(cab);
        
        // çƒŸå›±
        this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.6, 1.8), blackMat);
        this.chimney.position.set(0, 4.5, 2.5); g.add(this.chimney);
        this.smokeSource = this.chimney; 

        // æ’éšœå™¨
        const cow = new THREE.Mesh(new THREE.ConeGeometry(2.0, 1.5, 4), blackMat);
        cow.rotation.x = -Math.PI/2; cow.rotation.y = Math.PI/4; 
        cow.scale.set(1, 0.5, 1); cow.position.set(0, 1.0, 4.5); g.add(cow);

        // è½®ç»„ (æ›´ç´§å‡‘)
        const addWheel = (z, radius) => {
            const wGeo = new THREE.CylinderGeometry(radius, radius, 0.5, 16); wGeo.rotateZ(Math.PI/2);
            const w1 = new THREE.Mesh(wGeo, blackMat); w1.position.set(1.9, radius, z);
            const w2 = new THREE.Mesh(wGeo, blackMat); w2.position.set(-1.9, radius, z);
            g.add(w1); g.add(w2);
            this.wheels.push(w1, w2);
            if(radius > 1.0) { 
                const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.7,8), goldMat);
                hub.rotation.z = Math.PI/2; w1.add(hub); w2.add(hub.clone());
            }
        };
        addWheel(0, 1.3); addWheel(2.2, 1.3); addWheel(-1.5, 1.3); // åŠ¨è½®
        addWheel(4.0, 0.8); // å¯¼è½®

        // ç¯å…‰ (ä¿æŒ)
        const bulb = new THREE.Mesh(new THREE.CircleGeometry(0.5, 32), new THREE.MeshBasicMaterial({color: 0xffaa00}));
        bulb.position.set(0, 5.2, 3.6); g.add(bulb);

        const spriteMat = new THREE.SpriteMaterial({ 
            map: this.glareTexture, color: 0xffdd88, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false 
        });
        const glare = new THREE.Sprite(spriteMat);
        glare.position.set(0, 5.2, 4.0); glare.scale.set(10, 10, 1); g.add(glare);

        const s = new THREE.SpotLight(0xffccaa, 400, 120, 0.8, 0.5); 
        s.position.set(0, 5.2, 3.8); s.target.position.set(0, -5, 30); 
        s.castShadow = true; s.shadow.bias = -0.0001;
        g.add(s); g.add(s.target);
        
        // å…³é”®ï¼šè½¦å¤´åæ–¹çš„è¿æ¥å™¨ (å‡¸å‡º)
        const coupler = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.0, 8), blackMat);
        coupler.rotation.x = Math.PI/2; coupler.position.set(0, 2.0, -4.2); g.add(coupler);
        
        return g;
    }

    createDetailedCar(i) {
        const g = new THREE.Group();
        const colors = [0xb71c1c, 0x1b5e20, 0x0d47a1, 0xff6f00];
        const col = colors[(i-1) % 4];
        
        const bodyMat = new THREE.MeshStandardMaterial({
            color: col, roughness: 0.4, emissive: col, emissiveIntensity: 0.15
        });
        const blackMat = new THREE.MeshStandardMaterial({color:0x111111, roughness: 0.9});
        const winMat = new THREE.MeshStandardMaterial({color:0x000000, emissive: 0xffcc88, emissiveIntensity: 1.5});

        // 1. è½¦èº« (ä½ è®¾å®šçš„ 7.8)
        const carLen = 7.8;
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.4, 3.8, carLen), bodyMat); 
        body.position.y = 3.3; g.add(body);
        
        // 2. è½¦é¡¶ (é€‚é…é•¿åº¦)
        const roof = new THREE.Mesh(new THREE.CylinderGeometry(1.9, 1.9, carLen+0.2, 12, 1, false, 0, Math.PI), new THREE.MeshStandardMaterial({color:0x222222}));
        roof.rotation.z = Math.PI/2; roof.rotation.y = Math.PI/2; 
        roof.position.set(0, 5.2, 0); g.add(roof);
        
        // 3. çª—æˆ·ä¼˜åŒ– (å‡åŒ€åˆ†å¸ƒ 3 ä¸ªçª—æˆ·)
        // çª—æˆ·å°ºå¯¸ç¨å¾®ç¼©å°ä¸€ç‚¹ç‚¹(1.2*1.5)ï¼Œçœ‹èµ·æ¥æ›´ç²¾è‡´
        const winGeo = new THREE.PlaneGeometry(1.2, 1.5);
        const winCount = 3; // å¢åŠ çª—æˆ·æ•°é‡
        
        // è®¡ç®—çª—æˆ·åˆ†å¸ƒï¼š
        // è®©çª—æˆ·åˆ†å¸ƒåœ¨è½¦èº«ä¸­é—´ 5.0 ç±³çš„èŒƒå›´å†…ï¼Œä¸¤å¤´ç•™ç™½ 1.4 ç±³
        const spread = 5.0; 
        const startZ = -spread / 2;
        const step = spread / (winCount - 1);

        for(let side = -1; side <= 1; side += 2) {
            for(let k = 0; k < winCount; k++) {
                const w = new THREE.Mesh(winGeo, winMat);
                // åŠ¨æ€è®¡ç®— Z è½´åæ ‡
                const zPos = startZ + k * step;
                w.position.set(1.71*side, 3.6, zPos);
                w.rotation.y = side*Math.PI/2;
                g.add(w);
            }
        }

        // 4. é£ç´è¿æ¥ (Gangway) - è‡ªåŠ¨é€‚é… carLen
        const gangwayGeo = new THREE.BoxGeometry(2.4, 2.8, 1.2);
        const gangway = new THREE.Mesh(gangwayGeo, blackMat);
        // æ”¾åœ¨è½¦å¤´æœ€å‰ç«¯
        gangway.position.set(0, 3.0, carLen/2 + 0.3); 
        g.add(gangway);

        // 5. è½¬å‘æ¶ (Bogie) - ä½ç½®ä¼˜åŒ–
        // è½¦èº«å˜é•¿äº†ï¼Œè½®å­å¿…é¡»å¾€ä¸¤å¤´ç§»ï¼Œå¦åˆ™è½¦ä¼šæ˜¾å¾—å¾ˆæ™ƒ
        const createBogie = (z) => {
            const b = new THREE.Group(); b.position.set(0, 0, z);
            const wGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.4, 12); wGeo.rotateZ(Math.PI/2);
            const w1 = new THREE.Mesh(wGeo, blackMat); w1.position.set(1.6, 0.65, 0);
            const w2 = new THREE.Mesh(wGeo, blackMat); w2.position.set(-1.6, 0.65, 0);
            
            const beam = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.4, 1.0), blackMat);
            beam.position.y = 0.65;
            
            b.add(w1, w2, beam);
            g.add(b);
            this.wheels.push(w1, w2);
        };
        
        // ä¹‹å‰æ˜¯ 1.4ï¼Œç°åœ¨æ”¹ä¸º 2.8ï¼Œè½®å­æ”¯æ’‘ç‚¹æ›´å¼€é˜”
        createBogie(2.8); 
        createBogie(-2.8);
        
        return g;
    }

    update(delta) {
        const speed = PARAMS.trainSpeed * delta * 0.2;
        this.progress = (this.progress + speed) % 1;
        this.place(this.loco, this.progress);
        this.cars.forEach(c => {
            let t = this.progress - c.userData.tOffset; 
            if(t < 0) t += 1;
            this.place(c, t);
        });

        if(this.wheels) this.wheels.forEach(w => w.rotation.x -= speed * 150 * PARAMS.wheelSpeed);

        if(Math.random() > 0.85) { 
            _vec3.setFromMatrixPosition(this.smokeSource.matrixWorld); 
            _vec3.y += 0.8; 
            this.spawnSmoke(_vec3); 
        }
        this.updateSmoke();
    }

    place(obj, t) {
        const pos = this.curve.getPointAt(t);
        const tangent = this.curve.getTangentAt(t);
        obj.position.copy(pos);
        obj.lookAt(pos.clone().add(tangent)); 
    }

    spawnSmoke(pos) {
        const m = new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.4 + Math.random()*0.3, 0), 
            new THREE.MeshStandardMaterial({
                color: 0xeeeeee, transparent:true, opacity: 0.5, roughness: 1, depthWrite: false 
            })
        );
        m.position.copy(pos); 
        m.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
        this.scene.add(m); 
        this.smokes.push({m, life: 1.0 + Math.random() * 0.5});
    }

    updateSmoke() {
        for(let i=this.smokes.length-1; i>=0; i--) {
            const s = this.smokes[i]; 
            s.life -= 0.015; 
            s.m.position.y += 0.08; 
            s.m.rotation.x += 0.02; 
            const expansion = 1.0 + (1.5 - s.life) * 0.05; 
            s.m.scale.multiplyScalar(expansion); 
            s.m.material.opacity = s.life * 0.4;
            if(s.life <= 0){ 
                this.scene.remove(s.m); 
                this.smokes.splice(i, 1); 
            }
        }
    }
}

        // ============================
        // ğŸ‡ çƒŸèŠ±ç®¡ç†å™¨
        // ============================
        class FireworkManager {
    constructor(scene) {
        this.scene = scene;
        this.rockets = [];   // å­˜å‚¨ä¸Šå‡é˜¶æ®µçš„çƒŸèŠ±
        this.sparkles = [];  // å­˜å‚¨çˆ†ç‚¸åçš„ç²’å­
        
        // 1. ç”Ÿæˆé«˜æ¸…å…‰æ™•è´´å›¾ (128x128ï¼Œè¾¹ç¼˜æ›´æŸ”å’Œ)
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        g.addColorStop(0, 'rgba(255,255,255,1)');    // ä¸­å¿ƒæäº®
        g.addColorStop(0.2, 'rgba(255,255,255,0.8)'); // è¿‡æ¸¡
        g.addColorStop(0.5, 'rgba(255,255,255,0.2)'); // å…‰æ™•
        g.addColorStop(1, 'rgba(0,0,0,0)');           // è¾¹ç¼˜é€æ˜
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, 128, 128);
        this.texture = new THREE.CanvasTexture(canvas);

        // 2. é¢„è®¾ä¸“ä¸šèŠ‚æ—¥é…è‰²ç›˜
        this.palettes = [
            [0xff0000, 0xffaa00, 0xffffff], // ç»å…¸é‡‘çº¢
            [0x00ffff, 0x0000ff, 0xffffff], // å†°é›ªè“
            [0xff00ff, 0xaa00ff, 0xffaaaa], // èµ›åšç´«
            [0x00ff00, 0xffff00, 0xffffff], // åœ£è¯ç»¿
            [0xffffff, 0xffdd88, 0x88ccff], // é“¶æ²³ç™½
        ];
    }

    // å‘å°„é€»è¾‘ï¼šæ”¯æŒç‚¹å‡»åæ ‡ï¼Œä¹Ÿæ”¯æŒè‡ªåŠ¨è®¡ç®—
    launch(targetPos) {
        let startPos;
        // å¦‚æœæ²¡æœ‰ä¼ å…¥åæ ‡ï¼ˆæ¯”å¦‚è‡ªåŠ¨å‘å°„ï¼‰ï¼Œåˆ™åœ¨ç›¸æœºå‰æ–¹éšæœºç”Ÿæˆ
        if (!targetPos) {
            const vec = new THREE.Vector3(0, 0, -60).applyQuaternion(camera.quaternion).add(camera.position);
            startPos = vec.add(new THREE.Vector3((Math.random()-0.5)*80, -20, (Math.random()-0.5)*80));
        } else {
            startPos = targetPos.clone();
        }

        // éšæœºçˆ†ç‚¸é«˜åº¦ï¼š30 ~ 60
        const targetHeight = startPos.y + 60 + Math.random() * 30;
        
        // éšæœºé€‰æ‹©ä¸€ç§é…è‰²
        const palette = this.palettes[Math.floor(Math.random() * this.palettes.length)];

        // åˆ›å»ºä¸Šå‡çš„â€œç«ç®­â€ç²’å­
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
        const mat = new THREE.PointsMaterial({
            color: 0xffddaa, // ç«ç®­å°¾ç„°é¢œè‰²
            size: 2.5,
            map: this.texture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });
        
        const rocket = {
            mesh: new THREE.Points(geo, mat),
            pos: startPos.clone(),
            // ç‰©ç†å…¬å¼ï¼šåˆé€Ÿåº¦ = sqrt(2 * é‡åŠ› * é«˜åº¦å·®)ï¼Œç¡®ä¿åˆšå¥½é£åˆ°ç›®æ ‡é«˜åº¦
            vel: new THREE.Vector3(
                (Math.random()-0.5)*0.5, 
                Math.sqrt(2 * 0.02 * (targetHeight - startPos.y)), 
                (Math.random()-0.5)*0.5
            ),
            targetY: targetHeight,
            palette: palette
        };
        
        rocket.mesh.position.copy(startPos);
        this.scene.add(rocket.mesh);
        this.rockets.push(rocket);
    }

    // è‡ªåŠ¨é½å°„ï¼šä¿ç•™äº†ä½ å†™çš„â€œé¡ºç€é“è½¨å‰æ–¹â€çš„ä¼˜ç§€é€»è¾‘
    launchBurst() {
        if (!train || !trackCurve) return;
        
        // éšæœº 3-5 å‘
        const count = 3 + Math.floor(Math.random() * 3);
        
        for(let i=0; i<count; i++) {
            // 1. é¢„æµ‹ç«è½¦å‰æ–¹ä½ç½® (5% ~ 15% çš„è·¯ç¨‹)
            const lookAhead = 0.05 + Math.random() * 0.10;
            const t = (train.progress + lookAhead) % 1.0;

            // 2. è·å–é“è½¨åæ ‡
            const trackPos = trackCurve.getPointAt(t);

            // 3. æ•£å¸ƒåœ¨é“è½¨ä¸¤ä¾§ 40ç±³èŒƒå›´
            const spread = 40; 
            const randomX = (Math.random() - 0.5) * spread;
            const randomZ = (Math.random() - 0.5) * spread;

            // 4. è®¾å®šèµ·ç‚¹ (Y=-5 è®©å®ƒçœ‹èµ·æ¥ä»é›ªåœ°é‡Œé’»å‡ºæ¥)
            const startPos = new THREE.Vector3(trackPos.x + randomX, -5, trackPos.z + randomZ);
            
            // 5. é”™å³°å‘å°„ï¼Œé¿å…åŒæ—¶å‡ç©ºå¤ªæ­»æ¿
            setTimeout(() => {
                this.launch(startPos);
            }, Math.random() * 800);
        }
    }

    update() {
        // --- é˜¶æ®µ1ï¼šæ›´æ–°ä¸Šå‡çš„ç«ç®­ ---
        for (let i = this.rockets.length - 1; i >= 0; i--) {
            const r = this.rockets[i];
            
            // ç‰©ç†è¿åŠ¨
            r.pos.add(r.vel);
            r.vel.y -= 0.02; // é‡åŠ›ï¼šè¶Šæ¥è¶Šæ…¢
            r.mesh.position.copy(r.pos);

            // å½“é€Ÿåº¦æ¥è¿‘0ï¼ˆåˆ°è¾¾æœ€é«˜ç‚¹ï¼‰æ—¶å¼•çˆ†
            if (r.vel.y <= 0.5) {
                this.scene.remove(r.mesh);
                this.explode(r.pos, r.palette); // ä¼ å…¥ä½ç½®å’Œé¢œè‰²ç›˜
                this.rockets.splice(i, 1);
            }
        }

        // --- é˜¶æ®µ2ï¼šæ›´æ–°çˆ†ç‚¸åçš„çƒŸèŠ±ç²’å­ ---
        for (let i = this.sparkles.length - 1; i >= 0; i--) {
            const s = this.sparkles[i];
            const positions = s.mesh.geometry.attributes.position.array;
            const sizes = s.mesh.geometry.attributes.size.array;
            
            // å¯¿å‘½è¡°å‡
            s.life -= 0.008; 

            for (let k = 0; k < s.count; k++) {
                const idx = k * 3;
                
                // ä½ç½® += é€Ÿåº¦
                positions[idx]   += s.velocities[idx];
                positions[idx+1] += s.velocities[idx+1];
                positions[idx+2] += s.velocities[idx+2];

                // å…³é”®ç‰©ç†ï¼šç©ºæ°”é˜»åŠ› (æ¨¡æ‹Ÿçˆ†ç‚¸åçš„æ€¥å‰§å‡é€Ÿ)
                s.velocities[idx]   *= 0.96;
                s.velocities[idx+1] *= 0.96;
                s.velocities[idx+2] *= 0.96;

                // å…³é”®ç‰©ç†ï¼šé‡åŠ›ä¸‹å 
                s.velocities[idx+1] -= 0.03;

                // è§†è§‰ç‰¹æ•ˆï¼šé—ªçƒ (Twinkle)
                if(Math.random() > 0.5) {
                    // åŸºäºåŸºç¡€å¤§å°è¿›è¡Œéšæœºç¼©æ”¾
                    sizes[k] = s.baseSizes[k] * (0.5 + Math.random() * 0.5) * s.life;
                }
            }

            s.mesh.geometry.attributes.position.needsUpdate = true;
            s.mesh.geometry.attributes.size.needsUpdate = true;
            s.mesh.material.opacity = s.life;

            if (s.life <= 0) {
                // æ¶ˆå¤±å¤„ç†
                this.scene.remove(s.mesh);
                if(s.light) this.scene.remove(s.light);
                this.sparkles.splice(i, 1);
            } else if (s.light) {
                // ç¯å…‰è·Ÿéšç²’å­ä¸­å¿ƒå¹¶æ¸éš
                s.light.intensity = s.life * 15; 
                s.light.position.set(positions[0], positions[1], positions[2]);
            }
        }
    }

    explode(pos, palette) {
        const count = 1000; // ç²’å­æ•°é‡ (æ›´å¤š)
        const positions = new Float32Array(count * 3);
        const velocities = []; 
        const colors = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        const baseSizes = []; // è®°å½•åŸºç¡€å¤§å°ç”¨äºé—ªçƒ

        const colorObj = new THREE.Color();

        for (let i = 0; i < count; i++) {
            positions[i * 3] = pos.x;
            positions[i * 3 + 1] = pos.y;
            positions[i * 3 + 2] = pos.z;

            // çƒå½¢çˆ†ç‚¸é€Ÿåº¦è®¡ç®—
            // é€Ÿåº¦èŒƒå›´ 0.5 ~ 2.2 (ç‚¸å¾—æ›´å¼€)
            const speed = 0.5 + Math.random() * 2.2;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;

            velocities.push(
                speed * Math.sin(phi) * Math.cos(theta),
                speed * Math.sin(phi) * Math.sin(theta),
                speed * Math.cos(phi)
            );

            // ä»è°ƒè‰²ç›˜éšæœºå–è‰²
            const hex = palette[Math.floor(Math.random() * palette.length)];
            colorObj.setHex(hex);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;

            // éšæœºç²’å­å¤§å°
            const s = 1.5 + Math.random() * 2.5; 
            sizes[i] = s;
            baseSizes.push(s);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // æè´¨ï¼šä½¿ç”¨ vertexColors å’Œ AdditiveBlending å®ç°é«˜äº®å åŠ 
        const mat = new THREE.PointsMaterial({
            size: 1.0,
            map: this.texture,
            transparent: true,
            depthWrite: false, // é˜²æ­¢é®æŒ¡
            blending: THREE.AdditiveBlending, // è¶Šé‡å è¶Šäº®
            vertexColors: true // å¯ç”¨é¡¶ç‚¹é¢œè‰²
        });

        const mesh = new THREE.Points(geo, mat);
        this.scene.add(mesh);

        // é¢å¤–ç‰¹æ•ˆï¼šæ·»åŠ ä¸€ä¸ªç‚¹å…‰æºï¼Œç…§äº®å‘¨å›´çš„é›ªå’Œè½¦
        const light = new THREE.PointLight(palette[0], 15, 60);
        light.position.copy(pos);
        this.scene.add(light);

        this.sparkles.push({
            mesh, 
            light,
            count, 
            velocities, 
            baseSizes,
            life: 1.5 + Math.random() * 0.5 // å¯¿å‘½ 1.5~2.0ç§’
        });
    }
}

        // ============================
        // â„ï¸ å¤©æ°”ç³»ç»Ÿ
        // ============================
        class SnowSystem {
            constructor(scene) {
                const count = 3000;
                const pos = [];
                for(let i=0; i<count; i++) {
                    pos.push(Math.random()*600-300, Math.random()*200, Math.random()*600-300);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                // 1. ç”Ÿæˆä¸€ä¸ªç®€å•çš„åœ†å½¢è´´å›¾
const canvas = document.createElement('canvas');
canvas.width = 32; canvas.height = 32;
const context = canvas.getContext('2d');
context.fillStyle = '#ffffff';
context.beginPath();
context.arc(16, 16, 16, 0, Math.PI * 2);
context.fill();
const snowTexture = new THREE.CanvasTexture(canvas);

// 2. åº”ç”¨åˆ°æè´¨
this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({
    color: 0xaaaaaa, // ç°è‰²
    map: snowTexture, // åº”ç”¨åœ†å½¢è´´å›¾
    alphaMap: snowTexture, // ä½¿ç”¨é€æ˜åº¦è´´å›¾
    transparent: true,
    opacity: 0.6,
    size: 0.8, // æœ‰äº†è´´å›¾åï¼Œsize å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ç‚¹
    depthWrite: false, // å…³é”®ï¼šç¦æ­¢å†™å…¥æ·±åº¦ï¼Œé˜²æ­¢é›ªèŠ±é®æŒ¡çƒŸèŠ±æ—¶äº§ç”Ÿé»‘è¾¹
    blending: THREE.AdditiveBlending // å¯é€‰ï¼šå åŠ æ··åˆæ¨¡å¼ï¼Œä¼šè®©é‡å çš„é›ªèŠ±å˜äº®ä¸€ç‚¹ï¼Œä½†ä¸åƒçƒŸèŠ±é‚£ä¹ˆäº®
}));
                scene.add(this.mesh);
            }
            update() {
                const p = this.mesh.geometry.attributes.position.array;
                for(let i=1; i<p.length; i+=3) {
                    p[i] -= 0.25; 
                    if(p[i] < 0) p[i] = 200; // å¾ªç¯ä¸‹è½
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        // (Part 3 ç»“æŸï¼Œè¯·å›å¤ "4" ç»§ç»­)
      
      // (æ¥ Part 3)

        // ============================
        // âš™ï¸ äº¤äº’ä¸ UI è®¾ç½®
        // ============================
        function setupUI() {
            // 1. å¯åŠ¨æŒ‰é’®
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                STATE.started = true;
                // UI åŠ¨ç”»
                document.getElementById('start-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 600);
                document.getElementById('hud').style.opacity = '1';
                document.getElementById('settings-btn').style.opacity = '1';
            });

            // 2. è®¾ç½®å¼¹çª—
            const btn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const overlay = document.getElementById('modal-overlay');
            
            const toggleSettings = () => { 
                STATE.settingsOpen = !STATE.settingsOpen; 
                const disp = STATE.settingsOpen ? 'block' : 'none';
                modal.style.display = disp; 
                overlay.style.display = disp; 
            };
            btn.addEventListener('click', toggleSettings); 
            overlay.addEventListener('click', toggleSettings);

            // 3. GUI å‚æ•°é¢æ¿
            gui = new GUI({ container: modal, width: '100%' });
            gui.title('ğŸ”§ é©¾é©¶å‘˜æ§åˆ¶å°');

            const f1 = gui.addFolder('ğŸ¥ æ™ºèƒ½é•œå¤´');
            f1.add(PARAMS, 'camSmooth', 0.01, 0.1).name('å›æ­£æŸ”å’Œåº¦');
            f1.add(PARAMS, 'camHeightOffset', 2, 20).name('è§†è§’åŸºç¡€é«˜åº¦');

            const f2 = gui.addFolder('ğŸš‚ åˆ—è½¦ç‰©ç†');
            f2.add(PARAMS, 'trainSpeed', 0, 0.4).name('å¼•æ“é€Ÿåº¦');
            f2.add(PARAMS, 'carriageGap', 0.005, 0.02).name('è½¦å¢é—´è·').onChange(() => train.refreshGap());

            const f3 = gui.addFolder('ğŸ’¡ å…‰å½±æ°›å›´');
            f3.add(PARAMS, 'moonIntensity', 0, 5).name('æœˆå…‰äº®åº¦').onChange(v => lights.moon.intensity = v);
            f3.add(PARAMS, 'fogDensity', 0, 0.01).name('å¤§é›¾æµ“åº¦').onChange(v => scene.fog.density = v);
            f3.add(PARAMS, 'bloomStrength', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
            
            const updateEmis = () => emissiveObjects.forEach(o => {
                if(o.userData.type === 'bulb') o.material.emissiveIntensity = PARAMS.bulbBrightness;
                if(o.userData.type === 'headlight') o.material.emissiveIntensity = PARAMS.trainLightPower;
            });
            f3.add(PARAMS, 'bulbBrightness', 0, 50).name('å½©ç¯äº®åº¦').onChange(updateEmis);
            f3.add(PARAMS, 'trainLightPower', 0, 100).name('è½¦å¤´ç¯äº®åº¦').onChange(updateEmis);

			const f4 = gui.addFolder('ğŸ† èŠ‚æ—¥åº†å…¸');
			
			// 1. æ‰‹åŠ¨é½å°„æŒ‰é’®
			const fwControls = {
			    burst: () => fireworkMgr.launchBurst()
			};
			f4.add(fwControls, 'burst').name('âœ¨ ç«‹å³é½å°„');
			
			// 2. è‡ªåŠ¨æ’­æ”¾å¼€å…³é€»è¾‘
			const toggleAuto = (enabled) => {
			    if(autoFwTimer) clearInterval(autoFwTimer); // å…ˆæ¸…é™¤æ—§çš„
			    
			    if(enabled) {
			        // ç«‹å³å‘å°„ä¸€æ¬¡
			        fireworkMgr.launchBurst();
			        // å¼€å¯å®šæ—¶å™¨
			        autoFwTimer = setInterval(() => {
			            if(STATE.started) fireworkMgr.launchBurst();
			        }, PARAMS.fwInterval * 1000);
			    }
			};
			
			f4.add(PARAMS, 'autoFireworks').name('è‡ªåŠ¨çƒŸèŠ±ç§€').onChange(toggleAuto);
			
			// 3. é¢‘ç‡è°ƒæ•´
			f4.add(PARAMS, 'fwInterval', 0.5, 5.0).name('å‘å°„é—´éš”(ç§’)').onChange(() => {
			    // å¦‚æœå½“å‰æ˜¯å¼€å¯çŠ¶æ€ï¼Œéœ€è¦é‡ç½®å®šæ—¶å™¨è®©æ–°æ—¶é—´ç”Ÿæ•ˆ
			    if(PARAMS.autoFireworks) toggleAuto(true);
			});

            // 4. å…¨å±€äº¤äº’ç›‘å¬
            // ç‚¹å‡»æ”¾çƒŸèŠ± (é¿å¼€è®¾ç½®å¼¹çª—)
            // éœ€è¦å¼•å…¥ Raycaster æ¥æ£€æµ‹ç‚¹å‡»ä½ç½®
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			
			window.addEventListener('pointerdown', (e) => {
			    if(STATE.started && !STATE.settingsOpen) {
			        // 1. å°†é¼ æ ‡åæ ‡å½’ä¸€åŒ–ä¸º -1 åˆ° +1
			        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
			        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
			
			        // 2. å‘å°„å°„çº¿
			        raycaster.setFromCamera(mouse, camera);
			
			        // 3. æ£€æµ‹å°„çº¿æ˜¯å¦å‡»ä¸­åœ°é¢
			        // æ³¨æ„ï¼šå¦‚æœä½ æ”¹äº† groundMesh å˜é‡åï¼Œè¿™é‡Œè¦å¯¹åº”
			        const intersects = raycaster.intersectObject(groundMesh);
			
			        if (intersects.length > 0) {
			            // 4. è·å–å‡»ä¸­ç‚¹çš„åæ ‡ï¼Œå¹¶è®©çƒŸèŠ±ä»è¿™é‡Œå‘å°„
			            // y è½´ç¨å¾®åŠ ä¸€ç‚¹é«˜åº¦ï¼Œé¿å…å®Œå…¨è´´åœ¨åœ°ä¸Š
			            const point = intersects[0].point;
			            point.y += 0.5; 
			            fireworkMgr.launch(point);
			        } else {
			            // å¦‚æœç‚¹åˆ°äº†å¤©ç©ºï¼Œå°±éšæœºå‘å°„ï¼ˆå¯é€‰ï¼‰
			            fireworkMgr.launch();
			        }
			    }
			});
            
            // åŒå‡»åˆ‡æ¢è§†è§’
            window.addEventListener('dblclick', () => {
                if(!STATE.started) return;
                STATE.viewMode = STATE.viewMode === 'FOLLOW' ? 'GOD' : 'FOLLOW';
                
                // æ›´æ–° HUD æ–‡å­—
                const text = STATE.viewMode === 'FOLLOW' ? "æ™ºèƒ½é©¾é©¶æ¨¡å¼" : "ä¸Šå¸ä¿¯ç°æ¨¡å¼";
                document.getElementById('hud').querySelector('span').innerText = text;
                
                // åˆ‡æ¢åˆ°ä¸Šå¸è§†è§’æ—¶ï¼Œé‡ç½®ç›®æ ‡åˆ°ä¸­å¿ƒï¼Œæ–¹ä¾¿æ“ä½œ
                if(STATE.viewMode === 'GOD') controls.target.set(0,0,0);
            });
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // é˜²æ­¢ç©¿åœ°
            controls.minDistance = 10; 
            controls.maxDistance = 600;
            
            // å…³é”®ï¼šç›‘å¬ç”¨æˆ·äº¤äº’çŠ¶æ€
            // å½“ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨å±å¹•æ—¶ï¼Œæš‚åœç›¸æœºçš„è‡ªåŠ¨å›æ­£ï¼Œé¿å…â€œæŠ¢å¤ºâ€æ§åˆ¶æƒ
            controls.addEventListener('start', () => STATE.isUserInteracting = true);
            controls.addEventListener('end', () => STATE.isUserInteracting = false);
        }

        // ============================
        // ğŸ¥ æ ¸å¿ƒåŠ¨ç”»å¾ªç¯
        // ============================
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. æ›´æ–°å„ç³»ç»Ÿ
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();

            // 2. æ™ºèƒ½è·Ÿéšé€»è¾‘ (Smart TPS)
            if (STATE.started && STATE.viewMode === 'FOLLOW' && train) {
                const locoPos = train.loco.position;
                
                // æ ¸å¿ƒ A: é”å®šæ§åˆ¶å™¨ä¸­å¿ƒåˆ°ç«è½¦å¤´
                controls.target.copy(locoPos);

                // æ ¸å¿ƒ B: è‡ªåŠ¨å›æ­£ (ä»…å½“ç”¨æˆ·æ¾æ‰‹æ—¶)
                if (!STATE.isUserInteracting) {
                    // è·å–å½“å‰ç”¨æˆ·ç¼©æ”¾çš„è·ç¦» (Distance Memory)
                    const currentDist = camera.position.distanceTo(locoPos);
                    
                    // è·å–ç«è½¦æ­£åæ–¹å‘é‡ (-Zæ–¹å‘)
                    // (è½¦å¤´æ˜¯æŒ‡å‘åˆ‡çº¿çš„ï¼Œæˆ‘ä»¬å‡è®¾è½¦å¤´æ¨¡å‹çš„+Zæ˜¯å‰æ–¹)
                    // æ³¨æ„ï¼šåœ¨ TrainSystem.place ä¸­æˆ‘ä»¬ç”¨äº† lookAt(pos - tangent)
                    // è¿™æ„å‘³ç€ç‰©ä½“çš„ -Z æŒ‡å‘äº†åæ–¹ï¼Œ+Z æŒ‡å‘äº†å‰æ–¹ã€‚
                    // æ‰€ä»¥è·å–åæ–¹å¯ä»¥ç›´æ¥å–ç‰©ä½“åæ ‡ç³»çš„ -Z è½´ã€‚
                    const backVec = new THREE.Vector3(0, 0, -1).applyQuaternion(train.loco.quaternion).normalize();
                    
                    // è®¡ç®—ç†æƒ³ä½ç½®
                    // ä¿æŒå½“å‰çš„ç¼©æ”¾è·ç¦» (currentDist)
                    // å¹¶åŠ ä¸ŠåŸºç¡€é«˜åº¦åç§»
                    const idealPos = locoPos.clone()
                        .add(backVec.multiplyScalar(currentDist)) 
                        .add(new THREE.Vector3(0, PARAMS.camHeightOffset, 0)); 

                    // æŸ”å’Œæ’å€¼ç§»åŠ¨ (Soft Lock)
                    camera.position.lerp(idealPos, PARAMS.camSmooth);
                }
            } 
            // 3. å¾…æœºåŠ¨ç”» (æœªå¼€å§‹æ—¶)
            else if (!STATE.started) {
                const t = Date.now() * 0.0001;
                camera.position.set(Math.sin(t)*200, 120, Math.cos(t)*200);
                camera.lookAt(0,0,0);
            }

            controls.update();
            composer.render();
        }

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body> 
</html>
