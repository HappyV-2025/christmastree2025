<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8"><meta name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Christmas Express: Definitive Edition</title>
        <style>
    body{margin:0;overflow:hidden;background:#000;font-family:'Segoe UI',sans-serif;user-select:none}
    #canvas-container{width:100vw;height:100vh;display:block}
    /* UI Overlay */
    #start-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle at center,#1b2028 0%,#000 100%);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100;transition:opacity 0.8s}
    .card{background:rgba(255,255,255,0.06);padding:40px;border-radius:24px;border:1px solid rgba(255,255,255,0.1);text-align:center;backdrop-filter:blur(20px);box-shadow:0 40px 80px rgba(0,0,0,0.6);width:400px}
    h1{color:#ffb300;margin:0 0 20px;letter-spacing:4px;text-shadow:0 0 30px rgba(255,165,0,0.5);text-transform:uppercase}
    .tips{color:#ccc;font-size:14px;line-height:2.2;text-align:left;margin-left:30px;margin-bottom:30px}
    .k{color:#4fc3f7;font-weight:bold;margin-right:8px;border-bottom:1px dashed #4fc3f7}
    button{background:linear-gradient(135deg,#d32f2f,#b71c1c);color:#fff;border:none;padding:16px 60px;font-size:20px;border-radius:50px;cursor:pointer;box-shadow:0 10px 30px rgba(211,47,47,0.4);transition:0.2s;font-weight:bold;letter-spacing:1px}
    button:hover{transform:scale(1.05);box-shadow:0 15px 40px rgba(211,47,47,0.6)}
    #hud{opacity:0;transition:1s}
    .tag{background:rgba(0,0,0,0.7);color:#fff;padding:8px 18px;border-radius:30px;font-size:14px;border:1px solid #ffffff22;backdrop-filter:blur(5px);display:flex;align-items:center;gap:10px}
    .dot{width:8px;height:8px;background:#00ff00;border-radius:50%;box-shadow:0 0 8px #00ff00;transition:0.3s}
    .dot.stop{background:#ff3300;box-shadow:0 0 8px #ff3300}
    #settings-btn{width:44px;height:44px;background:rgba(255,255,255,0.1);border-radius:50%;border:1px solid #ffffff33;color:#fff;font-size:20px;display:flex;justify-content:center;align-items:center;cursor:pointer;opacity:0;backdrop-filter:blur(5px);transition:0.3s}
    #settings-modal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:30;display:none;width:320px}
    #modal-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:25;display:none;background:rgba(0,0,0,0.5)}
    #loading{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);color:#666;font-size:12px;letter-spacing:2px}
    /* å³ä¸‹è§’çƒŸèŠ±æŒ‰é’® */
    #firework-btn{position:absolute;bottom:30px;right:30px;z-index:20;width:60px;height:60px;background:radial-gradient(circle at 30% 30%,#ff6b6b,#d32f2f);border-radius:50%;border:2px solid #ff8a80;color:#fff;font-size:28px;display:flex;justify-content:center;align-items:center;cursor:pointer;opacity:0;transition:all 0.3s;box-shadow:0 4px 20px rgba(211,47,47,0.5)}
    #firework-btn:hover{transform:scale(1.1);box-shadow:0 6px 30px rgba(211,47,47,0.7)}
    #firework-btn:active{transform:scale(0.95)}
    #firework-btn.burst{animation:burst 0.4s ease-out}
    @keyframes burst{0%{transform:scale(1);box-shadow:0 4px 20px rgba(211,47,47,0.5)}50%{transform:scale(1.3);box-shadow:0 0 40px rgba(255,200,100,0.9),0 0 80px rgba(255,100,100,0.6)}100%{transform:scale(1);box-shadow:0 4px 20px rgba(211,47,47,0.5)}}
    /* HUDå¯åœæŒ‰é’® */
    #train-toggle{background:none;border:none;color:#fff;font-size:18px;cursor:pointer;padding:4px 8px;margin-left:8px;border-radius:8px;transition:0.2s}
    #train-toggle:hover{background:rgba(255,255,255,0.15)}
    /* HUDçŠ¶æ€å¯ç‚¹å‡» */
    #hud-status{cursor:pointer;transition:0.2s}
    #hud-status:hover{color:#4fc3f7}
    /* é¡¶éƒ¨å¯¼èˆªæ å®¹å™¨ */
    #top-bar{position:absolute;top:0;left:0;right:0;z-index:15;display:flex;justify-content:space-between;align-items:flex-start;padding:20px;pointer-events:none}
    #top-bar>*{pointer-events:auto}
    /* åœ£è¯å€’è®¡æ—¶ */
    #countdown-wrap{position:absolute;top:70px;right:20px;opacity:0;transition:opacity 0.5s}
    #countdown-trigger{background:linear-gradient(135deg,rgba(183,28,28,0.85),rgba(139,0,0,0.85));color:#fff;padding:6px 14px;border-radius:20px;font-size:13px;cursor:pointer;border:1px solid rgba(255,215,0,0.5);box-shadow:0 2px 12px rgba(0,0,0,0.3);display:flex;align-items:center;gap:6px;transition:all 0.3s;backdrop-filter:blur(5px)}
    #countdown-trigger:hover{transform:scale(1.05);box-shadow:0 4px 20px rgba(255,215,0,0.4)}
    #countdown-trigger .arrow{font-size:10px;transition:transform 0.3s}
    #countdown-trigger.expanded .arrow{transform:rotate(180deg)}
    #countdown-panel{position:absolute;top:100%;right:0;margin-top:10px;background:linear-gradient(145deg,rgba(20,60,20,0.95),rgba(139,0,0,0.9));border-radius:16px;padding:16px 24px;text-align:center;opacity:0;visibility:hidden;transition:all 0.4s cubic-bezier(0.4,0,0.2,1);border:2px solid rgba(255,215,0,0.4);box-shadow:0 8px 32px rgba(0,0,0,0.5);pointer-events:none;min-width:200px}
    #countdown-panel.show{opacity:1;visibility:visible;pointer-events:auto}
    #countdown-panel .title{color:#ffd700;font-size:14px;margin-bottom:8px;text-shadow:0 0 10px rgba(255,215,0,0.5)}
    #countdown-panel .time{color:#fff;font-size:28px;font-weight:bold;text-shadow:0 0 20px rgba(255,255,255,0.3);letter-spacing:2px}
    #countdown-panel .time span{color:#4fc3f7}
    #countdown-panel .hint{color:rgba(255,255,255,0.6);font-size:11px;margin-top:10px}
    #countdown-panel .decorations{position:absolute;top:-8px;left:50%;transform:translateX(-50%);font-size:20px}
    /* å“åº”å¼ */
    @media(max-width:480px){#countdown-trigger{padding:5px 10px;font-size:12px}#countdown-trigger .text{display:none}#countdown-panel{min-width:160px;padding:12px 16px}#countdown-panel .time{font-size:22px}}
</style>
    </head>
    <body>
        <div id="start-screen"><div class="card">
                <h1>ğŸ„ åœ£è¯å¿«ä¹</h1>
                <div class="tips">
                    <div><span class="k">ğŸš‚ ç‚¹å‡»è½¦å¤´</span> èƒŒæ™¯éŸ³ä¹ å¼€/å…³</div>
                    <div><span class="k">ğŸ”” ç‚¹å‡»è½¦å¢</span> é“ƒé“›å“èµ· + æ‰”å‡ºç¤¼ç›’</div>
                    <div><span class="k">ğŸ† å³ä¸‹æŒ‰é’®</span> ç‡ƒæ”¾çƒŸèŠ±</div>
                    <div><span class="k">ğŸ‘† æ‹–åŠ¨æ—‹è½¬</span> 360Â° è‡ªç”±è§‚å¯Ÿ</div>
                </div>
                <button id="start-btn">é¸£ç¬›å‘è½¦</button>
            </div>
        </div>
        <div id="top-bar">
            <div id="hud"><div class="tag"><div id="d-status" class="dot"></div><span id="hud-status">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span><button id="train-toggle">â¸ï¸</button></div></div>
            <div id="countdown-wrap">
                <div id="countdown-trigger">
                    <span>ğŸ„</span>
                    <span class="text">åœ£è¯</span>
                    <span id="countdown-days">--</span>å¤©
                    <span class="arrow">â–¼</span>
                </div>
                <div id="countdown-panel">
                    <div class="decorations">ğŸ…</div>
                    <div class="title">âœ¨ è·ç¦»åœ£è¯èŠ‚è¿˜æœ‰ âœ¨</div>
                    <div class="time" id="countdown-detail">--å¤© --:--:--</div>
                    <div class="hint">ç‚¹å‡»ä»»æ„å¤„æ”¶èµ·</div>
                </div>
            </div>
            <div id="settings-btn">âš™ï¸</div>
        </div>
        <div id="firework-btn">ğŸ†</div>
        <div id="modal-overlay"></div><div id="settings-modal"></div>
        <div id="loading">æ­£åœ¨è£…è½½ç¤¼ç‰©ä¸é­”æ³•...</div>
        <div id="canvas-container"></div>

        <script
            type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
        <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

// çƒŸèŠ±éŸ³æ•ˆé¢„è®¾
const SOUND_STYLES = [
    // 0. æ ‡å‡†å¹³è¡¡ (Standard)
    { name: "æ ‡å‡†", noise: {f:800, q:1, vol:3, dur:1.5}, kick: {f:60, vol:2.5, dur:0.3} },

    // 1. å·¨å‹é‡ç‚® (Heavy/Deep) - é€‚åˆå¤§çƒŸèŠ±ï¼Œä½éŸ³é‡ï¼Œå›å£°é•¿
    { name: "å·¨å‹é‡ç‚®", noise: {f:300, q:0.5, vol:4, dur:2.5}, kick: {f:50, vol:4.0, dur:0.5} },

    // 2. é—·å“ (Muffled/Distant) - åƒæ˜¯åœ¨è¿œå¤„çš„çˆ†ç‚¸
    { name: "è¿œå¤„é—·å“", noise: {f:200, q:0, vol:3, dur:1.0}, kick: {f:40, vol:2.0, dur:0.4} },

    // 3. é‡‘å±å›éŸ³ (Metallic) - å¸¦æœ‰å…±é¸£æ„Ÿ
    { name: "é‡‘å±å›éŸ³", noise: {f:1200, q:10, vol:2, dur:1.8}, kick: {f:80, vol:1.5, dur:0.2} },

    // 4. ç©ºæ°”çˆ†ç ´ (Airy) - ä¸»è¦æ˜¯æ°”æµå£°ï¼Œæ¯”è¾ƒæŸ”å’Œ
    { name: "ç©ºæ°”çˆ†ç ´", noise: {f:600, q:0.1, vol:2, dur:0.8}, kick: {f:30, vol:3.0, dur:0.4} },

    // 5. ç¤¼èŠ±å¼¹ (Shell) - å…ˆæœ‰ä¸€æ®µå°–å•¸ï¼ˆæ¨¡æ‹Ÿï¼‰ï¼Œè¿™é‡Œä¸»è¦è¡¨ç°ç‚¸å¼€çš„æ•£è½æ„Ÿ
    { name: "ç¤¼èŠ±æ•£è½", noise: {f:1000, q:0.5, vol:1.5, dur:3.0}, kick: {f:55, vol:2.0, dur:0.2} },

    // 6. æè‡´éœ‡æ’¼ (Impact) - ç”šè‡³ä¼šæœ‰ç‚¹ç ´éŸ³çš„æ„Ÿè§‰
    { name: "æè‡´éœ‡æ’¼", noise: {f:500, q:2, vol:6, dur:2.0}, kick: {f:45, vol:5.0, dur:0.6} },
];

class AudioEngine {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.nextChug = 0;
        this.bgmTimer = null;
        this.isBgmPlaying = false;
        this.lastNoiseVal = 0;

        // ğŸšï¸ é»˜è®¤éŸ³é‡é…ç½®
        this.vol = {
            master: 0.7,    // æ€»éŸ³é‡ç¨å¤§
            bgm: 0.6,       // BGM é€‚ä¸­ï¼Œä¸è¦ç›–è¿‡éŸ³æ•ˆ
            train: 0.8,     // ç«è½¦å£°æ¸…æ™°
            firework: 1.0   // çƒŸèŠ±éœ‡æ’¼
        };
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // æ··éŸ³é“¾è·¯
            this.nodes.master = this.ctx.createGain();
            this.nodes.bgm = this.ctx.createGain();
            this.nodes.train = this.ctx.createGain();
            this.nodes.fw = this.ctx.createGain();

            this.nodes.bgm.connect(this.nodes.master);
            this.nodes.train.connect(this.nodes.master);
            this.nodes.fw.connect(this.nodes.master);
            this.nodes.master.connect(this.ctx.destination);

            this.updateVols();

            // ç”Ÿæˆé€šç”¨å™ªéŸ³ Buffer (ç”¨äºæ¨¡æ‹Ÿæ°”æµã€çˆ†ç‚¸)
            const bSize = this.ctx.sampleRate * 2;
            this.noiseBuf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const out = this.noiseBuf.getChannelData(0);
            for (let i = 0; i < bSize; i++) {
                // æ··åˆç™½å™ªéŸ³å’Œç²‰çº¢å™ªéŸ³ï¼Œè´¨æ„Ÿæ›´å¥½
                const white = Math.random() * 2 - 1;
                out[i] = (this.lastNoiseVal + (0.02 * white)) / 1.02; // ç®€å•çš„ä½é€šæ»¤æ³¢æ¨¡æ‹Ÿç²‰çº¢å™ªéŸ³
                this.lastNoiseVal = out[i];
                out[i] *= 3.5; // è¡¥å¿éŸ³é‡
            }
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    
    updateVols() {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        this.nodes.master.gain.setTargetAtTime(this.vol.master, t, 0.1);
        this.nodes.bgm.gain.setTargetAtTime(this.vol.bgm, t, 0.1);
        this.nodes.train.gain.setTargetAtTime(this.vol.train, t, 0.1);
        this.nodes.fw.gain.setTargetAtTime(this.vol.firework, t, 0.1);
    }

    // ğŸµ BGM: ç»å¯¹æ ‡å‡†ç‰ˆã€ŠJingle Bellsã€‹ (ä¸»æ­Œ+å‰¯æ­Œå®Œæ•´å¾ªç¯)
    playBGM() {
        if(!this.ctx || this.isBgmPlaying) return;
        this.isBgmPlaying = true;
        
        // æ ‡å‡†éŸ³é«˜ (Cå¤§è°ƒ)
        const N = { 
            G3:196, A3:220, B3:247, 
            C4:262, D4:294, E4:330, F4:349, G4:392, A4:440, B4:494, 
            C5:523, D5:587, E5:659 
        };
        
        // åŸºç¡€æ‹é€Ÿ (BPM çº¦ 100)
        const Q = 360;  // å››åˆ†éŸ³ç¬¦ (1æ‹)
        const H = 720; // äºŒåˆ†éŸ³ç¬¦ (2æ‹)
        const W = 1080; // å…¨éŸ³ç¬¦ (4æ‹)
        
        const melody = [
            // === ä¸»æ­Œ Verse (Dashing through the snow) ===
            // 1. Dashing through the snow
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 2. In a one horse open sleigh
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 3. O'er the fields we go
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.B3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 4. Laughing all the way
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:H}, {n:0,d:Q}, {n:0,d:Q},
            
            // 5. Bells on bobtail ring
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 6. Making spirits bright
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 7. What fun it is to ride and sing
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q},
            // 8. A sleighing song tonight
            {n:N.A4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:H}, {n:N.G4,d:H}, // æœ€åG4æ˜¯è¿‡æ¸¡

            // === å‰¯æ­Œ Chorus (Jingle Bells) ===
            // 9. Jingle bells, jingle bells
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 10. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 11. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 12. In a one horse open sleigh
            {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:H}, {n:N.G4,d:H},

            // 13. Jingle bells, jingle bells (Repeat)
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 14. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 15. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 16. In a one horse open sleigh! (Ending)
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:W}, {n:0,d:W}
        ];

        let idx = 0;
        const playNext = () => {
            if(!this.isBgmPlaying) return;
            const note = melody[idx];
            if(note.n > 0) {
                const t = this.ctx.currentTime, dur = note.d/1000;
                
                // ğŸ¹ éŸ³è‰²æ ¸å¿ƒï¼šé«˜é¢‘æ³›éŸ³å åŠ 
                const playLayer = (freq, type, vol, decay) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = type;
                    osc.frequency.value = freq;
                    const gain = this.ctx.createGain();
                    gain.connect(this.nodes.bgm);
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(vol, t + 0.01); // æå¿«èµ·éŸ³
                    gain.gain.exponentialRampToValueAtTime(0.001, t + decay);
                    osc.start(t); osc.stop(t + decay + 0.1);
                };

                // 1. åŸºéŸ³ (Sine) - æ¸©æš–çš„ä¸»ä½“
                playLayer(note.n, 'sine', 0.6, dur * 1.5);
                // 2. äºŒæ¬¡è°æ³¢ (Sine) - å¢åŠ åšåº¦
                playLayer(note.n * 2, 'sine', 0.3, dur * 1.2);
                // 3. æ•²å‡»å£° (Triangle) - ç¬é—´çš„é«˜é¢‘ï¼Œæ¨¡æ‹Ÿæ•²å‡»é‡‘å±ç‰‡
                playLayer(note.n * 4, 'triangle', 0.06, 0.1); 
                // 4. ç©ºçµæ„Ÿ (Detuned Sine)
                playLayer(note.n + 5, 'sine', 0.6, dur);
            }
            this.bgmTimer = setTimeout(playNext, note.d);
            idx = (idx + 1) % melody.length;
        };
        playNext();
    }
    
    stopBGM() { this.isBgmPlaying = false; clearTimeout(this.bgmTimer); }

    // ğŸš‚ åšé‡è’¸æ±½é¸£ç¬› (Steam Blast)
    whistle() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        // è®¾å®šé¸£ç¬›æ—¶é•¿ä¸º 2.5 ç§’ (ä¹‹å‰çš„ 12ç§’å¤ªé•¿äº†ï¼Œä¸çœŸå®)
        const duration = 2.5; 

        const masterGain = this.ctx.createGain();
        masterGain.connect(this.nodes.train);

        // 1. æ ¸å¿ƒéŸ³è°ƒï¼šä½¿ç”¨â€œé”¯é½¿æ³¢â€åŒéŸ³ (æ¨¡æ‹Ÿé“œç®¡å…±é¸£)
        // é¢‘ç‡é€‰æ‹©ï¼šF4 (349Hz) å’Œ G#4 (415Hz) æ„æˆå°ä¸‰åº¦ï¼Œç»å…¸æ±½ç¬›å£°
        [349, 415].forEach(freq => {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth'; // é”¯é½¿æ³¢æ¯”æ­£å¼¦æ³¢æ›´ç²—çŠ·
            
            // åŠ¨æ€é¢‘ç‡ï¼šæ¨¡æ‹Ÿæ°”å‹å†²å‡»ï¼Œèµ·éŸ³æ—¶éŸ³è°ƒå¾®å‡
            osc.frequency.setValueAtTime(freq, t);
            osc.frequency.linearRampToValueAtTime(freq + 5, t + 0.2); 
            osc.frequency.linearRampToValueAtTime(freq, t + duration);

            // ä½é€šæ»¤æ³¢ï¼šå»æ‰é”¯é½¿æ³¢è¿‡äºåˆºè€³çš„é«˜é¢‘ï¼Œè®©å£°éŸ³å˜â€œé—·â€å˜åš
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            osc.connect(filter);
            filter.connect(masterGain);
            
            osc.start(t);
            osc.stop(t + duration + 0.5); // ç•™å‡ºå°¾éŸ³æ—¶é—´
        });

        // 2. å–·æ°”å™ªéŸ³ï¼šæ¨¡æ‹Ÿè’¸æ±½å–·å‡ºçš„â€œå˜¶å˜¶â€å£°
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        
        // å™ªéŸ³æ»¤æ³¢ï¼šåªä¿ç•™ä¸­é¢‘ï¼Œæ¨¡æ‹Ÿåšé‡çš„è’¸æ±½æŸ±ï¼Œè€Œä¸æ˜¯å°–é”çš„æ¼æ°”
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.value = 600; 
        noiseFilter.Q.value = 1.0; // å®½å¸¦
        
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.value = 0.6; // å™ªéŸ³å æ¯”é€‚ä¸­

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(masterGain);
        
        noise.start(t);
        noise.stop(t + duration + 0.5);

        // 3. å…³é”®ä¿®å¤ï¼šADSR åŒ…ç»œ (ä¿æŒéŸ³é‡ï¼)
        masterGain.gain.setValueAtTime(0, t);
        
        // Attack: å¿«é€Ÿè¾¾åˆ°æœ€å¤§éŸ³é‡ (0.2ç§’)
        masterGain.gain.linearRampToValueAtTime(0.8, t + 0.2);
        
        // Sustain: ä¿æŒéŸ³é‡å¹³ç¨³ (ç›´åˆ° duration ç»“æŸ)
        masterGain.gain.setValueAtTime(0.8, t + duration);
        
        // Release: å¿«é€Ÿæ·¡å‡º (0.4ç§’) - æ¨¡æ‹Ÿé˜€é—¨å…³é—­
        masterGain.gain.exponentialRampToValueAtTime(0.001, t + duration + 0.4);
    }

    // ğŸš‚ ç«è½¦å–·æ°”å£°
    chug(speed) {
        if (!this.ctx || speed < 0.01) return;
        const t = this.ctx.currentTime;
        const interval = Math.max(0.1, 1.0 / (speed * 40)); 
        
        if (t >= this.nextChug) {
            this.nextChug = t + interval;
            const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuf;
            
            // ä½é€šæ»¤æ³¢ï¼Œæ¨¡æ‹Ÿé‡ç‰©æ’å‡»
            const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; 
            f.frequency.value = 150 + speed * 1500; 

            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.5 + speed, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); // é•¿ä¸€ç‚¹çš„å°¾éŸ³

            src.connect(f); f.connect(g); g.connect(this.nodes.train);
            src.start(t); src.stop(t + 0.2);
        }
    }

    // ğŸ”” åœ£è¯é“ƒé“›å£°ï¼ˆJingle Bell é£æ ¼ï¼‰
    bell() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;

        // åœ£è¯é“ƒé“›çš„ç‰¹å¾ï¼šæ¸…è„†ã€æ˜äº®ã€æœ‰é‡‘å±å…±é¸£
        // ä½¿ç”¨æ›´é«˜çš„é¢‘ç‡å’Œéè°æ³¢æ³›éŸ³æ¨¡æ‹ŸçœŸå®é“ƒé“›
        const bellFreqs = [
            { f: 2600, vol: 0.25, decay: 0.6 },   // åŸºé¢‘
            { f: 3900, vol: 0.15, decay: 0.4 },   // 1.5å€æ³›éŸ³ï¼ˆéè°æ³¢ï¼Œé“ƒé“›ç‰¹å¾ï¼‰
            { f: 5200, vol: 0.08, decay: 0.3 },   // 2å€æ³›éŸ³
            { f: 6500, vol: 0.04, decay: 0.2 },   // é«˜é¢‘é—ªå…‰
        ];

        bellFreqs.forEach(({ f, vol, decay }) => {
            const osc = this.ctx.createOscillator();
            osc.type = 'sine';
            // è½»å¾®é¢‘ç‡æŠ–åŠ¨ï¼Œæ¨¡æ‹Ÿé“ƒé“›éœ‡åŠ¨
            osc.frequency.setValueAtTime(f, t);
            osc.frequency.exponentialRampToValueAtTime(f * 0.998, t + decay);

            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + decay);

            osc.connect(gain);
            gain.connect(this.nodes.train);
            osc.start(t);
            osc.stop(t + decay + 0.1);
        });

        // æ•²å‡»ç¬æ€ï¼šçŸ­ä¿ƒçš„å™ªéŸ³æ¨¡æ‹Ÿé‡‘å±ç¢°æ’
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 4000;
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(0.08, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.nodes.train);
        noise.start(t);
        noise.stop(t + 0.05);
    }

    // styleIndex: ä¼ å…¥åˆ™é€‰æ‹©ç‰¹å®šé£æ ¼ï¼Œä¸ä¼ åˆ™éšæœº
    explode(styleIndex = -1) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // 1. é€‰æ‹©é£æ ¼
        if (styleIndex === -1) {
            // éšæœºé€‰æ‹©
            styleIndex = Math.floor(Math.random() * SOUND_STYLES.length);
        }
        // é˜²æ­¢è¶Šç•Œ
        const style = SOUND_STYLES[styleIndex % SOUND_STYLES.length];
        
        // éšæœºå£°åƒ (Pan): -0.8(å·¦) ~ 0.8(å³)
        const pan = (Math.random() - 0.5) * 1.6;
        
        // -------------------------------------------
        // å±‚çº§ A: çˆ†è£‚å™ªéŸ³ (Texture Layer)
        // -------------------------------------------
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuf;
        // ç¨å¾®éšæœºä¸€ç‚¹éŸ³è°ƒï¼Œé¿å…æ¯æ¬¡å®Œå…¨ä¸€æ ·
        src.playbackRate.value = 0.8 + Math.random() * 0.4; 

        // æ»¤æ³¢å™¨ (å†³å®šæ˜¯é—·å“è¿˜æ˜¯è„†å“)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = style.noise.q; // å…±æŒ¯å³°
        
        // é¢‘ç‡åŒ…ç»œ
        if (style.noise.slide) {
            // ç§‘å¹»æ•ˆæœï¼šé¢‘ç‡å¿«é€Ÿæ»‘åŠ¨
            filter.frequency.setValueAtTime(style.noise.f * 2, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + style.noise.dur);
        } else {
            // è‡ªç„¶æ•ˆæœï¼šé¢‘ç‡éšæ—¶é—´ç•¥å¾®è¡°å‡
            filter.frequency.setValueAtTime(style.noise.f, t);
            filter.frequency.exponentialRampToValueAtTime(style.noise.f * 0.5, t + style.noise.dur);
        }

        // å£°åƒå®šä½
        const panner = this.ctx.createStereoPanner();
        panner.pan.value = pan;

        // éŸ³é‡åŒ…ç»œ
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, t);
        env.gain.linearRampToValueAtTime(style.noise.vol, t + 0.02); // æå¿«èµ·éŸ³
        env.gain.exponentialRampToValueAtTime(0.01, t + style.noise.dur); // è¡°å‡

        // è¿æ¥ A
        src.connect(filter);
        filter.connect(panner);
        panner.connect(env);
        env.connect(this.nodes.fw);
        
        src.start(t);
        src.stop(t + style.noise.dur + 0.1);

        // -------------------------------------------
        // å±‚çº§ B: ä½é¢‘å†²å‡» (Kick Layer) - ç‰©ç†æ‰“å‡»æ„Ÿ
        // -------------------------------------------
        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // æ­£å¼¦æ³¢æœ€é€‚åˆåšä½éŸ³
        
        // é¢‘ç‡ä¸‹æ½œ (Kickçš„æ ¸å¿ƒ)
        osc.frequency.setValueAtTime(style.kick.f, t);
        osc.frequency.exponentialRampToValueAtTime(1, t + style.kick.dur);
        
        const oscGain = this.ctx.createGain();
        oscGain.gain.setValueAtTime(0, t);
        oscGain.gain.linearRampToValueAtTime(style.kick.vol, t + 0.02);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + style.kick.dur);
        
        // è¿æ¥ B
        osc.connect(oscGain);
        oscGain.connect(this.nodes.fw); // ä¹Ÿè¦è¿åˆ° fw èŠ‚ç‚¹å—æ€»éŸ³é‡æ§åˆ¶
        
        osc.start(t);
        osc.stop(t + style.kick.dur + 0.1);
    }
}

const audio = new AudioEngine();

const CFG = {
    // ğŸš‚ ç‰©ç†
    maxSpeed: 0.10, accel: 0.005, decel: 0.003, wheelMult: 2.0, carriageGap: 0.009,
    
    // ğŸ¥ ç›¸æœº (å¤–ä¾§å‘å¿ƒè§†è§’)
    camHeight: 22,    // ç¨å¾®æŠ¬é«˜ï¼Œé˜²æ­¢ç«è½¦æŒ¡ä½å¤ªå¤šæ ‘çš„æ ¹éƒ¨
    camDist: 85,      // æ‹‰å¤§è·ç¦»ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨å¤–åœˆçœ‹ï¼Œéœ€è¦è§†é‡åŒ…ä½ä¸­å¤®
    camSmooth: 0.02,   // å¢å¤§é˜»å°¼ç³»æ•°ï¼Œè®©è·Ÿéšæ›´ç´§å‡‘ï¼Œå‡å°‘â€œæ‹–æ‹½æ„Ÿâ€å¸¦æ¥çš„æŠ–åŠ¨
    
    // ğŸ’¡ è§†è§‰ä¿®æ­£
    moonInt: 2.5, 
    fogDen: 0.0004, 
    bloomStr: 0.7,  
    bloomThr: 0.02, 
    lightPow: 100, bulbBri: 30,
    autoFw: true, fwRate: 4
};

const STATE = {
    started: false,
    viewMode: 'FOLLOW', // FOLLOW | FREE
    settings: false,
    interacting: false, // ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨
    running: true, // ç›®æ ‡çŠ¶æ€ï¼šæ˜¯å¦åº”è¯¥è·‘
    curSpeed: 0,   // å½“å‰å®é™…ç‰©ç†é€Ÿåº¦
    clickTime: 0,
    trainDir: Math.random() > 0.5 ? 1 : -1  // ğŸš‚ éšæœºæ–¹å‘ï¼š1=é¡ºæ—¶é’ˆï¼Œ-1=é€†æ—¶é’ˆ
};

// ğŸš æ— äººæœºæ¥åŠ›è·Ÿæ‹ç³»ç»Ÿé…ç½®
const DRONE = {
    count: 6,           // æ— äººæœºæ•°é‡ï¼ˆå‡åŒ€åˆ†å¸ƒåœ¨è½¨é“å‘¨å›´ï¼‰
    coverage: 0.18,     // æ¯ä¸ªæ— äººæœºè¦†ç›–çš„è½¨é“æ¯”ä¾‹
    switchDur: 1.0,     // åˆ‡æ¢è¿‡æ¸¡æ—¶é—´ï¼ˆç§’ï¼‰- ç¨å¿«ä¸€ç‚¹
    height: 40,         // é£è¡Œé«˜åº¦ - è°ƒé«˜çœ‹å…¨æ™¯
    distance: 100,      // è·Ÿæ‹è·ç¦» - è°ƒè¿œçœ‹æ›´å¤šåœºæ™¯
    smoothSpeed: 0.08,  // è·Ÿéšå¹³æ»‘åº¦ï¼ˆè¶Šå¤§è·Ÿå¾—è¶Šç´§ï¼‰
};

// æ— äººæœºçŠ¶æ€
const droneState = {
    current: 0,         // å½“å‰æ¿€æ´»çš„æ— äººæœºç´¢å¼•
    switching: false,   // æ˜¯å¦æ­£åœ¨åˆ‡æ¢ä¸­
    switchT: 0,         // åˆ‡æ¢è¿›åº¦ 0-1
    fromPos: new THREE.Vector3(),  // åˆ‡æ¢èµ·å§‹ä½ç½®
    toPos: new THREE.Vector3(),    // åˆ‡æ¢ç›®æ ‡ä½ç½®
    fromTarget: new THREE.Vector3(), // åˆ‡æ¢èµ·å§‹çœ‹å‘ç‚¹
    toTarget: new THREE.Vector3(),   // åˆ‡æ¢ç›®æ ‡çœ‹å‘ç‚¹
};

let scene, camera, renderer, composer, controls, gui;
let train, fwMgr, snowMgr, santaSleigh, trackCurve;
let lights={}, bloomPass;
let ground, trackPoints=[];
let autoTimer=null;
const clock = new THREE.Clock();
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const vec3 = new THREE.Vector3();
const emissives = [];

// ğŸ¨ å…¨å±€è£…é¥°ç‰©ç®¡ç†å™¨ - ä½¿ç”¨InstancedMeshä¼˜åŒ–æ€§èƒ½
const DecorManager = {
    // å…±äº«å‡ ä½•ä½“
    geos: {},
    // å…±äº«æè´¨
    mats: {},
    // InstancedMeshå®ä¾‹
    instances: {},
    // è®¡æ•°å™¨
    counts: {},
    // å¤ç”¨å¯¹è±¡ï¼ˆé¿å…æ¯æ¬¡è°ƒç”¨åˆ›å»ºæ–°å¯¹è±¡ï¼‰
    _dummy: null,
    _tempColor: null,
    // æœ€å¤§æ•°é‡é…ç½®ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
    maxCounts: {
        groundGift: 30,      // åœ°é¢ç¤¼ç›’
        snowman: 30,         // é›ªäºº
        lamp: 30,            // è·¯ç¯
    },

    init(sc) {
        this.scene = sc;
        // åˆå§‹åŒ–å¤ç”¨å¯¹è±¡
        this._dummy = new THREE.Object3D();
        this._tempColor = new THREE.Color();

        // åˆå§‹åŒ–å…±äº«å‡ ä½•ä½“ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
        this.geos.snowPatch = new THREE.SphereGeometry(0.5, 6, 4);  // è½¦å¢ç§¯é›ªä¹Ÿç”¨è¿™ä¸ª
        this.geos.giftBox = new THREE.BoxGeometry(1, 1, 1);
        this.geos.giftRibbon = new THREE.BoxGeometry(1.05, 0.15, 1.05);
        this.geos.lampPole = new THREE.CylinderGeometry(0.2, 0.2, 7, 8);
        this.geos.lampBulb = new THREE.SphereGeometry(0.5, 8, 8);

        // åˆå§‹åŒ–å…±äº«æè´¨ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
        this.mats.snow = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });   // é›ªäºº
        this.mats.white = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });  // ä¸å¸¦
        this.mats.black = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }); // ç¯æ†

        // åˆå§‹åŒ–InstancedMesh (åœ°é¢è£…é¥° - é™æ€)
        this.initGroundDecorations();
    },

    initGroundDecorations() {
        // åœ°é¢ç¤¼ç›’ - ä½¿ç”¨é¡¶ç‚¹é¢œè‰²æ”¯æŒ
        const giftMat = new THREE.MeshStandardMaterial({
            vertexColors: false,
            roughness: 0.3
        });
        this.instances.groundGiftBox = new THREE.InstancedMesh(
            this.geos.giftBox, giftMat, this.maxCounts.groundGift
        );
        this.instances.groundGiftBox.count = 0;
        this.instances.groundGiftBox.castShadow = true;
        this.scene.add(this.instances.groundGiftBox);

        this.instances.groundGiftRibbon = new THREE.InstancedMesh(
            this.geos.giftRibbon, this.mats.white, this.maxCounts.groundGift
        );
        this.instances.groundGiftRibbon.count = 0;
        this.scene.add(this.instances.groundGiftRibbon);

        // é›ªäººèº«ä½“
        this.instances.snowmanLower = new THREE.InstancedMesh(
            new THREE.SphereGeometry(1.2, 10, 10), this.mats.snow, this.maxCounts.snowman
        );
        this.instances.snowmanLower.count = 0;
        this.scene.add(this.instances.snowmanLower);

        this.instances.snowmanUpper = new THREE.InstancedMesh(
            new THREE.SphereGeometry(0.8, 10, 10), this.mats.snow, this.maxCounts.snowman
        );
        this.instances.snowmanUpper.count = 0;
        this.scene.add(this.instances.snowmanUpper);

        // è·¯ç¯æ†
        this.instances.lampPole = new THREE.InstancedMesh(
            this.geos.lampPole, this.mats.black, this.maxCounts.lamp
        );
        this.instances.lampPole.count = 0;
        this.scene.add(this.instances.lampPole);

        // åˆå§‹åŒ–è®¡æ•°
        this.counts.groundGift = 0;
        this.counts.snowman = 0;
        this.counts.lamp = 0;
    },

    // æ·»åŠ åœ°é¢ç¤¼ç›’
    addGroundGift(x, z) {
        if (this.counts.groundGift >= this.maxCounts.groundGift) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡
        const scale = 1.2 + Math.random() * 0.6;
        const rotY = Math.random() * Math.PI;

        // ç›’å­
        d.position.set(x, 0.75 * scale, z);
        d.scale.setScalar(scale);
        d.rotation.set(0, rotY, 0);
        d.updateMatrix();
        this.instances.groundGiftBox.setMatrixAt(this.counts.groundGift, d.matrix);

        // è®¾ç½®éšæœºé¢œè‰² - å¤ç”¨ tempColor
        this._tempColor.setHSL(Math.random(), 0.8, 0.5);
        this.instances.groundGiftBox.setColorAt(this.counts.groundGift, this._tempColor);

        // ä¸å¸¦
        d.updateMatrix();
        this.instances.groundGiftRibbon.setMatrixAt(this.counts.groundGift, d.matrix);

        this.counts.groundGift++;
        this.instances.groundGiftBox.count = this.counts.groundGift;
        this.instances.groundGiftRibbon.count = this.counts.groundGift;
        this.instances.groundGiftBox.instanceMatrix.needsUpdate = true;
        this.instances.groundGiftRibbon.instanceMatrix.needsUpdate = true;
        if (this.instances.groundGiftBox.instanceColor) {
            this.instances.groundGiftBox.instanceColor.needsUpdate = true;
        }
    },

    // æ·»åŠ é›ªäºº
    addSnowman(x, z) {
        if (this.counts.snowman >= this.maxCounts.snowman) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡

        // ä¸‹åŠèº«
        d.position.set(x, 1, z);
        d.scale.setScalar(1);
        d.rotation.set(0, 0, 0);
        d.updateMatrix();
        this.instances.snowmanLower.setMatrixAt(this.counts.snowman, d.matrix);

        // ä¸ŠåŠèº«
        d.position.set(x, 2.5, z);
        d.updateMatrix();
        this.instances.snowmanUpper.setMatrixAt(this.counts.snowman, d.matrix);

        this.counts.snowman++;
        this.instances.snowmanLower.count = this.counts.snowman;
        this.instances.snowmanUpper.count = this.counts.snowman;
        this.instances.snowmanLower.instanceMatrix.needsUpdate = true;
        this.instances.snowmanUpper.instanceMatrix.needsUpdate = true;
    },

    // æ·»åŠ è·¯ç¯
    addLamp(x, z) {
        if (this.counts.lamp >= this.maxCounts.lamp) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡
        d.position.set(x, 3.5, z);
        d.scale.setScalar(1);
        d.rotation.set(0, 0, 0);
        d.updateMatrix();
        this.instances.lampPole.setMatrixAt(this.counts.lamp, d.matrix);

        // ç¯æ³¡éœ€è¦å•ç‹¬å¤„ç†ï¼ˆå› ä¸ºéœ€è¦å‘å…‰æ•ˆæœï¼‰- ç¯æ³¡æè´¨å…±äº«
        if (!this._bulbMat) {
            this._bulbMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, fog: false });
            this._bulbBaseCol = new THREE.Color(0xffaa00);
        }
        const bulb = new THREE.Mesh(this.geos.lampBulb, this._bulbMat);
        bulb.position.set(x, 7, z);
        bulb.userData = { type: 'bulb', phase: Math.random() * Math.PI, baseCol: this._bulbBaseCol };
        emissives.push(bulb);
        this.scene.add(bulb);

        this.counts.lamp++;
        this.instances.lampPole.count = this.counts.lamp;
        this.instances.lampPole.instanceMatrix.needsUpdate = true;
    },

    // å®Œæˆåˆå§‹åŒ–åè°ƒç”¨
    finalize() {
        // æ›´æ–°æ‰€æœ‰å®ä¾‹çš„è¾¹ç•Œ
        Object.values(this.instances).forEach(inst => {
            if (inst.count > 0) {
                inst.computeBoundingSphere();
            }
        });
    }
};

// è½¦å¢ç§¯é›ªå…±äº«èµ„æºï¼ˆå¤ç”¨ DecorManager çš„å‡ ä½•ä½“å’Œæè´¨ï¼‰
const CarSnowResources = {
    get geo() { return DecorManager.geos.snowPatch; },
    get mat() { return DecorManager.mats.snow; }
};

// ğŸ„ è‹±é›„æ ‘å…±äº«èµ„æº - ä¼˜åŒ–å†…å­˜ä½¿ç”¨
const HeroTreeResources = {
    // æè´¨ï¼ˆè·¨æ‰€æœ‰æ ‘å…±äº«ï¼‰
    mats: null,
    // å‡ ä½•ä½“ï¼ˆè·¨æ‰€æœ‰æ ‘å…±äº«ï¼‰
    geos: null,

    init() {
        // å…±äº«æè´¨
        this.mats = {
            trunk: new THREE.MeshStandardMaterial({ color: 0x4a2e16, roughness: 1.0 }),
            foliage: new THREE.MeshStandardMaterial({ color: 0x0f5515, roughness: 0.8, flatShading: true }),
            red: new THREE.MeshStandardMaterial({ color: 0xe60000, roughness: 0.3 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 }),
            white: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }),
        };

        // å…±äº«å‡ ä½•ä½“
        this.geos = {
            // æ ‘å¹²
            trunk: new THREE.CylinderGeometry(3, 5, 15, 8),
            // è£…é¥°çƒ
            ball: new THREE.SphereGeometry(0.8, 12, 12),
            // æ‹æ–ç³–éƒ¨ä»¶
            caneStick: new THREE.CylinderGeometry(0.12, 0.12, 1.2, 8),
            caneHook: new THREE.TorusGeometry(0.35, 0.12, 8, 16, Math.PI),
            caneStripe: new THREE.TorusGeometry(0.13, 0.02, 4, 8),
            // ç¤¼ç›’éƒ¨ä»¶
            giftBox: new THREE.BoxGeometry(1.0, 1.0, 1.0),
            giftRibbon1: new THREE.BoxGeometry(1.05, 1.0, 0.25),
            giftRibbon2: new THREE.BoxGeometry(0.25, 1.0, 1.05),
            bowLoop: new THREE.TorusGeometry(0.2, 0.08, 6, 12),
            bowKnot: new THREE.BoxGeometry(0.15, 0.15, 0.15),
            // LEDç¯ç 
            bulb: new THREE.SphereGeometry(0.45, 8, 8),
        };
    }
};

// ğŸ å…±äº«ç¤¼ç›’å·¥å‚ - æ¶ˆé™¤ Train å’Œ SantaSleigh çš„é‡å¤ä»£ç 
const GiftFactory = {
    // å…±äº«æè´¨ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
    _mats: null,

    getMats() {
        if (!this._mats) {
            this._mats = {
                red: new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 }),
                gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.5 }),
                white: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
            };
        }
        return this._mats;
    },

    /**
     * åˆ›å»ºç¤¼ç›’æ¨¡æ¿
     * @param {Object} options - é…ç½®é€‰é¡¹
     * @param {number} options.size - ç›’å­å°ºå¯¸ (é»˜è®¤ 2)
     * @param {boolean} options.hasKnot - æ˜¯å¦æœ‰è´è¶ç»“ä¸­å¿ƒç»“ (é»˜è®¤ false)
     * @param {string} options.bowMat - è´è¶ç»“æè´¨ 'gold' | 'white' (é»˜è®¤ 'gold')
     */
    createTemplate(options = {}) {
        const { size = 2, hasKnot = false, bowMat = 'gold' } = options;
        const mats = this.getMats();
        const group = new THREE.Group();

        // ç›’å­ä¸»ä½“
        const box = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), mats.red);
        group.add(box);

        // åå­—ä¸å¸¦
        const ribbonThick = size * 0.15;
        const ribbonSize = size * 1.05;
        const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(ribbonSize, ribbonThick, ribbonSize), mats.gold);
        const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(ribbonThick, ribbonSize, ribbonSize), mats.gold);
        group.add(ribbon1, ribbon2);

        // è´è¶ç»“
        const bowRadius = size * 0.2;
        const bowTube = size * 0.06;
        const bowGeo = new THREE.TorusGeometry(bowRadius, bowTube, 6, 12);
        const bowMaterial = bowMat === 'white' ? mats.white : mats.gold;

        const bow1 = new THREE.Mesh(bowGeo, bowMaterial);
        bow1.position.set(size * 0.15, size * 0.55, 0);
        bow1.rotation.z = -Math.PI / 4;

        const bow2 = new THREE.Mesh(bowGeo, bowMaterial);
        bow2.position.set(-size * 0.15, size * 0.55, 0);
        bow2.rotation.z = Math.PI / 4;

        group.add(bow1, bow2);

        // å¯é€‰ï¼šè´è¶ç»“ä¸­å¿ƒç»“
        if (hasKnot) {
            const knot = new THREE.Mesh(new THREE.SphereGeometry(size * 0.1, 8, 8), mats.white);
            knot.position.y = size * 0.5;
            group.add(knot);
        }

        return group;
    },

    /**
     * å…‹éš†ç¤¼ç›’å¹¶ç‹¬ç«‹åŒ–æè´¨ï¼ˆç”¨äºè®¾ç½®ä¸åŒé¢œè‰²ï¼‰
     */
    cloneWithUniqueMaterials(template) {
        const gift = template.clone();
        gift.traverse(child => {
            if (child.isMesh) {
                child.material = child.material.clone();
            }
        });
        return gift;
    },

    // å¤ç”¨å‘é‡ï¼ˆé¿å…æ¯å¸§åˆ›å»ºï¼‰
    _physicsVel: new THREE.Vector3(),

    /**
     * ç»Ÿä¸€çš„ç¤¼ç‰©ç‰©ç†æ›´æ–°
     * @param {Object} giftData - ç¤¼ç‰©æ•°æ® { mesh, vel, rotVel, landed, targetY? }
     * @param {number} dt - æ—¶é—´å¢é‡
     * @param {Object} options - é…ç½®é€‰é¡¹
     * @param {number} options.gravity - é‡åŠ›åŠ é€Ÿåº¦ (é»˜è®¤ 25)
     * @param {number} options.groundY - è½åœ°é«˜åº¦ (é»˜è®¤ 1)
     * @returns {boolean} æ˜¯å¦åˆšåˆšè½åœ°
     */
    updateGiftPhysics(giftData, dt, options = {}) {
        if (giftData.landed) return false;

        const { gravity = 25, groundY = 1 } = options;
        const targetY = giftData.targetY ?? groundY;

        // é‡åŠ›
        giftData.vel.y -= gravity * dt;

        // ä½ç½®æ›´æ–°
        this._physicsVel.copy(giftData.vel).multiplyScalar(dt);
        giftData.mesh.position.add(this._physicsVel);

        // æ—‹è½¬
        giftData.mesh.rotation.x += giftData.rotVel.x;
        giftData.mesh.rotation.y += giftData.rotVel.y;
        giftData.mesh.rotation.z += giftData.rotVel.z;

        // è½åœ°æ£€æŸ¥
        if (giftData.mesh.position.y <= targetY) {
            giftData.mesh.position.y = targetY;
            giftData.landed = true;
            giftData.rotVel.set(0, 0, 0);
            giftData.mesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
            return true; // åˆšåˆšè½åœ°
        }

        return false;
    }
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
    scene.fog = new THREE.FogExp2(0x000000, CFG.fogDen);

    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 4000);
    camera.position.set(0, 150, 150);

    renderer = new THREE.WebGLRenderer({
        antialias: false, powerPreference: "high-performance", depth: true, stencil: false
    });
    renderer.setSize(innerWidth, innerHeight);

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // åˆå§‹åŒ–è£…é¥°ç‰©ç®¡ç†å™¨
    DecorManager.init(scene);
    HeroTreeResources.init();

    buildLights();
    buildTrack();
    buildEnv();

    // å®Œæˆè£…é¥°ç‰©åˆå§‹åŒ–
    DecorManager.finalize();

    const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight, { type: THREE.HalfFloatType, stencilBuffer: false });

    const rp = new RenderPass(scene, camera);
    bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = CFG.bloomThr; 
    bloomPass.strength = CFG.bloomStr; 
    bloomPass.radius = 0.5;

    composer = new EffectComposer(renderer, rt);
    composer.addPass(rp);
    composer.addPass(bloomPass);

    train = new Train(scene, trackCurve);
    fwMgr = new Fireworks(scene);
    snowMgr = new Snow(scene);
    santaSleigh = new SantaSleigh(scene);

    setupControls();
    setupUI();
    
    document.getElementById('loading').style.display='none';
    animate();
}

// åœ¨ animate å‡½æ•°å¤–ï¼Œç¡®ä¿å®šä¹‰äº†è¿™äº›è¾…åŠ©å˜é‡ï¼Œç”¨äºå¤ç”¨
const _v2 = new THREE.Vector3();
const _target = new THREE.Vector3();
const _up = new THREE.Vector3(0, 1, 0);
const _tempCol = new THREE.Color();
const _dronePos = new THREE.Vector3();
const _droneTarget = new THREE.Vector3();

// ğŸš è®¡ç®—æŒ‡å®šæ— äººæœºçš„ç†æƒ³ä½ç½®ï¼ˆä¿®æ­£ç‰ˆï¼šä½¿ç”¨å¾„å‘å‘é‡ç¡®ä¿åœ¨è½¨é“å¤–ä¾§ï¼‰
function getDronePosition(droneIndex, trainProg, outPos, outTarget) {
    // è·å–ç«è½¦å½“å‰ä½ç½®
    const trainPos = trackCurve.getPointAt(trainProg);

    // ğŸ”‘ æ ¸å¿ƒä¿®æ­£ï¼šä½¿ç”¨å¾„å‘å‘é‡ï¼ˆä»ä¸­å¿ƒæŒ‡å‘ç«è½¦ï¼‰ï¼Œè¿™ä¸ªæ–¹å‘æ°¸è¿œæŒ‡å‘å¤–ä¾§
    _v2.set(trainPos.x, 0, trainPos.z).normalize();

    // æ— äººæœºä½ç½® = ç«è½¦ä½ç½® + å¾„å‘å¤–åç§» + é«˜åº¦
    outPos.copy(trainPos);
    outPos.addScaledVector(_v2, DRONE.distance); // å‘å¤–åç§»
    outPos.y = DRONE.height;

    // çœ‹å‘ç‚¹ï¼šåœ°å›¾ä¸­å¿ƒï¼ˆç¨å¾®æŠ¬é«˜ï¼Œèƒ½çœ‹åˆ°åœ£è¯æ ‘ï¼‰
    outTarget.set(0, 15, 0);
}

// ğŸš æ£€æµ‹æ˜¯å¦éœ€è¦åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ— äººæœºï¼ˆæ”¯æŒåŒå‘è¡Œé©¶ï¼‰
function checkDroneSwitch(trainProg) {
    const droneStart = droneState.current / DRONE.count;

    // è®¡ç®—ç«è½¦ç›¸å¯¹äºå½“å‰æ— äººæœºèµ·ç‚¹çš„ä½ç½®
    let relProg = trainProg - droneStart;
    if (relProg < -0.5) relProg += 1;
    if (relProg > 0.5) relProg -= 1;

    // æ ¹æ®ç«è½¦æ–¹å‘åˆ¤æ–­æ˜¯å¦è¶…å‡ºè¦†ç›–èŒƒå›´
    const needSwitch = STATE.trainDir > 0
        ? relProg > DRONE.coverage   // é¡ºæ—¶é’ˆï¼šè¶…å‡ºæ­£å‘èŒƒå›´
        : relProg < 0;                // é€†æ—¶é’ˆï¼šè¶…å‡ºè´Ÿå‘èŒƒå›´

    if (needSwitch && !droneState.switching) {
        // è®°å½•å½“å‰ä½ç½®ä½œä¸ºèµ·ç‚¹
        droneState.fromPos.copy(camera.position);
        droneState.fromTarget.copy(controls.target);

        // æ ¹æ®æ–¹å‘åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæˆ–ä¸Šä¸€ä¸ªæ— äººæœº
        droneState.current = (droneState.current + STATE.trainDir + DRONE.count) % DRONE.count;

        // è®¡ç®—æ–°æ— äººæœºçš„ä½ç½®
        getDronePosition(droneState.current, trainProg, droneState.toPos, droneState.toTarget);

        // å¼€å§‹åˆ‡æ¢åŠ¨ç”»
        droneState.switching = true;
        droneState.switchT = 0;
    }
}

// ğŸš å¹³æ»‘æ’å€¼å‡½æ•° (ease-in-out)
function smoothStep(t) {
    return t * t * (3 - 2 * t);
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // å¦‚æœä¸¤å¸§é—´éš”è¶…è¿‡ 0.1ç§’ï¼ˆæ¯”å¦‚åˆ‡åå°äº†ï¼‰ï¼Œå°±å¼ºåˆ¶æŒ‰ 0.1ç§’è®¡ç®—
    // è¿™æ ·é›ªèŠ±å°±ä¸ä¼šç¬é—´æ‰åˆ°åº•ï¼Œç«è½¦ä¹Ÿä¸ä¼šç¬ç§»
    const deltaTime = dt > 0.1 ? 0.1 : dt; 

    // 1. ç‰©ç†æƒ¯æ€§
    if(STATE.running) {
        // åŠ é€Ÿé€»è¾‘
        if(STATE.curSpeed < CFG.maxSpeed) {
            STATE.curSpeed += CFG.accel;
            if(STATE.curSpeed > CFG.maxSpeed) STATE.curSpeed = CFG.maxSpeed;
        }
        // å‡é€Ÿé€»è¾‘ (å½“ä½ åœ¨è®¾ç½®é‡ŒæŠŠæé€Ÿè°ƒä½æ—¶ï¼Œç«è½¦ä¼šæ…¢æ…¢å‡é€Ÿé€‚åº”æ–°è®¾ç½®)
        else if(STATE.curSpeed > CFG.maxSpeed) {
            STATE.curSpeed *= 0.98; // æ‘©æ“¦åŠ›å‡é€Ÿ
        }
    } else {
        // åœè½¦é€»è¾‘ï¼šæ‘©æ“¦åŠ›æ¨¡å‹ï¼ˆå¼€å§‹å¿«ï¼Œç»“æŸæ…¢ï¼Œæ›´è‡ªç„¶ï¼‰
        if(STATE.curSpeed > 0.001) {
            STATE.curSpeed *= 0.985; // æ¯å¸§è¡°å‡1.5%
        } else {
            STATE.curSpeed = 0;
        }
    }

    if(train) train.update(deltaTime, STATE.curSpeed);
    if(fwMgr) fwMgr.update();
    if(snowMgr) snowMgr.update(deltaTime);
    if(santaSleigh) santaSleigh.update(deltaTime);

    // ç¯å…‰åŠ¨ç”»
    emissives.forEach(obj => {
        if(obj.userData.type === 'led_instanced') {
            const data = obj.userData.data;
            for(let i=0; i<obj.count; i++) {
                const item = data[i];
                const val = Math.sin(time * item.speed + item.offset);
                const intensity = 0.5 + 1.25 * (val + 1); 
                _tempCol.copy(item.baseCol).multiplyScalar(intensity);
                obj.setColorAt(i, _tempCol);
            }
            if(obj.instanceColor) obj.instanceColor.needsUpdate = true;
        }
        if(obj.userData.type === 'bulb' && obj.userData.baseCol) {
            const blink = 0.6 + 0.4 * Math.sin(time * 3.0 + obj.userData.phase);
            const intensity = 1.0 + blink * (CFG.bulbBri / 8); 
            obj.material.color.copy(obj.userData.baseCol).multiplyScalar(intensity);
        }
        if(obj.userData.type === 'star') obj.material.color.setHSL(0.14, 1.0, 0.6 + 0.3 * Math.sin(time));
        if(obj.userData.type === 'headlight_spot') obj.intensity = CFG.lightPow;
    });

    // ğŸš æ— äººæœºæ¥åŠ›è·Ÿæ‹ç³»ç»Ÿ
    if(STATE.started && train && train.loco) {
        const trainProg = train.prog;

        if (STATE.viewMode === 'FOLLOW' && !STATE.interacting) {
            // æ£€æµ‹æ˜¯å¦éœ€è¦åˆ‡æ¢æ— äººæœº
            checkDroneSwitch(trainProg);

            if (droneState.switching) {
                // æ­£åœ¨åˆ‡æ¢ä¸­ï¼šæ‰§è¡Œå¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
                droneState.switchT += deltaTime / DRONE.switchDur;

                if (droneState.switchT >= 1) {
                    // åˆ‡æ¢å®Œæˆ
                    droneState.switchT = 1;
                    droneState.switching = false;
                }

                // ä½¿ç”¨å¹³æ»‘æ’å€¼
                const k = smoothStep(droneState.switchT);

                // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆå› ä¸ºç«è½¦è¿˜åœ¨ç§»åŠ¨ï¼‰
                getDronePosition(droneState.current, trainProg, droneState.toPos, droneState.toTarget);

                // æ’å€¼ç›¸æœºä½ç½®å’Œçœ‹å‘ç‚¹
                camera.position.lerpVectors(droneState.fromPos, droneState.toPos, k);
                _target.lerpVectors(droneState.fromTarget, droneState.toTarget, k);
                controls.target.copy(_target);
            } else {
                // æ­£å¸¸è·Ÿæ‹ï¼šæ— äººæœºå¹³æ»‘è·Ÿéšç«è½¦
                getDronePosition(droneState.current, trainProg, _dronePos, _droneTarget);

                // é€Ÿåº¦è‡ªé€‚åº”è·Ÿéšï¼šé«˜é€Ÿæ—¶è·Ÿå¾—æ›´ç´§
                const speedFactor = 1 + STATE.curSpeed * 3;  // é€Ÿåº¦è¶Šå¿«ï¼Œè·Ÿéšè¶Šç´§
                const posSmooth = Math.min(DRONE.smoothSpeed * speedFactor, 0.25);
                const targetSmooth = Math.min(DRONE.smoothSpeed * speedFactor * 1.5, 0.35);

                camera.position.lerp(_dronePos, posSmooth);
                controls.target.lerp(_droneTarget, targetSmooth);
            }
        } else if (STATE.viewMode === 'FOLLOW') {
            // ç”¨æˆ·æ­£åœ¨äº¤äº’ï¼Œåªæ›´æ–°ç›®æ ‡ç‚¹
            getDronePosition(droneState.current, trainProg, _dronePos, _droneTarget);
            controls.target.lerp(_droneTarget, DRONE.smoothSpeed * 1.2);
        }
    }

    controls.update();
    composer.render();
}

function buildLights() {
    const moon = new THREE.DirectionalLight(0xaaccff, CFG.moonInt);
    moon.position.set(-80, 150, -80);
    moon.castShadow=true; 
    moon.shadow.mapSize.set(1024,1024);
    moon.shadow.camera.left=-400; moon.shadow.camera.right=400;
    moon.shadow.camera.top=400; moon.shadow.camera.bottom=-400;
    scene.add(moon); lights.moon = moon;

    // æœˆäº®å®ä½“
    const mMesh = new THREE.Mesh(new THREE.SphereGeometry(15,32,32), new THREE.MeshBasicMaterial({color:0xffffee, fog:false}));
    mMesh.position.copy(moon.position).normalize().multiplyScalar(900);
    scene.add(mMesh);

    // æ˜Ÿç©º
    const sg = new THREE.BufferGeometry();
    const sp = [];
    for(let i=0;i<3000;i++) {
        const r=800+Math.random()*200;
        const th=Math.random()*Math.PI*2;
        const ph=Math.acos(2*Math.random()-1);
        if(Math.cos(ph)<0) continue; // åªåœ¨å¤©ä¸Š
        sp.push(r*Math.sin(ph)*Math.cos(th), Math.abs(r*Math.cos(ph)), r*Math.sin(ph)*Math.sin(th));
    }
    sg.setAttribute('position', new THREE.Float32BufferAttribute(sp,3));
    scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff, size:1.5, transparent:true, opacity:0.8, fog:false})));

    scene.add(new THREE.AmbientLight(0x303050, 0.4));
    
    // åœ°é¢
    ground = new THREE.Mesh(new THREE.CircleGeometry(1000,64), new THREE.MeshStandardMaterial({color:0x8899aa, roughness:1, metalness:0.1}));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow=true;
    scene.add(ground);
}

function buildTrack() {
    const points = [];
    const segments = 12; 
    
    const BaseR = 120; 
    const Amp = 50; 

    // å…³é”®ä¿®æ”¹ï¼šç”Ÿæˆéšæœºç§å­ï¼Œè®©ä¸‰ä¸ªå¶ç‰‡çš„å¤§å°æ¯æ¬¡éƒ½ä¸å¤ªä¸€æ ·
    // r1, r2, r3 åˆ†åˆ«å½±å“ä¸‰ä¸ªå¶ç‰‡çš„ "çªå‡ºç¨‹åº¦"
    const r1 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r2 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r3 = 1.0 + (Math.random() - 0.5) * 0.4;

    for (let i = 0; i < segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        
        // å…³é”®ä¿®æ”¹ï¼šæ ¹æ®è§’åº¦é€‰æ‹©ä¸åŒçš„éšæœºç³»æ•°
        let randomScale = 1.0;
        // ç®€å•åˆ¤æ–­è§’åº¦è½åœ¨å“ªä¸ªå¶ç‰‡åŒºé—´ (0~2PI åˆ†ä¸‰æ®µ)
        if (theta < 2) randomScale = r1;
        else if (theta < 4) randomScale = r2;
        else randomScale = r3;

        // å…¬å¼ï¼šåŸºç¡€åŠå¾„ + (æŒ¯å¹… * éšæœºç³»æ•° * ä¸‰å¶è‰å½¢çŠ¶) + å¾®å°æŠ–åŠ¨
        const r = BaseR + (Amp * randomScale * Math.sin(3 * theta));
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        points.push(new THREE.Vector3(x, 0, z));
    }

    trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.4); 
    trackPoints = trackCurve.getPoints(1000);

    const divs = 600;
    const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 4.2, 8, true), new THREE.MeshStandardMaterial({color:0x080808, roughness:1}));
    bed.position.y = 0.1; bed.scale.y = 0.1; scene.add(bed);
    
    const pg = new THREE.BoxGeometry(6, 0.4, 1.2); 
    const pm = new THREE.MeshStandardMaterial({color:0x3e2723});
    const pi = new THREE.InstancedMesh(pg, pm, divs);
    const dum = new THREE.Object3D();
    for(let i=0; i<divs; i++){
        const t = i/divs; const p = trackCurve.getPointAt(t); const tan = trackCurve.getTangentAt(t);
        dum.position.set(p.x, 0.3, p.z); dum.lookAt(p.x + tan.x, 0.3, p.z + tan.z); dum.updateMatrix();
        pi.setMatrixAt(i, dum.matrix);
    }
    pi.receiveShadow = true; scene.add(pi);

    // --- ä¿®å¤ï¼šåŒè½¨ç”Ÿæˆé€»è¾‘ ---
    // é—®é¢˜æ ¹æºï¼šExtrudeGeometry ä¼šè‡ªåŠ¨æ—‹è½¬åæ ‡ç³»ï¼Œå¯¼è‡´é“è½¨å˜æˆäº†ä¸Šä¸‹æ’åˆ—è€Œä¸æ˜¯å·¦å³æ’åˆ—
    // è§£å†³æ–¹æ¡ˆï¼šæ‰‹åŠ¨è®¡ç®—ä¸¤æ¡å¹³è¡Œäºåœ°é¢çš„è·¯å¾„
    
    const railPointsL = [];
    const railPointsR = [];
    const railSamp = 400;
    const dist = 2.2; // è½¨è·

    // é¢„åˆ†é…å¤ç”¨å¯¹è±¡ï¼Œå‡å°‘ GC å‹åŠ›
    const upVec = new THREE.Vector3(0, 1, 0);
    const rightVec = new THREE.Vector3();
    const tempL = new THREE.Vector3();
    const tempR = new THREE.Vector3();

    for(let i=0; i<=railSamp; i++) {
        const t = i / railSamp;
        const pt = trackCurve.getPointAt(t);
        const tan = trackCurve.getTangentAt(t);

        // å¤ç”¨ rightVec è®¡ç®—å³ä¾§å‘é‡
        rightVec.crossVectors(tan, upVec).normalize();

        // ç”Ÿæˆå·¦å³åæ ‡ç‚¹
        tempL.copy(pt).addScaledVector(rightVec, -dist);
        tempR.copy(pt).addScaledVector(rightVec, dist);
        railPointsL.push(tempL.clone());
        railPointsR.push(tempR.clone());
    }

    // 4. åˆ›å»ºä¸¤æ¡å¹³è¡Œçš„æ›²çº¿å¯¹è±¡
    const curveL = new THREE.CatmullRomCurve3(railPointsL, true, 'catmullrom', 0.4);
    const curveR = new THREE.CatmullRomCurve3(railPointsR, true, 'catmullrom', 0.4);
    
    const railMat = new THREE.MeshStandardMaterial({
        color: 0x555555, 
        metalness: 0.8, 
        roughness: 0.4
    });

    // 5. ä½¿ç”¨æœ€ç¨³å¦¥çš„ TubeGeometry ç”Ÿæˆå®ä½“
    // 0.12 æ˜¯é“è½¨ç²—ç»†ï¼Œ8 æ˜¯æˆªé¢åœ†æ»‘åº¦
    const railMeshL = new THREE.Mesh(new THREE.TubeGeometry(curveL, railSamp, 0.12, 8, true), railMat);
    const railMeshR = new THREE.Mesh(new THREE.TubeGeometry(curveR, railSamp, 0.12, 8, true), railMat);
    
    // 6. è°ƒæ•´é«˜åº¦
    // æ•æœ¨é¡¶é¢çº¦ 0.5ï¼Œé“è½¨è®¾ä¸º 0.56ï¼Œåˆšå¥½å‹åœ¨æ•æœ¨ä¸Š
    railMeshL.position.y = 0.56;
    railMeshR.position.y = 0.56;

    scene.add(railMeshL);
    scene.add(railMeshR);
}

function buildEnv() {
    // 1. ä¸‹æ–¹æ”¾ç½®å¤§å·è‹±é›„æ ‘ (é…åˆå¤§åœ†å¼§)
    createHeroTree(0, -90, 2.8); 
    
    // 2. å·¦ä¸Šå’Œå³ä¸Šæ”¾ç½®å°å·è‹±é›„æ ‘
    createHeroTree(85, 55, 1.4); 
    createHeroTree(-85, 55, 1.4);

    // ğŸŒ² å‡çº§ç‰ˆæ£®æ—
    const matTree = new THREE.MeshStandardMaterial({color:0x0f3315, roughness:0.9});
    const matSnow = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.6}); 
    
    const count = 700; 
    
    const meshBot = new THREE.InstancedMesh(new THREE.ConeGeometry(3.5, 5, 7), matTree, count);
    const meshMid = new THREE.InstancedMesh(new THREE.ConeGeometry(2.5, 4, 7), matTree, count);
    const meshTop = new THREE.InstancedMesh(new THREE.ConeGeometry(1.5, 3, 7), matSnow, count); 
    
    meshBot.castShadow=true; meshBot.receiveShadow=true;
    meshMid.castShadow=true; meshMid.receiveShadow=true;
    
    const dummy = new THREE.Object3D();
    let idx = 0;
    
    for(let i=0; i<3000; i++) {
        if(idx >= count) break;
        const r = 60 + Math.random()*380;
        const a = Math.random()*6.28;
        const x = Math.cos(a)*r, z = Math.sin(a)*r;
        let safe=true;
        const distSq = 25*25; 
        for(let k=0; k<trackPoints.length; k+=10) { 
            const dx = trackPoints[k].x - x, dz = trackPoints[k].z - z;
            if((dx*dx + dz*dz) < distSq) { safe=false; break; }
        }

        if(safe) {
            const s = 0.6 + Math.random() * 1.6; 
            const rotY = Math.random() * Math.PI;
            dummy.position.set(x, 2.5*s, z); dummy.scale.set(s,s,s); dummy.rotation.y = rotY; dummy.updateMatrix();
            meshBot.setMatrixAt(idx, dummy.matrix);
            dummy.position.set(x, 5.5*s, z); dummy.scale.set(s,s,s); dummy.updateMatrix();
            meshMid.setMatrixAt(idx, dummy.matrix);
            dummy.position.set(x, 8.0*s, z); dummy.scale.set(s,s,s); dummy.updateMatrix();
            meshTop.setMatrixAt(idx, dummy.matrix);
            idx++;
        }
    }
    
    scene.add(meshBot); scene.add(meshMid); scene.add(meshTop);

    // ğŸ¨ è£…é¥°å“ - ä½¿ç”¨DecorManagerä¼˜åŒ–
    for(let i=0; i<30; i++){
        const x=(Math.random()-0.5)*350, z=(Math.random()-0.5)*350;
        let safe=true;
        for(let k=0;k<trackPoints.length;k+=10) {
            const dx=trackPoints[k].x-x, dz=trackPoints[k].z-z;
            if((dx*dx+dz*dz)<400) { safe=false; break; }
        }
        if(safe) {
            const r=Math.random();
            if(r<0.3) DecorManager.addGroundGift(x,z);
            else if(r<0.6) DecorManager.addSnowman(x,z);
            else DecorManager.addLamp(x,z);
        }
    }
}

function createHeroTree(x, z, scale) {
    const g = new THREE.Group();
    g.position.set(x, 0, z);
    g.scale.set(scale, scale, scale);

    // ä½¿ç”¨å…±äº«èµ„æºå¼•ç”¨ï¼ˆç®€åŒ–ä»£ç ï¼‰
    const { mats, geos } = HeroTreeResources;

    // 1. æ ‘å¹² - ä½¿ç”¨å…±äº«å‡ ä½•ä½“å’Œæè´¨
    const trunk = new THREE.Mesh(geos.trunk, mats.trunk);
    trunk.position.y = 6;
    g.add(trunk);

    const bulbCols = [0xff0000, 0x00ff00, 0x0088ff, 0xffd700, 0xff00ff];

    // ğŸ¬ æ‹æ–ç³– - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    const createCandyCane = () => {
        const cane = new THREE.Group();

        // æ£èº« - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const stick = new THREE.Mesh(geos.caneStick, mats.white);
        stick.position.y = 0.6; // stickH / 2 = 1.2 / 2

        // å¼¯é’© - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const hook = new THREE.Mesh(geos.caneHook, mats.white);
        hook.position.set(0.35, 1.2, 0); // hookRadius, stickH

        // æ£èº«ä¸Šçš„æ¡çº¹ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        for(let i=0; i<5; i++) {
            const stripe = new THREE.Mesh(geos.caneStripe, mats.red);
            stripe.position.y = 0.2 + i * 0.22;
            stripe.rotation.x = Math.PI / 2;
            stripe.rotation.y = 0.3;
            cane.add(stripe);
        }

        // å¼¯é’©ä¸Šçš„æ¡çº¹
        const hookStripes = new THREE.Group();
        hookStripes.position.copy(hook.position);

        for(let i=1; i<4; i++) {
            const angle = (i / 4) * Math.PI;
            const stripe = new THREE.Mesh(geos.caneStripe, mats.red);
            stripe.position.set(Math.cos(angle) * 0.35, Math.sin(angle) * 0.35, 0);
            stripe.rotation.z = angle + Math.PI/2;
            hookStripes.add(stripe);
        }

        cane.add(stick, hook, hookStripes);
        cane.scale.set(1.2, 1.2, 1.2);
        cane.rotation.z = Math.PI / 6;

        return cane;
    };

    // ğŸ å°ç¤¼ç‰© - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    const createMiniGift = () => {
        const boxG = new THREE.Group();
        const mainMat = Math.random() > 0.5 ? mats.red : mats.gold;

        // ç›’å­ä¸»ä½“ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const box = new THREE.Mesh(geos.giftBox, mainMat);

        // åå­—ä¸å¸¦ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const r1 = new THREE.Mesh(geos.giftRibbon1, mats.white);
        const r2 = new THREE.Mesh(geos.giftRibbon2, mats.white);

        // è´è¶ç»“
        const bowG = new THREE.Group();
        bowG.position.y = 0.5;

        const b1 = new THREE.Mesh(geos.bowLoop, mats.white);
        b1.position.set(0.15, 0.15, 0);
        b1.rotation.set(0, 0, -Math.PI / 4);

        const b2 = new THREE.Mesh(geos.bowLoop, mats.white);
        b2.position.set(-0.15, 0.15, 0);
        b2.rotation.set(0, 0, Math.PI / 4);

        const knot = new THREE.Mesh(geos.bowKnot, mats.white);

        bowG.add(b1, b2, knot);
        boxG.add(box, r1, r2, bowG);
        boxG.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);

        return boxG;
    };

    const tiers = [
        { r: 24, h: 16, y: 14 }, { r: 20, h: 15, y: 24 },
        { r: 16, h: 14, y: 34 }, { r: 11, h: 12, y: 43 },
        { r: 6,  h: 10, y: 51 }
    ];
    let treeTopY = 0;

    tiers.forEach((tier, index) => {
        const geo = new THREE.ConeGeometry(tier.r, tier.h, 8);
        const mesh = new THREE.Mesh(geo, mats.foliage);
        mesh.position.y = tier.y;
        mesh.rotation.y = (index % 2) * (Math.PI / 8);
        mesh.castShadow = true; mesh.receiveShadow = true;
        g.add(mesh);
        treeTopY = tier.y + tier.h / 2;

        // --- è£…é¥°å“ï¼šä½¿ç”¨å…±äº«å‡ ä½•ä½“ ---
        const decorCount = Math.floor(tier.r * 0.8) + 2;
        for (let k = 0; k < decorCount; k++) {
            const angle = Math.random() * Math.PI * 2;
            const v = 0.1 + Math.random() * 0.5;
            const surfR = tier.r * (1 - v);
            const embed = 0.85 + Math.random() * 0.15;

            const lx = Math.cos(angle) * surfR * embed;
            const lz = Math.sin(angle) * surfR * embed;
            const ly = -tier.h / 2 + v * tier.h;

            const type = Math.random();
            let decor;
            if (type < 0.4) {
                // è£…é¥°çƒ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
                decor = new THREE.Mesh(geos.ball, Math.random()>.5 ? mats.red : mats.gold);
                decor.position.set(lx, ly, lz);
            } else if (type < 0.7) {
                decor = createMiniGift();
                decor.position.set(lx, ly + 0.5, lz);
                decor.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
            } else {
                decor = createCandyCane();
                decor.position.set(lx, ly, lz);
                decor.lookAt(0, ly, 0);
                decor.rotateX(Math.PI/4);
            }
            mesh.add(decor);
        }
    });

    // --- ğŸŒŸ å®ä½“ç”µçº¿ (éšæœºå¸ƒçº¿é€»è¾‘) ---
    const wirePoints = [];
    wirePoints.push(new THREE.Vector3(0, 2, 2)); // èµ·ç‚¹
    let currentAngle = 0;

    tiers.forEach((tier) => {
        // ç›˜æ—‹ï¼š0.5 ~ 1.5 åœˆ
        const loops = 0.5 + Math.random() * 1.0; 
        const steps = 15; // ç»†åˆ†
        
        for(let s=0; s <= steps; s++) {
            const t = s / steps;
            
            // è§’åº¦æ¨è¿›
            const angleStep = (Math.PI * 2 * loops) / steps;
            currentAngle += angleStep;
            
            // é«˜åº¦ï¼šåœ¨å½“å‰å±‚çˆ¬å‡
            // åªçˆ¬åˆ° 70% é«˜åº¦ï¼Œç•™å‡ºé’»å›å»çš„ç©ºé—´
            const py = (tier.y - tier.h/2) + (tier.h * 0.7) * t;
            
            // åŠå¾„ï¼šä»è¡¨é¢ç¨å¾®æµ®èµ·
            const surfR = tier.r * (1 - t * 0.7); // éšé«˜åº¦å˜ç»†
            const r = surfR * 1.05 + Math.random(); // éšæœºæ¾å¼›
            
            const px = Math.cos(currentAngle) * r;
            const pz = Math.sin(currentAngle) * r;
            wirePoints.push(new THREE.Vector3(px, py, pz));
        }

        // C. é’»å›ï¼šå›åˆ°æ ‘å¹²é™„è¿‘ï¼Œå‡†å¤‡å»ä¸‹ä¸€å±‚
        const endH = tier.y + tier.h/2 - 1;
        wirePoints.push(new THREE.Vector3(2 * Math.cos(currentAngle), endH, 2 * Math.sin(currentAngle)));
    });
    // ç»ˆç‚¹
    wirePoints.push(new THREE.Vector3(0, treeTopY, 0));

    const curve = new THREE.CatmullRomCurve3(wirePoints);
    const tubeGeo = new THREE.TubeGeometry(curve, 300, 0.08, 6, false);
    const wireMesh = new THREE.Mesh(tubeGeo, mats.black); // ä½¿ç”¨å…±äº«æè´¨
    g.add(wireMesh);

    // --- ğŸŒŸ LED ç¯ç  (ç¨€ç–åˆ†å¸ƒ + å±€éƒ¨ç‚¹å…‰æº) ---
    const totalLength = curve.getLength();
    const bulbCountRaw = Math.floor(totalLength * 1.8);

    // LEDæè´¨éœ€è¦ç‹¬ç«‹åˆ›å»ºï¼ˆMeshBasicMaterial ç”¨äºå‘å…‰æ•ˆæœï¼‰
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
    const ledMesh = new THREE.InstancedMesh(geos.bulb, bulbMat, bulbCountRaw); // ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    
    const dummy = new THREE.Object3D();
    const ledData = [];
    let realCount = 0;
    let clusterState = false; 
    let clusterCounter = 0;

    for(let i=0; i<bulbCountRaw; i++) {
        const t = i / bulbCountRaw;
        
        if (clusterCounter <= 0) {
            clusterState = !clusterState;
            clusterCounter = clusterState ? Math.floor(Math.random() * 5 + 4) : Math.floor(Math.random() * 12 + 8);
        }
        clusterCounter--;
        if (!clusterState) continue;

        const pos = curve.getPointAt(t);
        // éšæœºåç§»
        pos.x += (Math.random()-0.5)*0.3;
        pos.y += (Math.random()-0.5)*0.3;
        pos.z += (Math.random()-0.5)*0.3;

        dummy.position.copy(pos);
        dummy.scale.setScalar(1.0);
        dummy.updateMatrix();
        ledMesh.setMatrixAt(realCount, dummy.matrix);
        
        const colHex = bulbCols[Math.floor(Math.random() * bulbCols.length)];
        const color = new THREE.Color(colHex);
        ledMesh.setColorAt(realCount, color);
        
        ledData.push({ id: realCount, baseCol: color, speed: 0.5 + Math.random() * 3.0, offset: Math.random() * 100 });
        realCount++;
    }
    
    ledMesh.count = realCount;
    ledMesh.instanceColor.needsUpdate = true;
    ledMesh.userData = { type: 'led_instanced', data: ledData };
    emissives.push(ledMesh);
    g.add(ledMesh);

    if (scale > 2.0) {
        const innerLight = new THREE.PointLight(0xffaa33, 100, 50);
        innerLight.position.set(0, 15, 0);
        g.add(innerLight);
    }

    // --- ğŸŒŸ æ ‘é¡¶æ˜Ÿæ˜Ÿ (ä¿®å¤ç‰ˆï¼šæ— ç¼ºå£) ---
    const starShape = new THREE.Shape();
    const pts = 5;
    const outerR = 4.2; 
    const innerR = 2.0; 
    // ä»æ­£ä¸Šæ–¹å¼€å§‹ç”» (Angle = -PI/2)
    for (let i = 0; i < pts * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const a = (i / 10) * Math.PI * 2 - Math.PI/2;
        if(i===0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    starShape.closePath();

    // å‡å° bevel é˜²æ­¢è‡ªç›¸äº¤ç¼ºå£
    const starGeo = new THREE.ExtrudeGeometry(starShape, { 
        depth: 1.0, 
        bevelEnabled: true, 
        bevelThickness: 0.1, 
        bevelSize: 0.1, 
        bevelSegments: 1 
    });
    starGeo.center();
    
    const star = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffeb3b, fog: false }));
    star.position.set(0, treeTopY + 3.5, 0);
    star.userData = { type: 'star' }; 
    emissives.push(star); 
    g.add(star);
    
    scene.add(g);
}

class Train {
    constructor(sc, curve) {
        this.grp=new THREE.Group(); sc.add(this.grp);
        this.curve=curve; this.prog=0; this.wheels=[]; this.smokes=[];
        this.smokeMax = 50;
        this.smokeIdx = 0;
        this.smokeData = [];
        
        // ğŸ› ï¸ GC ä¼˜åŒ–ï¼šé¢„åˆ†é…å‡ ä½•ä½“å’Œæè´¨ (Flyweight Pattern)
        // é¿å…æ¯èŠ‚è½¦å¢éƒ½ new Geometryï¼Œå…±ç”¨ä¸€ä»½èµ„æº
        this.sharedResources = {
            bodyGeo: new THREE.BoxGeometry(3.4, 3.8, 7.8),
            goldBandGeo: new THREE.BoxGeometry(3.45, 0.2, 7.85),
            roofGeo: new THREE.CylinderGeometry(2.05, 2.05, 13, 13, 1, false, 0, Math.PI),
            winGeo: new THREE.PlaneGeometry(1.3, 1.6),
            borderGeo: new THREE.PlaneGeometry(1.4, 1.7),
            connectorGeo: new THREE.BoxGeometry(2.4, 2.8, 1.2),
            wheelGeo: new THREE.CylinderGeometry(0.65, 0.65, 0.4, 12).rotateZ(Math.PI / 2),
            winMat: new THREE.MeshBasicMaterial({ color: 0xffccaa, fog: false })
        };

        const sGeo = new THREE.IcosahedronGeometry(1, 0);
        const sMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd, transparent: true, opacity: 0.6, depthWrite: false, roughness: 1, flatShading: true
        });
        this.smokeMesh = new THREE.InstancedMesh(sGeo, sMat, this.smokeMax);
        this.smokeMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.smokeMesh.frustumCulled = false; // å…³é”®ä¿®å¤ï¼šé˜²æ­¢çƒŸé›¾è¢«é”™è¯¯å‰”é™¤
        this.grp.add(this.smokeMesh);

        // é¢„å…ˆåˆ›å»ºè¾…åŠ©å¯¹è±¡ï¼Œé¿å…åå¤åˆ›å»º
        this.dummy = new THREE.Object3D();
        this._trainDir = new THREE.Vector3(); // å¤ç”¨çš„æ–¹å‘å‘é‡
        this._tempVel = new THREE.Vector3();  // å¤ç”¨çš„é€Ÿåº¦å‘é‡ï¼ˆç”¨äºç‰©ç†æ›´æ–°ï¼‰ 

        for(let i=0; i<this.smokeMax; i++) {
            // åˆå§‹ç§»åˆ°æ— é™è¿œ
            this.dummy.position.set(0, -1000, 0); 
            this.dummy.updateMatrix();
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            this.smokeData.push({ active: false, life: 0, vel: new THREE.Vector3(), scale: 1 });
        }

        // Glare
        const cv=document.createElement('canvas'); cv.width=64;cv.height=64;
        const cx=cv.getContext('2d'); const gr=cx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#fff'); gr.addColorStop(1,'transparent'); cx.fillStyle=gr; cx.fillRect(0,0,64,64);
        this.glare=new THREE.CanvasTexture(cv);

        this.loco=this.mkLoco(); this.grp.add(this.loco);
        this.cars=[]; for(let i=1;i<=12;i++) { const c=this.mkCar(i); this.grp.add(c); this.cars.push(c); }
        this.gap();
    }
    gap() { this.cars.forEach((c,i)=>c.userData.off=(i+1)*(0.0075+CFG.carriageGap*0.2)); }
    
    mkLoco() {
        const g=new THREE.Group();
        const red=new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.3});
        const blk=new THREE.MeshStandardMaterial({color:0x111});
        const boil=new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,5,16), red); boil.rotation.x=Math.PI/2; boil.position.set(0,3.6,1);
        const cab=new THREE.Mesh(new THREE.BoxGeometry(3.8,5.2,3.2), red); cab.position.set(0,4.1,-2.5);
        this.chim=new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.6,2.5), blk); this.chim.position.set(0,4.8,2.5);
        const cow=new THREE.Mesh(new THREE.ConeGeometry(2,1.5,4), blk); cow.rotation.set(-Math.PI/2,Math.PI/4,0); cow.scale.set(1,0.5,1); cow.position.set(0,1,4.5);
        
        const aw=(z,r)=>{
            const w=new THREE.Mesh(new THREE.CylinderGeometry(r,r,0.5,16).rotateZ(Math.PI/2), blk);
            w.position.set(1.9,r,z); const w2=w.clone(); w2.position.set(-1.9,r,z);
            g.add(w,w2); this.wheels.push(w,w2);
        };
        aw(0,1.3); aw(2.2,1.3); aw(-1.5,1.3); aw(4.0,0.8);
        
        const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:this.glare, color:0xffdd88, blending:THREE.AdditiveBlending}));
        sp.position.set(0,5.2,4); sp.scale.set(10,10,1);
        const sl=new THREE.SpotLight(0xffccaa, CFG.lightPow, 150, 0.8, 0.5);
        sl.position.set(0,5.2,3.8); sl.target.position.set(0,-5,30); sl.castShadow=true;
        sl.userData={type:'headlight_spot'};
        emissives.push(sl); // åŠ å…¥ emissives ä»¥æ”¯æŒåŠ¨æ€äº®åº¦è°ƒèŠ‚
        g.add(boil,cab,this.chim,cow,sp,sl,sl.target);
        return g;
    }

    mkCar(i) {
        const g = new THREE.Group();
        const cols = [0x8b0000, 0x004d26, 0x003366, 0xb8860b];
        const col = cols[(i - 1) % 4];
        
        const matBody = new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.2 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });

        // 1. è½¦èº« (å…±äº« Geo)
        const body = new THREE.Mesh(this.sharedResources.bodyGeo, matBody);
        body.position.y = 3.3;
        
        // 2. é‡‘è‰²è£…é¥° (å…±äº« Geo)
        const goldBand = new THREE.Mesh(this.sharedResources.goldBandGeo, matGold);
        goldBand.position.y = 3.0; 
        g.add(goldBand);
        
        // 3. è½¦é¡¶ (å…±äº« Geo)
        const roof = new THREE.Mesh(
            this.sharedResources.roofGeo,
            new THREE.MeshStandardMaterial({color:0x222, roughness:0.9}) 
        );
        roof.rotation.set(0, Math.PI/2, Math.PI/2);
        roof.scale.set(1, 0.65, 1);
        roof.position.set(0, 5.1, 0);

        // 3.5 è½¦é¡¶ç§¯é›ª (ä¿æŒåŸæœ‰é€»è¾‘ï¼Œå› ç§¯é›ªå½¢çŠ¶éšæœºï¼Œéš¾ä»¥å®Œå…¨å…±äº«å®ä¾‹ï¼Œæš‚ä¸”ä¿ç•™)
        const snowGroup = new THREE.Group();
        const roofRadius = 2.05;
        const roofCenterY = 5.1;

        const getRoofY = (x) => {
            const safeX = Math.max(-roofRadius * 0.98, Math.min(roofRadius * 0.98, x));
            return roofCenterY + Math.sqrt(roofRadius * roofRadius - safeX * safeX);
        };
        const getSlope = (x) => {
            const safeX = Math.max(-roofRadius * 0.98, Math.min(roofRadius * 0.98, x));
            return Math.atan2(safeX, Math.sqrt(roofRadius * roofRadius - safeX * safeX));
        };

        // ä¸»è¦ç§¯é›ªå±‚
        for (let j = 0; j < 24; j++) {
            const snowPatch = new THREE.Mesh(CarSnowResources.geo, CarSnowResources.mat);
            
            const xRaw = (Math.random() + Math.random() - 1.0) * 1.6; 
            const zPos = (Math.random() - 0.5) * 11;
            const sizeFactor = 1.0 - Math.abs(xRaw)/2.5;
            
            snowPatch.scale.set(
                (0.5 + Math.random() * 0.3) * sizeFactor,
                0.06 + Math.random() * 0.04,
                (0.5 + Math.random() * 0.3) * sizeFactor
            );

            const roofY = getRoofY(xRaw);
            const slope = getSlope(xRaw);

            snowPatch.position.set(xRaw, roofY - 0.15, zPos);
            snowPatch.rotation.z = -slope;
            snowPatch.rotation.y = Math.random() * Math.PI * 2;
            
            snowGroup.add(snowPatch);
        }

        // è¾¹ç¼˜ç§¯é›ª
        for (let side = -1; side <= 1; side += 2) {
            for (let j = 0; j < 6; j++) {
                const edgeSnow = new THREE.Mesh(CarSnowResources.geo, CarSnowResources.mat);
                const xPos = side * (1.6 + Math.random() * 0.3);
                const zPos = -4.5 + j * 1.8 + Math.random() * 0.5;

                edgeSnow.scale.set(0.4, 0.08, 0.35);

                const roofY = getRoofY(xPos);
                const slope = getSlope(xPos);

                edgeSnow.position.set(xPos, roofY - 0.1, zPos);
                edgeSnow.rotation.z = -slope;
                snowGroup.add(edgeSnow);
            }
        }
        g.add(snowGroup);

        // 4. è½¦çª— (å…±äº« Geo)
        const windows = [];
        for (let side = -1; side <= 1; side += 2) {
            for (let k = 0; k < 3; k++) {
                const w = new THREE.Mesh(this.sharedResources.winGeo, this.sharedResources.winMat.clone()); 
                const border = new THREE.Mesh(this.sharedResources.borderGeo, matGold);

                w.position.set(1.76 * side, 3.8, -2.5 + k * 2.5);
                w.rotation.y = side * Math.PI / 2;
                w.userData.isWindow = true; 
                windows.push(w);

                border.position.copy(w.position);
                border.position.x -= 0.01 * side; 
                border.rotation.copy(w.rotation);

                g.add(border);
                g.add(w);
            }
        }
        g.userData.windows = windows; 

        // 5. è¿æ¥å¤„ & è½®å­ (å…±äº« Geo)
        const gw = new THREE.Mesh(this.sharedResources.connectorGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
        gw.position.set(0, 3, 4.2);

        const ab = z => {
            const gr = new THREE.Group(); gr.position.set(0, 0, z);
            const w = new THREE.Mesh(this.sharedResources.wheelGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
            w.position.set(1.6, 0.65, 0);
            const w2 = w.clone(); w2.position.set(-1.6, 0.65, 0);
            gr.add(w, w2); g.add(gr); this.wheels.push(w, w2);
        };
        ab(2.8); ab(-2.8);

        g.add(body, roof, gw);
        return g;
    }

    update(dt, speed) {
        audio.chug(speed);

        // ğŸš‚ æ”¯æŒåŒå‘è¡Œé©¶ï¼šSTATE.trainDir = 1(é¡ºæ—¶é’ˆ) æˆ– -1(é€†æ—¶é’ˆ)
        const dist = speed * dt * 0.2 * STATE.trainDir;
        this.prog = (this.prog + dist + 1) % 1; // +1 ç¡®ä¿ç»“æœä¸ºæ­£

        this.place(this.loco, this.prog);
        this.cars.forEach(c => {
            // è½¦å¢è·Ÿéšï¼šæ ¹æ®æ–¹å‘å†³å®šåç§»æ–¹å‘
            let t = this.prog - c.userData.off * STATE.trainDir;
            t = ((t % 1) + 1) % 1; // ç¡®ä¿ t åœ¨ [0, 1) èŒƒå›´å†…
            this.place(c, t);
        });

        // è½®å­æ—‹è½¬æ–¹å‘ä¹Ÿè¦éšç«è½¦æ–¹å‘
        this.wheels.forEach(w => w.rotation.x -= dist * 150 * CFG.wheelMult);

        // ğŸš‚ çƒŸé›¾ç”Ÿæˆé€»è¾‘ä¼˜åŒ–
        // ç¡®ä¿çŸ©é˜µæ›´æ–°ï¼Œä»¥è·å–å‡†ç¡®çš„çƒŸå›±ä½ç½®
        this.loco.updateMatrixWorld(true);
        this.chim.updateMatrixWorld(true);

        // å†’çƒŸæ¦‚ç‡ï¼šä¿åº• 0.05 (é™æ­¢ä¹Ÿæœ‰å‘¼å¸æ„Ÿ) + é€Ÿåº¦åŠ æˆ
        const smokeProb = 0.05 + Math.min(speed * 5.0, 0.8);

        if(Math.random() < smokeProb) {
            vec3.setFromMatrixPosition(this.chim.matrixWorld);
            // ä»çƒŸå›±é¡¶éƒ¨å–·å‡º (yè½´å‘ä¸Šåç§»)
            vec3.y += 1.2;
            this.spawnSmoke(vec3, speed);
        }

        this.updateSmoke(speed);
        this.updateDroppedGifts(dt);
    }

    spawnSmoke(pos, trainSpeed) {
        const idx = this.smokeIdx;
        const s = this.smokeData[idx];

        s.active = true;
        s.life = 1.0 + Math.random() * 0.5; 
        s.scale = 0.6 + Math.random() * 0.4; 
        s.pos = pos.clone();
        s.trainSpeed = trainSpeed; 

        const q = new THREE.Quaternion();
        this.loco.getWorldQuaternion(q);
        const upDir = new THREE.Vector3(0, 1, 0).applyQuaternion(q).normalize();

        // ä¿®æ­£ï¼šå¤§å¹…é™ä½é€Ÿåº¦å¯¹å–·å°„åŠ›åº¦çš„å½±å“ç³»æ•°
        // åŸºç¡€ 2.5ï¼Œæœ€å¤§å¢é‡ä¹Ÿå°± +3.2 (å½“ speed=0.4æ—¶)
        // è¿™æ ·é«˜é€Ÿæ—¶è™½ç„¶å–·å¾—å¿«ï¼Œä½†ä¸ä¼šçªœä¸Šå¤©
        const burstPower = 2.5 + trainSpeed * 8.0; 

        s.vel.copy(upDir).multiplyScalar(burstPower);

        // ä¿®æ­£ï¼šå‡å°éšæœºæ¹æµï¼Œè®©çƒŸæŸ±æ›´å‡èš
        s.vel.x += (Math.random() - 0.5) * 0.6;
        s.vel.z += (Math.random() - 0.5) * 0.6;

        this.smokeIdx = (this.smokeIdx + 1) % this.smokeMax;
    }

    updateSmoke(currentSpeed) {
        let dirty = false;

        // ğŸ’¨ åŠ¨æ€é£åœºè®¡ç®— (Dynamic Wind Field)
        const t = clock.getElapsedTime();
        // åŸºç¡€é£åŠ› + é˜µé£æ‰°åŠ¨ (ä½¿ç”¨ä¸åŒé¢‘ç‡çš„æ­£å¼¦æ³¢å åŠ )
        // æ¨¡æ‹Ÿä¸€é˜µé˜µçš„é£ï¼Œé£å‘å’ŒåŠ›åº¦éšæ—¶é—´å˜åŒ–
        const windX = (Math.sin(t * 0.8) + Math.sin(t * 2.5) * 0.6) * 0.015;
        const windZ = (Math.cos(t * 0.6) + Math.sin(t * 1.9) * 0.6) * 0.015;

        for(let i=0; i<this.smokeMax; i++) {
            const s = this.smokeData[i];
            if(!s.active) continue;

            // 1. åº”ç”¨é£åŠ› (åœ¨é˜»åŠ›ä¹‹å‰åº”ç”¨ï¼Œè®©é£æŒç»­æ¨åŠ¨)
            s.vel.x += windX;
            s.vel.z += windZ;

            // 2. ç‰©ç†è¿åŠ¨
            s.pos.add(s.vel);

            // 3. ç©ºæ°”é˜»åŠ› (Air Resistance)
            // é€Ÿåº¦æå¿«è¡°å‡ï¼Œæ¨¡æ‹Ÿæ’å‡»é™æ­¢ç©ºæ°”
            s.vel.multiplyScalar(0.85); 

            // 4. çƒ­æµ®åŠ› (Buoyancy)
            if (s.vel.y < 0.8) {
                s.vel.y += 0.02; 
            }

            // æ°”ä½“è†¨èƒ€
            const age = 1.0 - (s.life / 1.5); 
            const expansion = 1.0 + age * 3.0; 
            
            s.life -= 0.016;

            if(s.life <= 0) {
                s.active = false;
                this.dummy.position.set(0, -1000, 0);
                this.dummy.updateMatrix();
                this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
                dirty = true;
                continue;
            }

            // æ›´æ–°å˜æ¢
            this.dummy.position.copy(s.pos);
            this.dummy.scale.setScalar(s.scale * expansion);
            this.dummy.rotation.set(age, age, age); 
            this.dummy.updateMatrix();
            
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            dirty = true;
        }

        if(dirty) this.smokeMesh.instanceMatrix.needsUpdate = true;
    }
    place(o, t) {
        const p = this.curve.getPointAt(t);
        const tan = this.curve.getTangentAt(t);
        o.position.copy(p);
        // ğŸš‚ æ ¹æ®è¡Œé©¶æ–¹å‘è°ƒæ•´æœå‘ï¼šé€†æ—¶é’ˆæ—¶ç¿»è½¬åˆ‡çº¿æ–¹å‘
        const dir = STATE.trainDir > 0 ? 1 : -1;
        o.lookAt(p.x + tan.x * dir, p.y + tan.y * dir, p.z + tan.z * dir);
    }

    // ğŸ ä»è½¦å¢æ‰”å‡ºç¤¼ç›’
    throwGift(car) {
        if (!this.droppedGifts) {
            this.droppedGifts = [];
            this.giftCooldown = 0;
            this.buildGiftTemplate();
        }

        // å†·å´æ£€æŸ¥ (0.2ç§’ï¼Œå¯ä»¥æ‰”å¿«ç‚¹)
        if (Date.now() - this.giftCooldown < 200) return false;
        this.giftCooldown = Date.now();

        // åˆ›å»ºç¤¼ç›’
        const gift = this.giftTemplate.clone();
        gift.traverse(c => { if (c.isMesh) c.material = c.material.clone(); });

        // éšæœºé¢œè‰²
        const colors = [0xcc0000, 0x00aa00, 0x0066cc, 0xffaa00];
        const col = colors[Math.floor(Math.random() * colors.length)];
        gift.children[0].material.color.setHex(col);

        // ä»è½¦å¢ä¸–ç•Œä½ç½®æ‰”å‡º
        const worldPos = new THREE.Vector3();
        car.getWorldPosition(worldPos);

        // éšæœºé€‰æ‹©å·¦ä¾§æˆ–å³ä¾§ (-1 æˆ– 1)
        const side = Math.random() > 0.5 ? 1 : -1;

        // è·å–è½¦å¢çš„â€œå³â€å‘é‡ (Local X axis)
        const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(car.quaternion);
        
        // è·å–è½¦å¢çš„â€œä¸Šâ€å‘é‡ (Local Y axis)
        const upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(car.quaternion);

        // èµ·å§‹ä½ç½®ï¼šè½¦å¢ä¾§é¢çª—æˆ·é«˜åº¦
        gift.position.copy(worldPos);
        gift.position.addScaledVector(rightVec, side * 2.0); // å‘å¤–åç§»
        gift.position.addScaledVector(upVec, 1.0); // ç¨å¾®å‘ä¸Š
        gift.scale.set(0.5, 0.5, 0.5);

        scene.add(gift);

        // è®¡ç®—æŠ›å‡ºé€Ÿåº¦å‘é‡
        // 1. åŸºç¡€ä¾§å‘é€Ÿåº¦ (å‘å¤–)
        const throwVel = rightVec.clone().multiplyScalar(side * (8 + Math.random() * 8)); 
        
        // 2. å‚ç›´åˆ†é‡ (å‘ä¸ŠæŠ›)
        throwVel.add(upVec.clone().multiplyScalar(5 + Math.random() * 5));

        // 3. å‰åéšæœºåˆ†é‡ (é¿å…è½ç‚¹æˆä¸€æ¡ç›´çº¿)
        const forwardVec = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
        throwVel.add(forwardVec.multiplyScalar((Math.random() - 0.5) * 10));

        this.droppedGifts.push({
            mesh: gift,
            vel: throwVel,
            rotVel: new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            ),
            landed: false
        });

        return true;
    }

    buildGiftTemplate() {
        // ä½¿ç”¨å…±äº«å·¥å‚åˆ›å»ºå°å·ç¤¼ç›’æ¨¡æ¿
        this.giftTemplate = GiftFactory.createTemplate({ size: 2, bowMat: 'gold' });
    }

    updateDroppedGifts(dt) {
        if (!this.droppedGifts) return;

        // ä½¿ç”¨ç»Ÿä¸€çš„ç‰©ç†æ›´æ–°
        for (const g of this.droppedGifts) {
            GiftFactory.updateGiftPhysics(g, dt, { gravity: 25, groundY: 1 });
        }

        // é™åˆ¶åœ°é¢ç¤¼ç›’æ•°é‡ (æœ€å¤š20ä¸ª)
        while (this.droppedGifts.length > 20) {
            const oldest = this.droppedGifts.shift();
            scene.remove(oldest.mesh);

            // ğŸ—‘ï¸ å†…å­˜æ¸…ç†
            oldest.mesh.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        }
    }

    // ğŸ’¡ è½¦å¢çª—æˆ·é—ªçƒæ•ˆæœ
    flashWindows(car) {
        const windows = car.userData.windows;
        if (!windows || windows.length === 0) return;

        // è®°å½•åŸå§‹é¢œè‰²
        const originalColors = windows.map(w => w.material.color.getHex());

        // é—ªçƒåºåˆ—
        let flashCount = 0;
        const maxFlash = 4;
        const flashInterval = setInterval(() => {
            const bright = flashCount % 2 === 0;
            windows.forEach(w => {
                w.material.color.setHex(bright ? 0xffffff : 0xffccaa);
            });
            flashCount++;
            if (flashCount >= maxFlash) {
                clearInterval(flashInterval);
                // æ¢å¤åŸè‰²
                windows.forEach((w, i) => w.material.color.setHex(originalColors[i]));
            }
        }, 80);
    }
}

class Fireworks {
    constructor(sc) {
        this.sc = sc;
        this.activeRockets = [];

        // çº¹ç†ç”Ÿæˆ
        const c = document.createElement('canvas'); c.width=32; c.height=32;
        const x = c.getContext('2d'); 
        const g = x.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent'); 
        x.fillStyle=g; x.fillRect(0,0,32,32);
        this.tex = new THREE.CanvasTexture(c);
        
        this.cols = [[0xff0000,0xffaa00],[0x00ffff,0x0000ff],[0xff00ff,0xffaaaa],[0x00ff00,0xffff00]];
        this.sharedMat = new THREE.PointsMaterial({
            size: 8.0, map: this.tex, transparent: true, depthWrite: false,
            blending: THREE.AdditiveBlending, vertexColors: true
        });

        // ç«ç®­å…±äº«æè´¨
        this.rocketMat = new THREE.PointsMaterial({
            color: 0xffddaa, size: 5, map: this.tex,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        });
        // ç«ç®­å…±äº«å‡ ä½•ä½“ï¼ˆå•ç‚¹ï¼‰
        this.rocketGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);

        // å¤ç”¨é¢œè‰²å¯¹è±¡
        this._tempColor = new THREE.Color();

        // --- å¯¹è±¡æ± åˆå§‹åŒ– ---
        this.poolSize = 15; // æœ€å¤§åŒæ—¶å­˜åœ¨çš„çˆ†ç‚¸æ•°
        this.pool = [];
        const particlesPerExplosion = 80;

        for(let i=0; i<this.poolSize; i++) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particlesPerExplosion * 3);
            const col = new Float32Array(particlesPerExplosion * 3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            
            const m = new THREE.Points(geo, this.sharedMat);
            m.frustumCulled = false; // é¿å…è§†é”¥å‰”é™¤è®¡ç®—
            m.visible = false;
            this.sc.add(m);
            
            this.pool.push({
                mesh: m,
                velocities: new Float32Array(particlesPerExplosion * 3), // é¢„åˆ†é…é€Ÿåº¦æ•°ç»„
                life: 0,
                available: true
            });
        }
    }

    launch(pos) {
        // ç«ç®­ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“å’Œæè´¨
        if(!pos) pos = new THREE.Vector3((Math.random()-0.5)*50, -5, (Math.random()-0.5)*50);
        const ty = pos.y + 50 + Math.random()*40;
        const pal = this.cols[Math.floor(Math.random()*this.cols.length)];

        const m = new THREE.Points(this.rocketGeo, this.rocketMat); // ä½¿ç”¨å…±äº«èµ„æº
        m.position.copy(pos);
        this.sc.add(m);

        this.activeRockets.push({
            m, pos: pos.clone(),
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.sqrt(2*0.02*(ty-pos.y)), (Math.random()-0.5)*0.5),
            pal
        });
    }

    update() {
        // 1. æ›´æ–°ç«ç®­
        for(let i = this.activeRockets.length - 1; i >= 0; i--) {
            const r = this.activeRockets[i];
            r.pos.add(r.vel); r.vel.y -= 0.02; r.m.position.copy(r.pos);
            if(r.vel.y <= 0.5) {
                this.sc.remove(r.m);
                this.explode(r.pos, r.pal);
                this.activeRockets.splice(i, 1);
            }
        }

        // 2. æ›´æ–°çˆ†ç‚¸ (ä½¿ç”¨å¯¹è±¡æ± )
        for(let i = 0; i < this.poolSize; i++) {
            const p = this.pool[i];
            if(p.available) continue;

            p.life -= 0.015;
            if(p.life <= 0) {
                p.mesh.visible = false;
                p.available = true; // å½’è¿˜åˆ°æ± å­
                continue;
            }

            const positions = p.mesh.geometry.attributes.position.array;
            const colors = p.mesh.geometry.attributes.color.array;
            
            for(let k=0; k<80; k++) {
                const idx = k*3;
                positions[idx] += p.velocities[idx];
                positions[idx+1] += p.velocities[idx+1];
                positions[idx+2] += p.velocities[idx+2];
                
                p.velocities[idx] *= 0.92;
                p.velocities[idx+1] *= 0.92;
                p.velocities[idx+2] *= 0.92;
                p.velocities[idx+1] -= 0.02;

                // ç®€å•çš„æ·¡å‡º (ç›´æ¥ä¿®æ”¹é¢œè‰² buffer)
                if(p.life < 1.0) {
                    colors[idx] *= 0.94; colors[idx+1] *= 0.94; colors[idx+2] *= 0.94;
                }
            }
            p.mesh.geometry.attributes.position.needsUpdate = true;
            p.mesh.geometry.attributes.color.needsUpdate = true;
        }
    }

    explode(pos, pal) {
        const styleIdx = window.getFireworkSoundStyle?.() ?? -1;
        audio.explode(styleIdx);

        // ä»æ± ä¸­æŸ¥æ‰¾å¯ç”¨å¯¹è±¡
        const item = this.pool.find(p => p.available);
        if(!item) return; // æ± å­æ»¡äº†å°±å¿½ç•¥ï¼Œä¿è¯æ€§èƒ½

        item.available = false;
        item.life = 1.5;
        item.mesh.visible = true;

        const posAttr = item.mesh.geometry.attributes.position.array;
        const colAttr = item.mesh.geometry.attributes.color.array;

        // é‡ç½®ç²’å­çŠ¶æ€ï¼ˆä½¿ç”¨å¤ç”¨é¢œè‰²å¯¹è±¡ï¼‰
        for(let i=0; i<80; i++) {
            const idx = i*3;
            // ä½ç½®é‡ç½®ä¸ºçˆ†ç‚¸ä¸­å¿ƒ
            posAttr[idx] = pos.x; posAttr[idx+1] = pos.y; posAttr[idx+2] = pos.z;

            // é€Ÿåº¦é‡ç½®
            const speed = 0.5 + Math.random() * 2.8;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            item.velocities[idx] = speed * Math.sin(phi) * Math.cos(theta);
            item.velocities[idx+1] = speed * Math.sin(phi) * Math.sin(theta);
            item.velocities[idx+2] = speed * Math.cos(phi);

            // é¢œè‰²é‡ç½® - ä½¿ç”¨å¤ç”¨é¢œè‰²å¯¹è±¡
            this._tempColor.setHex(pal[Math.floor(Math.random() * pal.length)]);
            this._tempColor.multiplyScalar(1.5);
            colAttr[idx] = this._tempColor.r;
            colAttr[idx+1] = this._tempColor.g;
            colAttr[idx+2] = this._tempColor.b;
        }
        item.mesh.geometry.attributes.position.needsUpdate = true;
        item.mesh.geometry.attributes.color.needsUpdate = true;
    }
}

// âœ¨ ç‹¬ç«‹çš„é­”æ³•å°¾è¿¹ç³»ç»Ÿ (ç»†è…»é‡‘æ²™ç‰ˆ - æœ€ç»ˆå®šç¨¿)
class MagicTrail {
    constructor(scene) {
        this.maxParticles = 1200;
        this.particles = [];
        this.scene = scene;

        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); 
        const g = cx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0, 'rgba(255, 255, 255, 0.9)');   // æ ¸å¿ƒç•¥ç™½
        g.addColorStop(0.4, 'rgba(255, 210, 80, 0.4)');  // ä¸­é—´æ·¡é‡‘
        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
        cx.fillStyle = g; cx.fillRect(0,0,32,32);
        const tex = new THREE.CanvasTexture(cv);

        this.geo = new THREE.BufferGeometry();
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));
        this.geo.setAttribute('opacity', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));

        this.mat = new THREE.ShaderMaterial({
            uniforms: { map: { value: tex } },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                attribute float opacity;
                varying vec3 vColor;
                varying float vOpacity;
                void main() {
                    vColor = color;
                    vOpacity = opacity;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    // å°ºå¯¸ç³»æ•°é™è‡³ 700ï¼Œç¡®ä¿ç²’å­ç»†è…»
                    gl_PointSize = size * (700.0 / -mvPosition.z); 
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                varying vec3 vColor;
                varying float vOpacity;
                void main() {
                    vec4 texColor = texture2D(map, gl_PointCoord);
                    if (texColor.a < 0.05) discard;
                    // NormalBlending æ··åˆï¼ŒæŸ”å’Œä¸åˆºçœ¼
                    gl_FragColor = vec4(vColor, texColor.a * vOpacity); 
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.NormalBlending 
        });

        this.mesh = new THREE.Points(this.geo, this.mat);
        this.mesh.frustumCulled = false; 
        
        const posAttr = this.geo.attributes.position;
        for(let i=0; i<this.maxParticles; i++) posAttr.setXYZ(i, 0, -9999, 0);
        
        this.scene.add(this.mesh);
    }

    update(dt) {
        const positions = this.geo.attributes.position;
        const opacities = this.geo.attributes.opacity;
        const sizes = this.geo.attributes.size;
        const colors = this.geo.attributes.color;

        for(let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.life -= dt;

            if(p.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }

            p.pos.addScaledVector(p.vel, dt);
            p.vel.y -= 6.0 * dt; // ä¿æŒä¸‹å æ„Ÿ
            p.vel.multiplyScalar(0.98); 

            const age = p.life / p.maxLife; 
            p.currOpacity = age * 0.8; // é€æ˜åº¦ä¸Šé™ 0.8
            p.currSize = p.baseSize * (0.6 + 0.4 * age); 
        }

        for(let i=0; i<this.maxParticles; i++) {
            if(i < this.particles.length) {
                const p = this.particles[i];
                positions.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);
                opacities.setX(i, p.currOpacity);
                sizes.setX(i, p.currSize);
                // æš—é‡‘è‰²ï¼Œè´¨æ„Ÿæ›´å¥½
                colors.setXYZ(i, 0.9, 0.7, 0.2); 
            } else {
                positions.setXYZ(i, 0, -9999, 0);
                opacities.setX(i, 0);
            }
        }

        positions.needsUpdate = true;
        opacities.needsUpdate = true;
        sizes.needsUpdate = true;
        colors.needsUpdate = true;
    }

    emit(pos, quat, intensity) {
        if (intensity <= 0.05) return;

        const count = Math.floor(2 + intensity * 4); 
        const offset = new THREE.Vector3();
        const backDir = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();

        for(let k=0; k<count; k++) {
            if(this.particles.length >= this.maxParticles) break;

            const side = Math.random() > 0.5 ? 1.8 : -1.8;
            
            offset.set(
                side + (Math.random()-0.5) * 0.2, 
                0.0, 
                4.0 + Math.random() * 2.0 
            ).applyQuaternion(quat);

            const p = {
                pos: pos.clone().add(offset),
                // ä¿æŒå‘åçš„æƒ¯æ€§é€Ÿåº¦ï¼Œè¿™éƒ¨åˆ†é€»è¾‘æ˜¯å¯¹çš„
                vel: backDir.clone().multiplyScalar(4.0 + Math.random() * 4.0) 
                    .add(new THREE.Vector3(
                        (Math.random()-0.5) * 0.2, 
                        0, 
                        (Math.random()-0.5) * 0.2
                    )),
                life: 0.6 + Math.random() * 0.6, 
                maxLife: 0,
                baseSize: 1.5 + Math.random() * 2.0, // å°ºå¯¸å‡å°
                currSize: 0,
                currOpacity: 1
            };
            p.maxLife = p.life;
            this.particles.push(p);
        }
    }
}

// ğŸ¦Œ åœ£è¯è€äººé©¯é¹¿é›ªæ©‡ - å¢å¼ºç‰ˆ
class SantaSleigh {
    constructor(sc) {
        this.scene = sc;
        this.group = new THREE.Group();
        this.active = false;
        this.nextTrigger = 12 + Math.random() * 8; 
        this.elapsed = 0;

        this.phase = 'idle';
        this.phaseTime = 0;

        this.approachDur = 4;    
        this.syncDur = 3;        
        this.dropDur = 0.8;      
        this.departDur = 4;      
        this.hoverHeight = 35;   

        this.fallingGifts = [];
        
        // ğŸ› ï¸ GC ä¼˜åŒ–ï¼šé¢„åˆ†é…å¤ç”¨å¯¹è±¡
        this._tempVel = new THREE.Vector3();
        this._tempVec = new THREE.Vector3();
        this._targetPos = new THREE.Vector3();
        this._lookPos = new THREE.Vector3();
        this._sleighWorldPos = new THREE.Vector3();
        
        this._targetQuat = new THREE.Quaternion();
        this._lookMatrix = new THREE.Matrix4();
        this._upVector = new THREE.Vector3(0, 1, 0);
        this._lookDir = new THREE.Vector3();

        this.buildSleigh();
        this.buildReindeer();
        // ğŸŒŸ ä½¿ç”¨æ–°çš„æ¨¡å—åŒ–å°¾è¿¹ç³»ç»Ÿ
        this.trail = new MagicTrail(sc);
        this.buildGiftTemplate();

        // ğŸ”§ ä¿®æ­£æœå‘ä¸ä½ç½®
        this.reindeer.rotation.y = Math.PI; 
        this.sleigh.rotation.y = Math.PI;
        this.reindeer.position.set(0, 0, -6); 
        this.sleigh.position.set(0, 0, 6);

        this.group.visible = false;
        this.group.scale.set(1.0, 1.0, 1.0); 
        sc.add(this.group);
    }

    buildSleigh() {
        const sleighG = new THREE.Group();

        const matRed = new THREE.MeshStandardMaterial({ color: 0xb71c1c, roughness: 0.4 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }); // ç»’æ¯›æ„Ÿ
        const matFace = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.5 });

        // ğŸ›· é›ªæ©‡ä¸»ä½“
        const createRunner = (x) => {
            const rG = new THREE.Group();
            rG.position.set(x, 0, 0);
            
            // ç›´æ®µ
            const straight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 6), matGold);
            straight.position.y = 0.2;
            rG.add(straight);

            // å·æ›²å‰ç«¯
            const curl = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.15, 8, 16, Math.PI), matGold);
            curl.position.set(0, 1.7, 3.0); // å‰ç«¯
            curl.rotation.y = Math.PI/2;
            curl.rotation.z = Math.PI/4; // å‘ä¸Šå·
            rG.add(curl);

            // æ”¯æ’‘æ†
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), matGold);
            leg1.position.set(0, 1.0, 1.5);
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), matGold);
            leg2.position.set(0, 1.0, -1.5);
            rG.add(leg1, leg2);

            return rG;
        };
        sleighG.add(createRunner(1.8));
        sleighG.add(createRunner(-1.8));

        // è½¦å¢
        const carriage = new THREE.Group();
        carriage.position.y = 2.0;
        
        // åº•æ¿
        const floor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 5), matRed);
        carriage.add(floor);
        
        // ä¾§æ¿ (å¸¦å¼§åº¦)
        const sideGeo = new THREE.BoxGeometry(0.2, 2, 5);
        const sideL = new THREE.Mesh(sideGeo, matRed); sideL.position.set(1.9, 1, 0);
        const sideR = new THREE.Mesh(sideGeo, matRed); sideR.position.set(-1.9, 1, 0);
        // é èƒŒ
        const back = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 0.2), matRed);
        back.position.set(0, 1.25, -2.4);
        
        // é‡‘è‰²è¾¹ç¼˜
        const rimL = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 5.2).rotateX(Math.PI/2), matGold);
        rimL.position.set(1.9, 2.0, 0);
        const rimR = rimL.clone(); rimR.position.set(-1.9, 2.0, 0);
        
        carriage.add(sideL, sideR, back, rimL, rimR);
        sleighG.add(carriage);

        // ğŸ… åœ£è¯è€äºº
        const santa = new THREE.Group();
        santa.position.set(0, 2.5, -0.5);

        // èº«ä½“ (èƒ–)
        const body = new THREE.Mesh(new THREE.SphereGeometry(1.4, 12, 12), matRed);
        body.scale.y = 1.2;
        santa.add(body);

        // çº½æ‰£
        for(let i=0; i<3; i++) {
            const btn = new THREE.Mesh(new THREE.SphereGeometry(0.15), matGold);
            btn.position.set(0, 0.5 + i*0.6, 1.2);
            santa.add(btn);
        }

        // å¤´
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 12, 12), matFace);
        head.position.y = 2.2;
        santa.add(head);

        // å¤§èƒ¡å­ (ä¸è§„åˆ™å½¢çŠ¶)
        const beard = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6, 0), matWhite);
        beard.position.set(0, 1.9, 0.6);
        beard.scale.set(1, 1.2, 0.5);
        santa.add(beard);

        // å¸½å­
        const hatGroup = new THREE.Group();
        hatGroup.position.y = 2.7;
        hatGroup.rotation.x = -0.2; // ç¨å¾®åä»°
        
        const hatBrim = new THREE.Mesh(new THREE.TorusGeometry(0.75, 0.2, 8, 16), matWhite);
        hatBrim.rotation.x = Math.PI/2;
        
        const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.8, 16), matRed);
        hatCone.position.y = 0.9;
        hatCone.rotation.x = -0.2; // å¸½å°–åå‚
        
        const hatBall = new THREE.Mesh(new THREE.SphereGeometry(0.25), matWhite);
        hatBall.position.set(0, 1.7, -0.4); // å‚åœ¨åé¢

        hatGroup.add(hatBrim, hatCone, hatBall);
        santa.add(hatGroup);

        // æ‰‹è‡‚ (ä¸¾ç€ç¼°ç»³)
        const armGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5);
        const armL = new THREE.Mesh(armGeo, matRed);
        armL.position.set(1.2, 1.2, 0.5);
        armL.rotation.set(1.0, 0, -0.5); // å‘å‰ä¸¾
        const armR = new THREE.Mesh(armGeo, matRed);
        armR.position.set(-1.2, 1.2, 0.5);
        armR.rotation.set(1.0, 0, 0.5);
        
        // æ‰‹å¥—
        const gloveL = new THREE.Mesh(new THREE.SphereGeometry(0.35), matWhite);
        gloveL.position.y = 0.8; 
        armL.add(gloveL);
        const gloveR = gloveL.clone();
        armR.add(gloveR);

        santa.add(armL, armR);
        sleighG.add(santa);

        // ğŸ ç¤¼ç‰©è¢‹
        const sack = new THREE.Mesh(new THREE.IcosahedronGeometry(1.8, 0), new THREE.MeshStandardMaterial({color:0x8b4513}));
        sack.position.set(0, 3.0, -2.0);
        sack.scale.set(1.2, 1.0, 0.8);
        sack.rotation.z = 0.2;
        sleighG.add(sack);

        // æ•´ä½“ä½ç½®ï¼šæ”¾åœ¨é©¯é¹¿åé¢ (reindeer åœ¨ 0,0,0 é™„è¿‘)
        // æˆ‘ä»¬çš„é©¯é¹¿æœå‘ +Z (å‰è¿›)ï¼Œæ‰€ä»¥é›ªæ©‡åœ¨ -Z æ–¹å‘
        // ä¹‹å‰çš„ä»£ç é€»è¾‘é‡Œ forward æ˜¯ -Z? ä¸ï¼Œæˆ‘ä»¬ä¹‹å‰çš„ buildReindeer æ”¹ä¸º +Z å‰è¿›äº†ã€‚
        // æ‰€ä»¥è¿™é‡Œé›ªæ©‡åº”è¯¥åœ¨ -Z ä½ç½®ã€‚
        sleighG.position.set(0, 0, -5);
        sleighG.scale.set(0.8, 0.8, 0.8);

        this.sleigh = sleighG;
        this.group.add(sleighG);
    }

    buildReindeer() {
        const reindeerG = new THREE.Group();
        
        // æè´¨
        const matSkin = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.9 }); // é¹¿çš®è¤
        const matDark = new THREE.MeshStandardMaterial({ color: 0x4a3015, roughness: 0.9 }); // æ·±è‰²è¹„å­/è§’
        const matNose = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 }); // é»‘é¼»å­
        const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive:0xff0000, emissiveIntensity:0.8 }); // çº¢é¼»å­

        // ğŸ¦Œ æ„å»ºå•åªé©¯é¹¿
        const createDeer = (isRudolph) => {
            const deer = new THREE.Group();

            // 1. èº¯å¹² (Torso)
            const bodyGeo = new THREE.BoxGeometry(1.1, 1.3, 2.6);
            const body = new THREE.Mesh(bodyGeo, matSkin);
            body.position.y = 2.0;
            deer.add(body);

            // 2. è„–å­ (Neck)
            const neck = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.5, 0.9), matSkin);
            neck.position.set(0, 3.0, 1.4); // åå‰
            neck.rotation.x = -Math.PI / 6; // å‘åä»°
            deer.add(neck);

            // 3. å¤´éƒ¨ (Head)
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 3.8, 1.9);
            
            // è„¸éƒ¨ä¸»ä½“
            const face = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.85, 1.2), matSkin);
            headGroup.add(face);
            
            // å˜´éƒ¨çªå‡º
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.5, 0.6), matSkin);
            snout.position.set(0, -0.15, 0.7);
            headGroup.add(snout);

            // é¼»å­ (Nose)
            const noseMat = isRudolph ? matRed : matNose;
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), noseMat);
            nose.position.set(0, 0.15, 1.0);
            headGroup.add(nose);
            if(isRudolph) {
                const light = new THREE.PointLight(0xff0000, 1.5, 10);
                light.position.set(0, 0.2, 1.2);
                headGroup.add(light);
            }

            // è€³æœµ
            const earGeo = new THREE.BoxGeometry(0.6, 0.3, 0.15);
            const earL = new THREE.Mesh(earGeo, matSkin);
            earL.position.set(0.5, 0.2, -0.3);
            earL.rotation.set(0, 0.4, 0.3);
            const earR = new THREE.Mesh(earGeo, matSkin);
            earR.position.set(-0.5, 0.2, -0.3);
            earR.rotation.set(0, -0.4, -0.3);
            headGroup.add(earL, earR);

            // é¹¿è§’ (Antlers)
            const antGeo = new THREE.CylinderGeometry(0.04, 0.06, 1.2);
            [1, -1].forEach(side => {
                const ant = new THREE.Mesh(antGeo, matDark);
                ant.position.set(side * 0.3, 0.8, -0.2);
                ant.rotation.z = side * 0.3;
                ant.rotation.x = -0.2;
                
                // åˆ†å‰
                const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.04,0.6), matDark);
                branch.position.y = 0.2;
                branch.position.z = 0.2;
                branch.rotation.x = Math.PI/3;
                ant.add(branch);

                headGroup.add(ant);
            });

            deer.add(headGroup);

            // 4. å››è‚¢ (Legs) - ç®€å•çš„å…³èŠ‚è¿åŠ¨æ¨¡æ‹Ÿ
            // è…¿éƒ¨å‡ ä½•ä½“
            const upperLegGeo = new THREE.BoxGeometry(0.35, 1.2, 0.35);
            const lowerLegGeo = new THREE.BoxGeometry(0.25, 1.2, 0.25);

            const createLeg = (x, z, isFront) => {
                const legG = new THREE.Group();
                legG.position.set(x, 1.5, z); // é«‹å…³èŠ‚ä½ç½®

                // å¤§è…¿
                const upper = new THREE.Mesh(upperLegGeo, matSkin);
                upper.position.y = -0.5;
                // å…³èŠ‚å¼¯æ›²ï¼šå‰è…¿å‘åå¼¯ï¼Œåè…¿å‘å‰å¼¯
                upper.rotation.x = isFront ? 0.1 : -0.1; 
                
                // å°è…¿
                const lower = new THREE.Mesh(lowerLegGeo, matSkin);
                lower.position.y = -1.1;
                lower.position.z = isFront ? -0.1 : 0.1;
                lower.rotation.x = isFront ? -0.2 : 0.2;
                
                upper.add(lower);
                legG.add(upper);
                return legG;
            };

            // å‰è…¿
            deer.add(createLeg(0.35, 1.0, true));
            deer.add(createLeg(-0.35, 1.0, true));
            // åè…¿
            deer.add(createLeg(0.35, -1.0, false));
            deer.add(createLeg(-0.35, -1.0, false));

            // å°å°¾å·´
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matSkin);
            tail.position.set(0, 2.2, -1.4);
            tail.rotation.x = 0.5;
            deer.add(tail);

            return deer;
        };

        // ğŸ¦Œ ç¼–é˜Ÿ
        // é¢†å¤´ Rudolph
        const rudolph = createDeer(true);
        rudolph.position.set(0, 0, 10); // æœ€å‰é¢
        reindeerG.add(rudolph);

        // ä¸­é—´ä¸¤å¯¹
        const d1 = createDeer(false); d1.position.set(-1.8, 0, 6);
        const d2 = createDeer(false); d2.position.set(1.8, 0, 6);
        const d3 = createDeer(false); d3.position.set(-1.8, 0, 2);
        const d4 = createDeer(false); d4.position.set(1.8, 0, 2);
        reindeerG.add(d1, d2, d3, d4);

        // ç¼°ç»³è¿æ¥
        const ropeMat = new THREE.LineBasicMaterial({ color: 0x5d3a1a });
        const pts = [
            new THREE.Vector3(0, 2.5, 10), // Rudolph Neck (Leader)
            new THREE.Vector3(0, 2.5, 6),  // Mid
            new THREE.Vector3(0, 2.5, 2),  // Back
            // ğŸ”§ ä¿®å¤ï¼šå»¶é•¿ç¼°ç»³ä»¥åŒ¹é…æ–°çš„é›ªæ©‡ä½ç½®
            // é©¯é¹¿åœ¨ -6ï¼Œé›ªæ©‡åœ¨ 6ï¼Œé—´è· 12ã€‚
            // é©¯é¹¿å±€éƒ¨åæ ‡ -Z æ˜¯åæ–¹ï¼Œæ‰€ä»¥è¦å»¶ä¼¸åˆ° -13 å·¦å³æ‰èƒ½ç¢°åˆ°åœ£è¯è€äººçš„æ‰‹
            new THREE.Vector3(0, 3.5, -13)  
        ];
        reindeerG.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), ropeMat));

        // æ•´ä½“ç¼©æ”¾ï¼šç°åœ¨çš„æ¨¡å‹å•ä½æ¯”è¾ƒå¤§ï¼Œéœ€è¦ç¼©å°ä¸€ç‚¹ä»¥åŒ¹é…ç«è½¦
        reindeerG.scale.set(0.7, 0.7, 0.7);
        
        // **å…³é”®ä¿®æ­£**ï¼šä¹‹å‰çš„æ¨¡å‹æ˜¯æœå‘ -Z çš„ï¼Œç°åœ¨æˆ‘çš„æ¨¡å‹æ„å»ºæ˜¯æœå‘ +Z (Face z=0.7)ï¼Œ
        // æ‰€ä»¥ä¸éœ€è¦æ—‹è½¬ -Math.PI/2ï¼Œæˆ–è€…éœ€è¦è°ƒæ•´ã€‚
        // æ£€æŸ¥ SantaSleigh.update: lookAt ä¹Ÿæ˜¯æœå‘ç›®æ ‡çš„ã€‚
        // é€šå¸¸ç‰©ä½“åº”è¯¥æœå‘ +Z æˆ– -Zã€‚è¿™é‡Œä¸ºäº†ç»Ÿä¸€ï¼Œæˆ‘ä»¬è®©å®ƒæœå‘ +Zï¼ˆå‰è¿›æ–¹å‘ï¼‰ã€‚
        // æ‰€ä»¥ä¸éœ€è¦é¢å¤–çš„ rotation.yã€‚
        
        this.reindeer = reindeerG;
        this.group.add(reindeerG);
    }

    buildTrail() {
        // ğŸŒŸ ç²’å­å°¾è¿¹ç³»ç»Ÿåˆå§‹åŒ–
        this.maxTrailParticles = 1000; // å¢åŠ ç²’å­ä¸Šé™
        this.trailParticles = []; 

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles * 3), 3));
        geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles * 3), 3));
        geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles), 1));

        const cv = document.createElement('canvas'); cv.width=64; cv.height=64;
        const cx = cv.getContext('2d'); 
        const g = cx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0,'rgba(255,255,255,1)');
        g.addColorStop(0.2,'rgba(255,220,100,0.9)');
        g.addColorStop(0.5,'rgba(255,180,50,0.4)');
        g.addColorStop(1,'rgba(0,0,0,0)'); 
        cx.fillStyle=g; cx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cv);

        const mat = new THREE.ShaderMaterial({
            uniforms: { map: { value: tex } },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    // è¶…å¤§å°ºå¯¸ç³»æ•°ï¼Œç¡®ä¿è¿œçœ‹ä¹Ÿæ¸…æ™°
                    gl_PointSize = size * (3000.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                varying vec3 vColor;
                void main() {
                    vec4 texColor = texture2D(map, gl_PointCoord);
                    // å¢å¼ºé€æ˜åº¦ï¼Œé˜²æ­¢çœ‹ä¸è§
                    gl_FragColor = vec4(vColor, 1.0) * texColor * 1.5;
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.trail = new THREE.Points(geo, mat);
        this.trail.frustumCulled = false; // å…³é”®ä¿®å¤ï¼šé˜²æ­¢å°¾è¿¹å› åŒ…å›´ç›’è¿‡æœŸè€Œè¢«å‰”é™¤
        
        const posAttr = geo.attributes.position;
        for(let i=0; i<this.maxTrailParticles; i++) posAttr.setXYZ(i, 0, -5000, 0);
        
        this.scene.add(this.trail);
    }

    // å‘å°„æ–°ç²’å­ (åœ¨é£è¡Œæ—¶æŒç»­è°ƒç”¨)
    emitTrail() {
        const count = 8; // åŠ å¤§å‘å°„é‡
        const offset = new THREE.Vector3();
        
        for(let k=0; k<count; k++) {
            if(this.trailParticles.length >= this.maxTrailParticles) break;

            // æ‰‡å½¢å‘å°„æºï¼šé›ªæ©‡å°¾éƒ¨
            // å› ä¸ºä¹‹å‰æˆ‘ä»¬å°† group é‡Œçš„æ¨¡å‹è½¬äº† 180åº¦ï¼Œä½† group æœ¬èº«çš„åæ ‡ç³»æ²¡å˜ã€‚
            // æˆ‘ä»¬çš„æ¨¡å‹ï¼šå¤´éƒ¨åœ¨å±€éƒ¨ -Zï¼Œå°¾éƒ¨åœ¨å±€éƒ¨ +Zã€‚
            // æ‰€ä»¥å°¾è¿¹åº”è¯¥åœ¨ +Z æ–¹å‘ç”Ÿæˆï¼Œå¹¶å‘ +Z æ–¹å‘å–·å°„ã€‚
            offset.set(
                (Math.random()-0.5) * 4.0,  // å®½ä¸€ç‚¹
                (Math.random()-0.5) * 2.0 + 2.0, 
                (Math.random()-0.5) * 2.0 + 8.0 // é å (å±€éƒ¨+Z)
            ).applyQuaternion(this.group.quaternion); 
            
            const p = {
                pos: this.group.position.clone().add(offset),
                // ç²’å­åˆé€Ÿåº¦ï¼šå‘åå–·å°„ (å±€éƒ¨ +Z)
                vel: new THREE.Vector3(0,0,1).applyQuaternion(this.group.quaternion).multiplyScalar(0.8) 
                    .add(new THREE.Vector3(
                        (Math.random()-0.5) * 0.5, 
                        -Math.random() * 0.2, 
                        (Math.random()-0.5) * 0.5
                    )),
                life: 2.0 + Math.random() * 1.5, // å¯¿å‘½æ›´é•¿
                maxLife: 0, 
                size: 6.0 + Math.random() * 6.0 // åŸºç¡€å°ºå¯¸æ›´å¤§
            };
            p.maxLife = p.life;
            this.trailParticles.push(p);
        }
    }

    // æ›´æ–°æ‰€æœ‰ç²’å­
    updateTrailParticles(dt) {
        const positions = this.trail.geometry.attributes.position;
        const colors = this.trail.geometry.attributes.color;
        const sizes = this.trail.geometry.attributes.size;

        // 1. é€»è¾‘æ›´æ–°
        for(let i = this.trailParticles.length - 1; i >= 0; i--) {
            const p = this.trailParticles[i];
            p.life -= dt;

            if(p.life <= 0) {
                this.trailParticles.splice(i, 1);
                continue;
            }

            p.pos.add(p.vel);
            p.vel.multiplyScalar(0.97); // é˜»åŠ›
        }

        // 2. æ¸²æŸ“æ›´æ–°
        for(let i=0; i<this.maxTrailParticles; i++) {
            if(i < this.trailParticles.length) {
                const p = this.trailParticles[i];
                positions.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);
                
                // é¢œè‰²ä¸å¤§å°éšç”Ÿå‘½å‘¨æœŸè¡°å‡
                const alpha = Math.pow(p.life / p.maxLife, 1.2); 
                
                // é‡‘è‰²ç³»ï¼šR=1.0, G=0.8~0.5, B=0.0
                colors.setXYZ(i, 1.0 * alpha, (0.4 + 0.4 * alpha) * alpha, 0.0); 

                sizes.setX(i, p.size * (0.3 + 0.7 * alpha));
            } else {
                // éšè—æœªä½¿ç”¨çš„ç‚¹
                positions.setXYZ(i, 0, -5000, 0); 
                sizes.setX(i, 0);
            }
        }

        positions.needsUpdate = true;
        colors.needsUpdate = true;
        sizes.needsUpdate = true;
    }



    buildGiftTemplate() {
        // ä½¿ç”¨å…±äº«å·¥å‚åˆ›å»ºå¤§å·ç¤¼ç›’æ¨¡æ¿ï¼ˆå¸¦è´è¶ç»“ä¸­å¿ƒç»“ï¼Œç™½è‰²è´è¶ç»“ï¼‰
        this.giftTemplate = GiftFactory.createTemplate({ size: 2.5, hasKnot: true, bowMat: 'white' });
    }

    createGift() {
        return GiftFactory.cloneWithUniqueMaterials(this.giftTemplate);
    }

    trigger() {
        if (this.active) return;
        if (!train) return; // éœ€è¦ç«è½¦å­˜åœ¨

        this.active = true;
        this.phase = 'approach';
        this.phaseTime = 0;
        this.group.visible = true;
        this.trailPositions = [];
        this.giftDropped = false;

        // è®°å½•è§¦å‘æ—¶çš„ç«è½¦ä½ç½®ä½œä¸ºç›®æ ‡
        this.targetTrainProg = train.prog;

        // è®¡ç®—èµ·å§‹ä½ç½®ï¼ˆå¤©è¾¹è¿œå¤„ï¼‰
        const trainPos = trackCurve.getPointAt(this.targetTrainProg);
        const angle = Math.random() * Math.PI * 2;
        this.startPos = new THREE.Vector3(
            trainPos.x + Math.cos(angle) * 600,
            250 + Math.random() * 100,
            trainPos.z + Math.sin(angle) * 600
        );

        // è®¡ç®—ç¦»å¼€ä½ç½®ï¼ˆå¦ä¸€ä¸ªæ–¹å‘çš„å¤©è¾¹ï¼‰
        const exitAngle = angle + Math.PI + (Math.random() - 0.5) * 0.5;
        this.exitPos = new THREE.Vector3(
            trainPos.x + Math.cos(exitAngle) * 600,
            200 + Math.random() * 100,
            trainPos.z + Math.sin(exitAngle) * 600
        );

        this.group.position.copy(this.startPos);

        // æ’­æ”¾è¿œå¤„é“ƒé“›å£°
        if (audio && audio.bell) {
            audio.bell();
        }
    }

    update(dt) {
        this.elapsed += dt;

        // 1. å§‹ç»ˆæ›´æ–°å°¾è¿¹ç³»ç»Ÿ (å¤„ç†æ®‹ç•™ç²’å­)
        if (this.trail) this.trail.update(dt);
        
        this.updateFallingGifts(dt);

        if (!this.active && this.elapsed >= this.nextTrigger) {
            this.trigger();
            this.nextTrigger = this.elapsed + 30 + Math.random() * 40; 
        }

        if (!this.active) {
            // å¦‚æœä¸æ´»åŠ¨ï¼Œé‡ç½®ä¸Šä¸€å¸§ä½ç½®ï¼Œé˜²æ­¢ä¸‹æ¬¡å‡ºç°æ—¶é€Ÿåº¦è®¡ç®—é”™è¯¯
            if (this._lastPos) this._lastPos.copy(this.group.position);
            return;
        }

        // åˆå§‹åŒ–ä¸Šä¸€å¸§ä½ç½®
        if (!this._lastPos) this._lastPos = this.group.position.clone();

        // 2. è®¡ç®—ç‰©ç†é€Ÿåº¦ (ç”¨äºæ§åˆ¶å°¾è¿¹å¼ºåº¦)
        const dist = this.group.position.distanceTo(this._lastPos);
        const currentSpeed = dist / dt; // å•ä½/ç§’
        
        // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
        this._lastPos.copy(this.group.position);

        // 3. åŸºäºé€Ÿåº¦çš„å–·å°„å¼ºåº¦
        // é€Ÿåº¦çº¦å¿«ï¼Œå–·å¾—è¶ŠçŒ›ï¼›æ‚¬åœæ—¶é€Ÿåº¦æ¥è¿‘0ï¼Œè‡ªåŠ¨åœæ­¢å–·å°„
        // 30.0 æ˜¯ç»éªŒå€¼ï¼Œå¤§æ¦‚å¯¹åº”å…¨é€Ÿé£è¡Œæ—¶çš„é€Ÿåº¦
        const emissionIntensity = Math.min(currentSpeed / 30.0, 1.0);

        // å‘å°„å°¾è¿¹
        if (this.trail) {
            this.trail.emit(this.group.position, this.group.quaternion, emissionIntensity);
        }

        this.phaseTime += dt;

        // --- åŸæœ‰é£è¡Œé€»è¾‘ ---
        const trainPos = train ? trackCurve.getPointAt(train.prog) : this._tempVec.set(0,0,0);
        const trainTan = train ? trackCurve.getTangentAt(train.prog) : new THREE.Vector3(0, 0, 1); 
        
        this._lookPos.copy(trainTan).multiplyScalar(STATE.trainDir); 
        const trainDir = this._lookPos; 

        const hoverPos = this._tempVec.copy(trainPos);
        hoverPos.y += this.hoverHeight;

        let updateLook = false;

        switch (this.phase) {
            case 'approach': {
                const t = Math.min(this.phaseTime / this.approachDur, 1);
                const easeT = 1 - Math.pow(1 - t, 3); 

                this._targetPos.copy(this.startPos).lerp(hoverPos, easeT);
                this._targetPos.y += Math.sin(t * Math.PI) * 20; 

                this._lookPos.copy(hoverPos);
                updateLook = true;

                if (t >= 1) {
                    this.phase = 'sync';
                    this.phaseTime = 0;
                    if (audio && audio.bell) audio.bell();
                }
                break;
            }

            case 'sync': {
                const t = this.phaseTime / this.syncDur;

                this._targetPos.copy(hoverPos);
                this._targetPos.y += Math.sin(this.elapsed * 2) * 1.5;

                const tDir = trainTan.clone().multiplyScalar(STATE.trainDir);
                this._lookPos.copy(this._targetPos).addScaledVector(tDir, 20);
                updateLook = true;

                if (t >= 0.5 && !this.giftDropped) {
                    if (!this._sleighWorldPos) this._sleighWorldPos = new THREE.Vector3();
                    this._sleighWorldPos.set(0, 2, 5); 
                    this._sleighWorldPos.applyMatrix4(this.group.matrixWorld);

                    this.dropGift(this._sleighWorldPos);
                    this.giftDropped = true;
                }

                if (t >= 1) {
                    this.phase = 'depart';
                    this.phaseTime = 0;
                    if(!this.departStart) this.departStart = new THREE.Vector3();
                    this.departStart.copy(this._targetPos);
                }
                break;
            }

            case 'depart': {
                const t = Math.min(this.phaseTime / this.departDur, 1);
                const easeT = t * t; 

                this._targetPos.copy(this.departStart).lerp(this.exitPos, easeT);
                this._targetPos.y += Math.sin(t * Math.PI) * 30; 

                this._lookPos.copy(this.exitPos);
                updateLook = true;

                if (t >= 1) {
                    this.active = false;
                    this.group.visible = false;
                    this.phase = 'idle';
                }
                break;
            }
        }

        if (this.active) {
            this.group.position.lerp(this._targetPos, 0.1);

            if (updateLook) {
                this._lookDir.copy(this._lookPos).sub(this.group.position).normalize();
                if (this._lookDir.length() > 0.01) {
                    this._lookMatrix.lookAt(this.group.position, this._lookPos, this._upVector);
                    this._targetQuat.setFromRotationMatrix(this._lookMatrix);
                    this.group.quaternion.slerp(this._targetQuat, 0.05);
                }
            }

            this.group.position.y += Math.sin(this.elapsed * 3) * 0.5;

            if (this.reindeer) {
                this.reindeer.children.forEach((deer, i) => {
                    if (deer.type === 'Group') {
                        deer.rotation.x = Math.sin(this.elapsed * 8 + i) * 0.15;
                    }
                });
            }
        }
    }

    dropGift(fromPos) {
        if (!train || train.cars.length === 0) return;

        // 1. éšæœºé”å®šä¸€èŠ‚ç›®æ ‡è½¦å¢
        const targetIndex = Math.floor(Math.random() * train.cars.length);
        const targetCar = train.cars[targetIndex];

        const gift = this.createGift();
        gift.position.copy(fromPos);
        gift.scale.set(0.8, 0.8, 0.8);
        this.scene.add(gift);

        if (audio && audio.bell) audio.bell();

        // 2. å¯ç”¨â€œåˆ¶å¯¼æ¨¡å¼â€
        this.fallingGifts.push({
            mesh: gift,
            startPos: fromPos.clone(), // è®°å½•èµ·ç‚¹
            targetCar: targetCar,      // é”å®šç›®æ ‡
            time: 0,                   // å·²é£æ—¶é—´
            duration: 1.2,             // æ€»é£è¡Œæ—¶é—´ (ç§’) - ç¨å¾®å¿«ä¸€ç‚¹
            arcHeight: 25,             // æŠ›ç‰©çº¿é«˜åº¦
            landed: false,
            rotVel: new THREE.Vector3( // éšæœºè‡ªæ—‹
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).multiplyScalar(5.0)
        });
    }

    updateFallingGifts(dt) {
        // å¤ç”¨å‘é‡ï¼Œå‡å°‘GC
        const _targetWorldPos = new THREE.Vector3();
        const _currentPos = new THREE.Vector3();

        for (let i = this.fallingGifts.length - 1; i >= 0; i--) {
            const g = this.fallingGifts[i];

            if (g.landed) {
                // å·²è½åœ°é€»è¾‘ï¼šéšè½¦ç§»åŠ¨ä¸€æ®µæ—¶é—´åæ¶ˆå¤±
                g.life -= dt;
                if(g.life <= 0) {
                    if(g.mesh.parent) g.mesh.parent.remove(g.mesh);
                    
                    // ğŸ—‘ï¸ å†…å­˜æ¸…ç†ï¼šæ·±åº¦é”€æ¯å‡ ä½•ä½“å’Œæè´¨
                    g.mesh.traverse(child => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    });
                    
                    this.fallingGifts.splice(i, 1);
                }
                continue; 
            }

            // --- åˆ¶å¯¼é£è¡Œé€»è¾‘ ---
            g.time += dt;
            const t = Math.min(g.time / g.duration, 1.0);
            
            // 1. è·å–ç›®æ ‡è½¦å¢å½“å‰çš„å®æ—¶ä¸–ç•Œåæ ‡ (è½¦é¡¶ä½ç½®)
            g.targetCar.getWorldPosition(_targetWorldPos);
            _targetWorldPos.y += 3.0; // ä¿®æ­£åˆ°è½¦é¡¶é«˜åº¦

            // 2. çº¿æ€§æ’å€¼ (Lerp) - åŸºç¡€è½¨è¿¹
            _currentPos.copy(g.startPos).lerp(_targetWorldPos, t);

            // 3. å åŠ æŠ›ç‰©çº¿é«˜åº¦ (Arc)
            const heightOffset = Math.sin(t * Math.PI) * g.arcHeight;
            _currentPos.y += heightOffset;

            g.mesh.position.copy(_currentPos);

            // 4. æ—‹è½¬åŠ¨ç”»
            g.mesh.rotation.x += g.rotVel.x * dt;
            g.mesh.rotation.y += g.rotVel.y * dt;
            g.mesh.rotation.z += g.rotVel.z * dt;

            // --- åˆ¤å®šè½åœ° ---
            if (t >= 1.0) {
                // å¼ºåˆ¶å¸é™„
                const car = g.targetCar;
                this.scene.remove(g.mesh);
                car.add(g.mesh);

                // è®¾å®šåœ¨è½¦é¡¶çš„å±€éƒ¨åæ ‡
                // é™åˆ¶åœ¨è½¦é¡¶è¾ƒå¹³å¦çš„åŒºåŸŸ (-1.0 ~ 1.0)ï¼Œé¿å…æ»‘è½
                const localX = (Math.random() - 0.5) * 2.0; 
                const localZ = (Math.random() - 0.5) * 6.5; // è½¦é•¿èŒƒå›´

                // è®¡ç®—ç²¾ç¡®çš„è½¦é¡¶è¡¨é¢é«˜åº¦
                const roofRadius = 2.05;
                const roofCenterY = 5.1;
                const safeX = Math.max(-roofRadius * 0.9, Math.min(roofRadius * 0.9, localX));
                const surfaceY = roofCenterY + Math.sqrt(roofRadius * roofRadius - safeX * safeX);
                
                // ç¤¼ç‰©ä¸­å¿ƒé«˜åº¦ = è¡¨é¢é«˜åº¦ + åŠé«˜(0.4) - åµŒå…¥é‡(0.05)
                const giftY = surfaceY + 0.35;

                g.mesh.position.set(localX, giftY, localZ); 
                
                // è®¡ç®—æ–œç‡ï¼Œè®©ç¤¼ç‰©è´´åˆåœ†å¼§
                const slope = Math.atan2(safeX, Math.sqrt(roofRadius * roofRadius - safeX * safeX));
                
                // è®¾ç½®æ—‹è½¬ï¼šæ°´å¹³éšæœºè½¬ + å‚ç›´è´´åˆæ–œç‡
                g.mesh.rotation.set(0, Math.random() * Math.PI * 2, -slope);
                g.mesh.scale.set(0.8, 0.8, 0.8);

                g.landed = true;
                g.life = 15.0; // å­˜æ´»æ—¶é—´
            }
        }
    }

    updateTrail(currentPos) {
        // æ·»åŠ æ–°ä½ç½®åˆ°å°¾è¿¹ï¼ˆå¸¦å›ºå®šçš„éšæœºåç§»ï¼Œåªåœ¨æ·»åŠ æ—¶è®¡ç®—ä¸€æ¬¡ï¼‰
        const trailPoint = currentPos.clone();
        trailPoint.x += (Math.random() - 0.5) * 6;
        trailPoint.y += (Math.random() - 0.5) * 3;
        trailPoint.z += (Math.random() - 0.5) * 6;
        this.trailPositions.unshift(trailPoint);

        // é™åˆ¶å°¾è¿¹é•¿åº¦
        if (this.trailPositions.length > 100) {
            this.trailPositions.pop();
        }

        // æ›´æ–°ç²’å­ä½ç½®ï¼ˆä¸å†æ¯å¸§éšæœºï¼Œä½¿ç”¨å·²å­˜å‚¨çš„ä½ç½®ï¼‰
        const positions = this.trail.geometry.attributes.position.array;
        for (let i = 0; i < 100; i++) {
            if (i < this.trailPositions.length) {
                const p = this.trailPositions[i];
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            } else {
                // æœªä½¿ç”¨çš„ç²’å­ç§»åˆ°å¾ˆè¿œ
                positions[i * 3] = 0;
                positions[i * 3 + 1] = -1000;
                positions[i * 3 + 2] = 0;
            }
        }
        this.trail.geometry.attributes.position.needsUpdate = true;

        // å°¾è¿¹é€æ˜åº¦éšæ—¶é—´è¡°å‡
        this.trail.material.opacity = this.active ? 0.8 : 0;
    }
}

class Snow {
    constructor(sc) {
        const count = 6000; // å¯ä»¥è½»æ¾æ”¯æŒæ›´å¤šç²’å­
        const pos = [];
        const velocities = []; // å­˜å‚¨ä¸‹è½é€Ÿåº¦å’Œåç§»
        
        for(let i=0; i<count; i++) {
            pos.push(
                (Math.random() * 2 - 1) * 400,
                Math.random() * 600,
                (Math.random() * 2 - 1) * 400
            );
            // x: ä¸‹è½é€Ÿåº¦, y: æ‘‡æ‘†é¢‘ç‡, z: æ‘‡æ‘†å¹…åº¦
            velocities.push(
                25 + Math.random() * 20, 
                0.5 + Math.random(), 
                5 + Math.random() * 10 
            );
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        // ç®€å•çš„é›ªèŠ±çº¹ç†
        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); cx.fillStyle='#fff'; cx.beginPath(); cx.arc(16,16,16,0,Math.PI*2); cx.fill();
        const tex = new THREE.CanvasTexture(cv);

        // è‡ªå®šä¹‰ Shader æè´¨
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTex: { value: tex },
                uHeight: { value: 600.0 } // è¾¹ç•Œé«˜åº¦
            },
            vertexShader: `
                uniform float uTime;
                uniform float uHeight;
                attribute vec3 velocity;
                varying float vAlpha;
                void main() {
                    vec3 pos = position;
                    // Yè½´ä¸‹è½è®¡ç®—ï¼š(åˆå§‹Y - é€Ÿåº¦*æ—¶é—´) å¯¹ é«˜åº¦å–æ¨¡
                    float fallOffset = velocity.x * uTime;
                    pos.y = mod(position.y - fallOffset, uHeight);
                    
                    // Xè½´æ‘‡æ‘†
                    pos.x += sin(uTime * velocity.y + position.y * 0.05) * velocity.z;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // è·ç¦»è¡°å‡ (å¯é€‰)
                    gl_PointSize = (300.0 / -mvPosition.z) * 0.8;
                    vAlpha = 0.8;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTex;
                varying float vAlpha;
                void main() {
                    vec4 color = texture2D(uTex, gl_PointCoord);
                    if (color.a < 0.5) discard;
                    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha * color.a);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.m = new THREE.Points(geo, mat);
        sc.add(this.m);
    }
    
    update(dt) {
        // CPU åªéœ€è¦æ›´æ–°ä¸€ä¸ªæ—¶é—´å˜é‡
        this.m.material.uniforms.uTime.value += dt;
    }
}

function setupControls() {
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 15; controls.maxDistance = 400;
    controls.addEventListener('start', () => STATE.interacting = true);
    controls.addEventListener('end', () => STATE.interacting = false);
}

function setupUI() {
    const btn = document.getElementById('start-btn');

    // æ‰¹é‡å‘å°„çƒŸèŠ±ï¼ˆæå‰å®šä¹‰ï¼Œä¾›ä¸‹æ–¹å›è°ƒä½¿ç”¨ï¼‰
    const launchBatch = () => {
        if(!STATE.started || document.visibilityState === 'hidden') return;
        const count = 2 + Math.floor(Math.random() * 4);
        for(let i=0; i<count; i++) {
            const delay = i * 300 + Math.random() * 200;
            setTimeout(() => fwMgr.launch(), delay);
        }
    };

    btn.onclick = () => {
        STATE.started = true;
        STATE.running = true;
        STATE.viewMode = 'INTRO'; // ğŸš« å…³é”®ä¿®å¤ï¼šæš‚æ—¶å±è”½ä¸»å¾ªç¯çš„ç›¸æœºæ§åˆ¶ï¼Œé˜²æ­¢æŠ–åŠ¨
        audio.init(); 
        audio.whistle(); 
        audio.playBGM(); 
        
        // è‡ªåŠ¨ç‡ƒæ”¾çš„å¯åŠ¨é€»è¾‘ï¼ˆå»¶è¿Ÿç­‰å¾…é™è½åŠ¨ç”»å®Œæˆï¼‰
        if (CFG.autoFw) {
            setTimeout(() => {
                if (!STATE.started) return; // é˜²æ­¢ç”¨æˆ·å¿«é€Ÿå…³é—­
                launchBatch(); 
                autoTimer = setInterval(launchBatch, CFG.fwRate * 1000);
            }, 2500); // å»¶è¿Ÿ2.5ç§’ï¼Œç­‰é™è½åŠ¨ç”»å®Œæˆ
        }

        document.getElementById('start-screen').style.opacity = 0;
        setTimeout(() => document.getElementById('start-screen').style.display = 'none', 800);
        document.getElementById('hud').style.opacity = 1;
        document.getElementById('settings-btn').style.opacity = 1;
        document.getElementById('firework-btn').style.opacity = 1;
        document.getElementById('countdown-wrap').style.opacity = 1;

        // é¦–æ¬¡å±•ç¤ºåœ£è¯å€’è®¡æ—¶
        if (window.showCountdownFirstTime) window.showCountdownFirstTime();

        // ğŸš å¯åŠ¨è¿é•œï¼šæ— äººæœºä»ä¾§é¢é«˜ç©ºé™è½
        // åˆå§‹åŒ–å½“å‰æ— äººæœºä¸ºç¬¬ä¸€ä¸ªï¼ˆæˆ–æ ¹æ®ç«è½¦ä½ç½®é€‰æ‹©æœ€è¿‘çš„ï¼‰
        droneState.current = Math.floor(train.prog * DRONE.count) % DRONE.count;

        // è®¡ç®—ç›®æ ‡è·Ÿæ‹ä½ç½®
        const endPos = new THREE.Vector3();
        const endTarget = new THREE.Vector3();
        getDronePosition(droneState.current, train.prog, endPos, endTarget);

        // èµ·å§‹ä½ç½®ï¼šç›®æ ‡ä½ç½®çš„æ­£ä¸Šæ–¹ + ä¾§å‘åç§»ï¼ˆæ¨¡æ‹Ÿæ— äººæœºä»ä¾§é¢é«˜ç©ºé£æ¥ï¼‰
        const startPos = endPos.clone();
        startPos.y += 120; // ä»é«˜ç©ºå¼€å§‹
        startPos.x += 60;  // ä¾§å‘åç§»
        startPos.z += 40;

        // èµ·å§‹çœ‹å‘ç‚¹ï¼šåœºæ™¯ä¸­å¿ƒï¼ˆä¿¯ç°å…¨æ™¯ï¼‰
        const startTarget = new THREE.Vector3(0, 0, 0);

        // è®¾ç½®åˆå§‹ç›¸æœºä½ç½®
        camera.position.copy(startPos);
        camera.lookAt(startTarget);
        controls.target.copy(startTarget);

        let t = 0;
        const iv = setInterval(() => {
            t += 0.012; // ç¨æ…¢ä¸€ç‚¹ï¼Œæ›´æœ‰ç”µå½±æ„Ÿ

            if (t >= 1) {
                clearInterval(iv);
                STATE.viewMode = 'FOLLOW'; // âœ… åŠ¨ç”»ç»“æŸï¼Œæ— ç¼åˆ‡æ¢å›æ™ºèƒ½è·Ÿæ‹æ¨¡å¼
                // ç¡®ä¿æœ€ç»ˆä½ç½®ç²¾ç¡®
                camera.position.copy(endPos);
                controls.target.copy(endTarget);
            } else {
                // ä½¿ç”¨ ease-out æ›²çº¿ï¼Œå¼€å§‹å¿«ç»“æŸæ…¢ï¼ˆåƒæ— äººæœºå‡é€Ÿé™è½ï¼‰
                const k = 1 - Math.pow(1 - t, 3);

                // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆç«è½¦åœ¨ç§»åŠ¨ï¼‰
                getDronePosition(droneState.current, train.prog, endPos, endTarget);

                // æ’å€¼ç›¸æœºä½ç½®
                camera.position.lerpVectors(startPos, endPos, k);

                // æ’å€¼çœ‹å‘ç‚¹ï¼ˆä»å…¨æ™¯è¿‡æ¸¡åˆ°è·Ÿè¸ªç«è½¦ï¼‰
                const lookTarget = new THREE.Vector3();
                lookTarget.lerpVectors(startTarget, endTarget, k);
                camera.lookAt(lookTarget);
                controls.target.copy(lookTarget);
            }
        }, 16);
    };

    const set = document.getElementById('settings-btn'), mod = document.getElementById('settings-modal'), over = document.getElementById('modal-overlay');
    const tog = () => { STATE.settings = !STATE.settings; const d = STATE.settings ? 'block' : 'none'; mod.style.display = d; over.style.display = d; };
    set.onclick = tog; over.onclick = tog;

    gui = new GUI({ container: mod, width: '100%' });
    gui.title('ğŸ„ æ§åˆ¶ä¸­å¿ƒ');

    const fSound = gui.addFolder('ğŸ”Š éŸ³é¢‘è®¾ç½®');
    fSound.add(audio.vol, 'master', 0, 1).name('æ€»éŸ³é‡').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'bgm', 0, 1).name('èƒŒæ™¯éŸ³ä¹').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'train', 0, 1).name('ç«è½¦éŸ³æ•ˆ').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'firework', 0, 1).name('çƒŸèŠ±éŸ³æ•ˆ').onChange(() => audio.updateVols());

    const fCam = gui.addFolder('ğŸ¥ é•œå¤´ä¸ç‰©ç†');
    fCam.add(DRONE, 'height', 10, 60).name('ğŸš æ— äººæœºé«˜åº¦');
    fCam.add(DRONE, 'distance', 30, 120).name('ğŸš è·Ÿæ‹è·ç¦»');
    fCam.add(DRONE, 'coverage', 0.08, 0.3).name('ğŸš æ¥åŠ›é—´éš”');
    fCam.add(DRONE, 'switchDur', 0.5, 3).name('ğŸš åˆ‡æ¢æ—¶é•¿');
    fCam.add(CFG, 'camSmooth', 0.01, 0.1).name('è·ŸéšæŸ”å’Œåº¦');
    fCam.add(CFG, 'maxSpeed', 0.02, 0.4).name('ç«è½¦æé€Ÿ');

    const fEnv = gui.addFolder('ğŸ’¡ ç¯å…‰ä¸ç¯å¢ƒ');
    fEnv.add(CFG, 'moonInt', 0, 5).name('æœˆå…‰äº®åº¦').onChange(v => lights.moon.intensity = v);
    fEnv.add(CFG, 'fogDen', 0, 0.005).name('å¤§é›¾æµ“åº¦').onChange(v => scene.fog.density = v);
    fEnv.add(CFG, 'bloomStr', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
    fEnv.add(CFG, 'bloomThr', 0, 1).name('è¾‰å…‰é˜ˆå€¼').onChange(v => bloomPass.threshold = v);
    fEnv.add(CFG, 'lightPow', 0, 200).name('è½¦ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'headlight_spot') o.intensity = v }));
    fEnv.add(CFG, 'bulbBri', 0, 50).name('å½©ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'bulb') o.material.emissiveIntensity = v }));

    const fFw = gui.addFolder('ğŸ† çƒŸèŠ±æ§åˆ¶');
    // è°ƒè¯•å¯¹è±¡ï¼šé»˜è®¤-1 è¡¨ç¤ºéšæœº
    const debugObj = { soundStyle: -1 };

    // è‡ªåŠ¨ç”ŸæˆéŸ³æ•ˆé£æ ¼é€‰é¡¹ï¼ˆå«â€œéšæœºâ€ï¼‰
    const styleOptions = { 'éšæœº (Random)': -1 };
    SOUND_STYLES.forEach((style, i) => {
        const label = `${i}. ${style.name} (${style.name})`;
        styleOptions[label] = i;
    });

    // æ·»åŠ  GUI æ§ä»¶
    fFw.add(debugObj, 'soundStyle', styleOptions)
       .name('ğŸ’¥ çˆ†ç‚¸éŸ³æ•ˆé£æ ¼'); // ä½¿ç”¨ .name() æ¥æ˜¾ç¤ºä¸­æ–‡æ ‡ç­¾

    window.getFireworkSoundStyle = () => debugObj.soundStyle;

    fFw.add(CFG, 'autoFw').name('è‡ªåŠ¨ç‡ƒæ”¾').onChange(v => {
        if (autoTimer) clearInterval(autoTimer);
        if (v) { 
            launchBatch(); 
            autoTimer = setInterval(launchBatch, CFG.fwRate * 1000); 
        }
    });
    fFw.add(CFG, 'fwRate', 3, 12).name('æ³¢æ¬¡é—´éš”(ç§’)').onChange(v => {
        if (CFG.autoFw) {
            clearInterval(autoTimer);
            autoTimer = setInterval(launchBatch, v * 1000);
        }
    });

    // ===== ğŸ† çƒŸèŠ±æŒ‰é’® =====
    const fwBtn = document.getElementById('firework-btn');
    fwBtn.onclick = () => {
        if (!STATE.started) return;
        // ç‚¹å‡»ç‰¹æ•ˆ
        fwBtn.classList.add('burst');
        setTimeout(() => fwBtn.classList.remove('burst'), 400);
        // å‘å°„çƒŸèŠ±
        launchBatch();
    };

    // ===== ğŸš‚ å¯åœæŒ‰é’® =====
    const trainToggle = document.getElementById('train-toggle');
    const hudStatus = document.getElementById('hud-status');
    const dot = document.getElementById('d-status');

    const updateTrainUI = () => {
        trainToggle.textContent = STATE.running ? 'â¸ï¸' : 'â–¶ï¸';
        dot.classList.toggle('stop', !STATE.running);
    };

    trainToggle.onclick = () => {
        if (!STATE.started) return;
        STATE.running = !STATE.running;
        if (STATE.running) {
            audio.whistle();
        }
        updateTrainUI();
    };

    // ===== ğŸš æ¨¡å¼åˆ‡æ¢ï¼ˆç‚¹å‡»HUDçŠ¶æ€æ–‡å­—ï¼‰ =====
    hudStatus.onclick = () => {
        if (!STATE.started) return;

        if (STATE.viewMode === 'FOLLOW') {
            // åˆ‡æ¢åˆ°è‡ªç”±æ¢ç´¢
            STATE.viewMode = 'FREE';
            hudStatus.textContent = 'è‡ªç”±æ¢ç´¢æ¨¡å¼';
            dot.style.background = '#4fc3f7';
            dot.style.boxShadow = '0 0 8px #4fc3f7';
        } else {
            // åˆ‡æ¢å›æ™ºèƒ½é©¾é©¶ï¼šå¹³æ»‘è¿‡æ¸¡åˆ°æ­£ç¡®çš„æ— äººæœºä½ç½®
            STATE.viewMode = 'FOLLOW';
            hudStatus.textContent = 'æ™ºèƒ½é©¾é©¶æ¨¡å¼';
            dot.style.background = STATE.running ? '#00ff00' : '#ff3300';
            dot.style.boxShadow = STATE.running ? '0 0 8px #00ff00' : '0 0 8px #ff3300';

            // è®¡ç®—æœ€è¿‘çš„æ— äººæœº
            droneState.current = Math.floor(train.prog * DRONE.count) % DRONE.count;

            // å¯åŠ¨å¹³æ»‘è¿‡æ¸¡
            droneState.fromPos.copy(camera.position);
            droneState.fromTarget.copy(controls.target);
            getDronePosition(droneState.current, train.prog, droneState.toPos, droneState.toTarget);
            droneState.switching = true;
            droneState.switchT = 0;
        }
    };

    // ===== ğŸ–±ï¸ åœºæ™¯ç‚¹å‡»äº¤äº’ =====
    const cvs = document.getElementById('canvas-container');
    cvs.addEventListener('pointerdown', () => STATE.clickTime = Date.now());
    cvs.addEventListener('pointerup', (e) => {
        if (Date.now() - STATE.clickTime < 200 && STATE.started && !STATE.settings) {
            mouse.x = (e.clientX / innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, camera);

            const hitTrain = ray.intersectObjects(train.grp.children, true);
            if (hitTrain.length > 0) {
                const hitObj = hitTrain[0].object;

                // åˆ¤æ–­æ˜¯å¦ç‚¹å‡»çš„æ˜¯ç«è½¦å¤´
                let isLoco = false;
                hitObj.traverseAncestors(p => { if (p === train.loco) isLoco = true; });

                if (isLoco) {
                    // ğŸµ ç‚¹å‡»ç«è½¦å¤´ â†’ BGM å¼€/å…³
                    if (audio.isBgmPlaying) {
                        audio.stopBGM();
                    } else {
                        audio.playBGM();
                    }
                } else {
                    // ğŸ”” ç‚¹å‡»è½¦å¢ â†’ çª—æˆ·é—ªçƒ + æ‰”ç¤¼ç›’ + é“ƒé“›å“
                    // æ‰¾åˆ°è¢«ç‚¹å‡»çš„è½¦å¢
                    let clickedCar = null;
                    hitObj.traverseAncestors(p => {
                        if (train.cars.includes(p)) clickedCar = p;
                    });

                    if (clickedCar) {
                        // å°è¯•æ‰”ç¤¼ç›’ï¼ˆæœ‰å†·å´é™åˆ¶ï¼‰
                        if (train.throwGift(clickedCar)) {
                            train.flashWindows(clickedCar);
                            audio.bell();
                        }
                    } else {
                        audio.bell();
                    }
                }
                return;
            }
            // ç‚¹å‡»ç©ºåœ°ï¼šæ— ååº”ï¼ˆå·²ç§»é™¤æ‰‹åŠ¨çƒŸèŠ±ï¼‰
        }
    });

    // ===== ğŸ„ åœ£è¯å€’è®¡æ—¶ =====
    const countdownTrigger = document.getElementById('countdown-trigger');
    const countdownPanel = document.getElementById('countdown-panel');
    const countdownDays = document.getElementById('countdown-days');
    const countdownDetail = document.getElementById('countdown-detail');
    let countdownExpanded = false;
    let countdownFirstShow = false;

    // è®¡ç®—åˆ°åœ£è¯èŠ‚çš„æ—¶é—´
    const getChristmasCountdown = () => {
        const now = new Date();
        const year = now.getFullYear();
        // ä»Šå¹´çš„åœ£è¯èŠ‚
        let christmas = new Date(year, 11, 25, 0, 0, 0);
        // å¦‚æœåœ£è¯èŠ‚å·²è¿‡ï¼Œè®¡ç®—åˆ°æ˜å¹´
        if (now > christmas) {
            christmas = new Date(year + 1, 11, 25, 0, 0, 0);
        }
        const diff = christmas - now;
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);
        return { days, hours, minutes, seconds, isToday: days === 0 && hours === 0 && minutes === 0 };
    };

    // æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
    const updateCountdown = () => {
        const { days, hours, minutes, seconds, isToday } = getChristmasCountdown();
        countdownDays.textContent = days;

        if (isToday) {
            countdownDetail.innerHTML = 'ğŸ‰ <span>åœ£è¯å¿«ä¹!</span> ğŸ‰';
            document.querySelector('#countdown-panel .title').textContent = 'âœ¨ Merry Christmas! âœ¨';
        } else {
            const pad = n => n.toString().padStart(2, '0');
            countdownDetail.innerHTML = `${days}<span>å¤©</span> ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }
    };

    // åˆ‡æ¢å±•å¼€/æ”¶èµ·
    const toggleCountdown = (forceState) => {
        countdownExpanded = forceState !== undefined ? forceState : !countdownExpanded;
        countdownTrigger.classList.toggle('expanded', countdownExpanded);
        countdownPanel.classList.toggle('show', countdownExpanded);
    };

    // ç‚¹å‡»è§¦å‘å™¨
    countdownTrigger.onclick = (e) => {
        e.stopPropagation();
        toggleCountdown();
    };

    // ç‚¹å‡»é¢æ¿å¤–éƒ¨æ”¶èµ·
    document.addEventListener('click', (e) => {
        if (countdownExpanded && !countdownPanel.contains(e.target) && !countdownTrigger.contains(e.target)) {
            toggleCountdown(false);
        }
    });

    // ç‚¹å‡»é¢æ¿å†…éƒ¨ä¹Ÿæ”¶èµ·
    countdownPanel.onclick = () => toggleCountdown(false);

    // åˆå§‹åŒ–å¹¶å¯åŠ¨å®šæ—¶å™¨
    updateCountdown();
    setInterval(updateCountdown, 1000);

    // é¦–æ¬¡å±•ç¤ºï¼ˆæ¸¸æˆå¼€å§‹å3ç§’å±•å¼€ï¼Œå†3ç§’åè‡ªåŠ¨æ”¶èµ·ï¼‰
    window.showCountdownFirstTime = () => {
        if (countdownFirstShow) return;
        countdownFirstShow = true;
        setTimeout(() => {
            toggleCountdown(true);
            setTimeout(() => toggleCountdown(false), 3000);
        }, 2000);
    };
}

window.onresize = () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
};

init();
</script>
    </body>
</html>
