<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas - Holiday Tour</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020305; font-family: 'Microsoft YaHei', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.9); 
            pointer-events: none; z-index: 10; font-size: 14px;
            background: linear-gradient(90deg, rgba(0,0,0,0.85) 0%, transparent 100%);
            padding: 20px; border-radius: 8px; border-left: 4px solid #00ff00;
        }
        h1 { margin: 0 0 8px 0; font-size: 24px; color: #ffcc00; text-shadow: 0 2px 8px rgba(0,0,0,0.8); }
        p { margin: 6px 0; font-size: 14px; color: #eee; }
        .highlight { color: #81d4fa; font-weight: bold; }
        .key-tip { color: #ffeb3b; font-weight: bold; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 8px;
            font-size: 16px; border: 1px solid #444;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>ğŸš‚ åœ£è¯å·¡æ¸¸ï¼šæ£®æ—å¥‡å¢ƒ</h1>
        <p>1. äº¤äº’: <span class="key-tip">åŒå‡»ç«è½¦</span> åˆ‡æ¢è§†è§’æ¨¡å¼</p>
        <p>2. å½“å‰æ¨¡å¼: <span id="mode-text" class="highlight">è‡ªç”±ä¸Šå¸è§†è§’</span></p>
        <p>3. åœºæ™¯: <span class="highlight">æ™ºèƒ½é¿éšœå¸ƒå±€ / å¤šåŒºåŸŸå·¡é€»</span></p>
        <p>4. æç¤º: <span class="highlight">è·Ÿéšæ¨¡å¼ä¸‹ä»å¯æ—‹è½¬è§†è§’</span></p>
    </div>
    
    <div id="loading">æ­£åœ¨è§„åˆ’å·¡æ¸¸è·¯çº¿...<br><span style="font-size:12px;color:#aaa">ç”Ÿæˆé˜²ç¢°æ’åœ°å›¾</span></div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- å…¨å±€å‚æ•° ---
        const PARAMS = {
            viewMode: 'è‡ªç”±è§†è§’', // å†…éƒ¨çŠ¶æ€
            moonIntensity: 2.0,
            ambientIntensity: 0.25,
            bulbBrightness: 12.0,
            starBrightness: 20.0,
            trainLightPower: 40.0,
            bloomThreshold: 1.1,
            bloomStrength: 0.9,
            trainSpeed: 0.12,
        };

        let scene, camera, renderer, composer, controls, gui;
        let raycaster, mouse;
        let train, fireworkMgr, snowSystem;
        let lights = {}; 
        let bloomPass;
        let emissiveObjects = [];
        let trackCurve; 
        let trackPointsSample = []; // ç”¨äºç¢°æ’æ£€æµ‹çš„é‡‡æ ·ç‚¹
        const clock = new THREE.Clock();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            scene.fog = new THREE.FogExp2(0x020408, 0.0025);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 80, 160); // åˆå§‹ä¿¯è§†

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupLights();
            
            // 1. ç”Ÿæˆå¤æ‚è·¯å¾„
            generateComplexTrack();
            
            // 2. æ¸²æŸ“è½¨é“æ¨¡å‹
            createTrackMesh();

            // 3. æ™ºèƒ½ç”Ÿæˆç¯å¢ƒ (é¿è®©è½¨é“)
            generateEnvironment();

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = PARAMS.bloomThreshold;
            bloomPass.strength = PARAMS.bloomStrength;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç³»ç»Ÿåˆå§‹åŒ–
            train = new TrainSystem(scene, trackCurve);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupInteraction();
            setupGUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupLights() {
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-100, 150, -50);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(2048, 2048);
            lights.moon.shadow.camera.left = -200; lights.moon.shadow.camera.right = 200;
            lights.moon.shadow.camera.top = 200; lights.moon.shadow.camera.bottom = -200;
            scene.add(lights.moon);

            lights.ambient = new THREE.AmbientLight(0x404060, PARAMS.ambientIntensity);
            scene.add(lights.ambient);

            // åœ°é¢
            const ground = new THREE.Mesh(
                new THREE.CircleGeometry(600, 128),
                new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 1.0, metalness: 0.0 })
            );
            ground.rotation.x = -Math.PI / 2; 
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // ============================
        // ğŸ›£ï¸ è½¨é“è§„åˆ’ (æ ¸å¿ƒé€»è¾‘)
        // ============================
        function generateComplexTrack() {
            // è®¾è®¡ä¸€ä¸ªä¸‰å¶è‰/8å­—å½¢æ··åˆè·¯å¾„ï¼Œç»•è¿‡ä¸‰ä¸ªä¸­å¿ƒç‚¹
            // ä¸­å¿ƒç‚¹å‡è®¾ä¸º: A(50, 0, 0), B(-40, 0, 40), C(-40, 0, -40)
            const points = [
                // ç¯ç»•åŒºåŸŸ A (ä¸œä¾§)
                new THREE.Vector3(10, 0, 20),
                new THREE.Vector3(50, 2, 50),
                new THREE.Vector3(90, 0, 0),
                new THREE.Vector3(50, 0, -50),
                new THREE.Vector3(10, 0, -20),
                
                // ç©¿è¿‡ä¸­å¿ƒï¼Œå»å¾€åŒºåŸŸ C (è¥¿å—)
                new THREE.Vector3(-20, 0, -20),
                new THREE.Vector3(-50, 3, -70), // ä¸Šå¡
                new THREE.Vector3(-90, 0, -50),
                new THREE.Vector3(-60, 0, -10),
                
                // å»å¾€åŒºåŸŸ B (è¥¿åŒ—)
                new THREE.Vector3(-60, 0, 10),
                new THREE.Vector3(-90, 0, 50),
                new THREE.Vector3(-50, 3, 70), // ä¸Šå¡
                new THREE.Vector3(-20, 0, 20),
                
                // å›åˆ°èµ·ç‚¹é™„è¿‘é—­åˆ
                new THREE.Vector3(0, 0, 0)
            ];
            trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            
            // **å…³é”®æ­¥éª¤**ï¼šé‡‡æ ·è½¨é“ç‚¹ç”¨äºåç»­çš„ç¢°æ’æ£€æµ‹
            trackPointsSample = trackCurve.getPoints(300); // é‡‡æ ·300ä¸ªç‚¹å»ºç«‹ç¦åŒº
        }

        function createTrackMesh() {
            const divisions = 400;
            // 1. è·¯åŸº (é»‘è‰²é˜²ç©¿å¸®)
            const bedGeo = new THREE.TubeGeometry(trackCurve, divisions, 3, 8, true);
            const bedMat = new THREE.MeshStandardMaterial({color: 0x050505, roughness: 1});
            const bed = new THREE.Mesh(bedGeo, bedMat);
            bed.position.y = -0.2; // ç•¥å¾®ä¸‹æ²‰
            bed.scale.y = 0.1; // å‹æ‰
            scene.add(bed);

            // 2. æ•æœ¨ (Instance)
            const plankGeo = new THREE.BoxGeometry(5, 0.4, 1.2);
            const plankMat = new THREE.MeshStandardMaterial({color: 0x4e342e});
            const planks = new THREE.InstancedMesh(plankGeo, plankMat, divisions);
            const dummy = new THREE.Object3D();
            
            for(let i=0; i<divisions; i++) {
                const t = i/divisions;
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t);
                dummy.position.copy(pos);
                dummy.lookAt(pos.clone().add(tangent));
                dummy.updateMatrix();
                planks.setMatrixAt(i, dummy.matrix);
            }
            planks.receiveShadow = true;
            scene.add(planks);

            // 3. é“è½¨ (ä¸¤æ¡çº¿)
            // ç®€åŒ–å¤„ç†ï¼šç”¨ä¸€æ¡æ·±è‰² Tube ä»£è¡¨åŒè½¨çš„è§†è§‰ä¸»ä½“
            const railGeo = new THREE.TubeGeometry(trackCurve, divisions, 0.2, 8, true);
            const railMat = new THREE.MeshStandardMaterial({color:0x222222, metalness:0.7, roughness:0.2});
            
            // å·¦è½¨
            const railL = new THREE.Mesh(railGeo, railMat);
            // ç®€å•çš„åç§»å¾ˆéš¾åšï¼Œè¿™é‡Œé€šè¿‡å…‹éš†å¹¶å¾®è°ƒä½ç½®æ¥æ¨¡æ‹Ÿè§†è§‰ä¸Šçš„åŒè½¨(ä»…åœ¨å¹³åœ°æœ‰æ•ˆï¼Œå¡åœ°ä¼šæœ‰åå·®)
            // ä¸ºäº†æ›´å¥½çš„æ•ˆæœï¼Œæˆ‘ä»¬ç›´æ¥åªæ¸²æŸ“ä¸­é—´çš„é»‘è‰²è·¯åŸºå’Œæ•æœ¨ï¼Œè¿™åœ¨ä¿¯è§†ä¸‹å·²ç»å¾ˆåƒé“è½¨äº†
            scene.add(railL); 
        }

        // ============================
        // ğŸŒ² æ™ºèƒ½åœºæ™¯ç”Ÿæˆ (Collision Check)
        // ============================
        
        // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è½¨é“é™„è¿‘ (å®‰å…¨è·ç¦» check)
        function isSafePosition(x, z, safeRadius = 8) {
            const p = new THREE.Vector3(x, 0, z);
            for(let i=0; i<trackPointsSample.length; i++) {
                // åªæ¯”è¾ƒ x, z å¹³é¢è·ç¦»
                const tp = trackPointsSample[i];
                const dx = tp.x - x;
                const dz = tp.z - z;
                if ((dx*dx + dz*dz) < safeRadius * safeRadius) {
                    return false; // å¤ªè¿‘äº†ï¼Œå†²çª
                }
            }
            return true;
        }

        function generateEnvironment() {
            // 1. ä¸‰ä¸ªæ ¸å¿ƒåœ°æ ‡ (æ”¾ç½®åœ¨ç¯è·¯ä¸­å¿ƒï¼Œæ¯”è¾ƒå®‰å…¨)
            // åŒºåŸŸ A (50, 0)
            createHeroTree(50, 0, 1.5, 0xff0000); 
            // åŒºåŸŸ B (-60, 40)
            createHeroTree(-60, 40, 1.3, 0x00ff00);
            // åŒºåŸŸ C (-60, -40)
            createHeroTree(-60, -40, 1.4, 0xffcc00);

            // 2. æ£®æ—ç”Ÿæˆ (æ™®é€šæ ‘æœ¨ï¼Œå¤§é‡)
            // é™åˆ¶ï¼šä¸åœ¨åœ°æ ‡é™„è¿‘ï¼Œä¸åœ¨è½¨é“é™„è¿‘
            const forestCount = 120;
            let planted = 0;
            let attempts = 0;
            
            while(planted < forestCount && attempts < 2000) {
                attempts++;
                const r = 30 + Math.random() * 120; // èŒƒå›´
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // é¿è®©è½¨é“ (åŠå¾„6)
                if(isSafePosition(x, z, 6)) {
                    // é¿è®©ä¸‰ä¸ªåœ°æ ‡ä¸­å¿ƒ (åŠå¾„15)
                    if(new THREE.Vector3(x,0,z).distanceTo(new THREE.Vector3(50,0,0)) > 15 &&
                       new THREE.Vector3(x,0,z).distanceTo(new THREE.Vector3(-60,0,40)) > 15 &&
                       new THREE.Vector3(x,0,z).distanceTo(new THREE.Vector3(-60,0,-40)) > 15) 
                    {
                        createNatureTree(x, z);
                        planted++;
                    }
                }
            }

            // 3. è£…é¥°å“ (ç¤¼ç‰©ã€é›ªäººã€è·¯ç¯)
            for(let i=0; i<30; i++) {
                const x = (Math.random()-0.5)*200;
                const z = (Math.random()-0.5)*200;
                if(isSafePosition(x, z, 5)) {
                    const type = Math.random();
                    if(type < 0.4) createGift(x, z);
                    else if(type < 0.7) createSnowman(x, z);
                    else createSimpleLamp(x, z);
                }
            }
        }

        // --- ç‰©ä»¶ç”Ÿæˆå‡½æ•° ---

        function createHeroTree(x, z, scale, colorTheme) {
            // ä¸»åœ£è¯æ ‘ï¼šå·¨å¤§ã€å½©ç¯å¤šã€æœ‰æ˜Ÿæ˜Ÿ
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            g.scale.set(scale, scale, scale);

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2.5, 6, 8), new THREE.MeshStandardMaterial({color:0x3e2723}));
            trunk.position.y = 3; g.add(trunk);

            const leafMat = new THREE.MeshStandardMaterial({color: 0x0f4d0f, roughness: 0.8});
            for(let i=0; i<5; i++) {
                const y = 5 + i*4;
                const r = 12 - i*2;
                const cone = new THREE.Mesh(new THREE.ConeGeometry(r, 7, 16), leafMat);
                cone.position.y = y; cone.castShadow = true; g.add(cone);
                
                // æŒ‚ç¯
                const count = 6+i;
                for(let k=0; k<count; k++) {
                    const a = (k/count)*Math.PI*2 + i;
                    const br = r - 0.4;
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({
                        color:0, emissive: Math.random()>0.5?colorTheme:0xffffff, emissiveIntensity: PARAMS.bulbBrightness
                    }));
                    bulb.position.set(Math.cos(a)*br, y-3, Math.sin(a)*br);
                    bulb.userData = {type:'bulb'}; emissiveObjects.push(bulb);
                    g.add(bulb);
                }
            }
            // æ˜Ÿæ˜Ÿ
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(2), new THREE.MeshStandardMaterial({
                color:0xffff00, emissive:0xffaa00, emissiveIntensity: PARAMS.starBrightness
            }));
            star.position.y = 26; star.userData={type:'star'}; emissiveObjects.push(star);
            g.add(star);
            
            // æ ‘ä¸‹çš„åœ°é¢å…‰
            const pl = new THREE.PointLight(colorTheme, 2, 40);
            pl.position.y = 5;
            g.add(pl);

            scene.add(g);
        }

        function createNatureTree(x, z) {
            // èƒŒæ™¯æ ‘ï¼šç®€å•ã€æ— ç¯ã€æœ‰é›ª
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            const s = 0.6 + Math.random()*0.8;
            g.scale.set(s,s,s);
            
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1, 4), new THREE.MeshStandardMaterial({color:0x3e2723}));
            trunk.position.y = 2; g.add(trunk);
            
            const mat = new THREE.MeshStandardMaterial({color: 0x1b3e20}); // æ·±ç»¿
            const snow = new THREE.MeshStandardMaterial({color: 0xffffff});
            
            for(let i=0; i<3; i++) {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(5-i, 6, 8), mat);
                cone.position.y = 5 + i*3.5; cone.castShadow=true; g.add(cone);
                // æ ‘é¡¶é›ªç›–
                const cap = new THREE.Mesh(new THREE.ConeGeometry(4.5-i, 2, 8), snow);
                cap.position.y = 4 + i*3.5; cap.rotation.x = (Math.random()-0.5)*0.2;
                g.add(cap);
            }
            scene.add(g);
        }

        function createGift(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z); g.rotation.y = Math.random();
            const sz = 1.5;
            const box = new THREE.Mesh(new THREE.BoxGeometry(sz,sz,sz), new THREE.MeshStandardMaterial({color: Math.random()*0xffffff}));
            box.position.y = sz/2; box.castShadow = true; g.add(box);
            scene.add(g);
        }

        function createSnowman(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z); g.rotation.y = Math.random()*6;
            const mat = new THREE.MeshStandardMaterial({color:0xffffff});
            const b1 = new THREE.Mesh(new THREE.SphereGeometry(1.5), mat); b1.position.y=1.2;
            const b2 = new THREE.Mesh(new THREE.SphereGeometry(1.0), mat); b2.position.y=3.2;
            g.add(b1); g.add(b2);
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2,1,8), new THREE.MeshStandardMaterial({color:0xff6600}));
            nose.rotation.x=1.57; nose.position.set(0,3.2,1); g.add(nose);
            scene.add(g);
        }

        function createSimpleLamp(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,8), new THREE.MeshStandardMaterial({color:0x222}));
            p.position.y=4; g.add(p);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({
                color:0xffaa00, emissive:0xffaa00, emissiveIntensity:10
            }));
            b.position.y=8; b.userData={type:'lamp'}; emissiveObjects.push(b);
            g.add(b);
            scene.add(g);
        }

        // ============================
        // ğŸš‚ ç«è½¦ç³»ç»Ÿ
        // ============================
        class TrainSystem {
            constructor(scene, curve) {
                this.scene = scene;
                this.curve = curve;
                this.group = new THREE.Group();
                this.smokes = [];
                this.progress = 0;
                
                this.loco = this.createLoco();
                this.group.add(this.loco);
                
                this.cars = [];
                for(let i=1; i<=4; i++) {
                    const car = this.createCar(i);
                    // é—´è·è®¡ç®—ï¼šå› ä¸ºè½¨é“é•¿åº¦ä¸ä¸€ï¼Œè¿™é‡Œç”¨è¿‘ä¼¼å€¼
                    car.userData.gap = i * 0.015; 
                    this.group.add(car);
                    this.cars.push(car);
                }
                scene.add(this.group);
            }

            createLoco() {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.3});
                const body = new THREE.Mesh(new THREE.BoxGeometry(3.5, 4.5, 7), mat);
                body.position.set(0, 3.5, 0); g.add(body);
                this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1.8), new THREE.MeshStandardMaterial({color:0x111}));
                this.chimney.position.set(0, 4.5, 2.5); g.add(this.chimney);
                
                const lamp = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.3), new THREE.MeshStandardMaterial({
                    color:0, emissive:0xffdd88, emissiveIntensity: PARAMS.trainLightPower
                }));
                lamp.rotation.x=-1.57; lamp.position.set(0, 3, 3.6);
                lamp.userData={type:'headlight'}; emissiveObjects.push(lamp);
                g.add(lamp);

                const spot = new THREE.SpotLight(0xffdd88, 30, 80, 0.6, 0.5);
                spot.position.set(0, 3.5, 4); spot.target.position.set(0, 0, 30);
                g.add(spot); g.add(spot.target);

                // ç¢°æ’æ£€æµ‹ç”¨
                const hit = new THREE.Mesh(new THREE.BoxGeometry(6,8,10), new THREE.MeshBasicMaterial({visible:false}));
                hit.userData = { isTrain: true };
                g.add(hit);

                return g;
            }

            createCar(i) {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color: i%2===0?0x1565c0:0x2e7d32});
                const b = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3.5, 5), mat);
                b.position.y=3; g.add(b);
                const gift = new THREE.Mesh(new THREE.BoxGeometry(2,1.5,2), new THREE.MeshStandardMaterial({color:0xffd54f}));
                gift.position.y=5.5; g.add(gift);
                return g;
            }

            update(delta) {
                const speed = PARAMS.trainSpeed * delta * 0.2;
                this.progress = (this.progress + speed) % 1;
                
                this.place(this.loco, this.progress);
                this.cars.forEach(c => {
                    let p = this.progress - c.userData.gap;
                    if(p < 0) p += 1;
                    this.place(c, p);
                });

                if(Math.random()>0.9) {
                    const p = new THREE.Vector3(); this.chimney.getWorldPosition(p); p.y+=0.5;
                    this.spawnSmoke(p);
                }
                this.updateSmoke();
            }

            place(obj, t) {
                const pos = this.curve.getPointAt(t);
                const tangent = this.curve.getTangentAt(t);
                obj.position.copy(pos);
                obj.lookAt(pos.clone().add(tangent));
            }

            spawnSmoke(pos) {
                const m = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5+Math.random()), new THREE.MeshStandardMaterial({
                    color:0xcccccc, transparent:true, opacity:0.5
                }));
                m.position.copy(pos);
                this.scene.add(m); this.smokes.push({m, life:1.5});
            }

            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i];
                    s.life-=0.02; s.m.position.y+=0.06; s.m.scale.multiplyScalar(1.02);
                    s.m.material.opacity = s.life*0.4;
                    if(s.life<=0) { this.scene.remove(s.m); this.smokes.splice(i,1); }
                }
            }
        }

        // ============================
        // äº¤äº’ä¸æ§åˆ¶
        // ============================
        function setupInteraction() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI/2 - 0.05; // é˜²æ­¢ç©¿åœ°
            controls.minDistance = 10;
            controls.maxDistance = 400;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize);
            
            // ç‚¹å‡»æ”¾çƒŸèŠ±
            window.addEventListener('pointerdown', (e) => {
                mouse.x = (e.clientX/window.innerWidth)*2-1; 
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
                const t = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, t);
                if(t) fireworkMgr.launch(t);
            });

            // åŒå‡»åˆ‡æ¢è§†è§’
            window.addEventListener('dblclick', (e) => {
                mouse.x = (e.clientX/window.innerWidth)*2-1; 
                mouse.y = -(e.clientY/window.innerHeight)*2+1;
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(train.group.children, true);
                let hitTrain = false;
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç«è½¦
                for(let h of hits) {
                    let o = h.object;
                    while(o) {
                        if(o.userData.isTrain || o.parent === train.group) {
                            hitTrain = true; break;
                        }
                        o = o.parent;
                    }
                }
                
                if(hitTrain) {
                    toggleViewMode();
                }
            });
        }

        function toggleViewMode() {
            if(PARAMS.viewMode === 'è‡ªç”±è§†è§’') {
                PARAMS.viewMode = 'è·Ÿéšç«è½¦';
            } else {
                PARAMS.viewMode = 'è‡ªç”±è§†è§’';
                // é‡ç½® targetï¼Œé˜²æ­¢åˆ‡å›æ¥åç›¸æœºä¹±è½¬
                controls.target.set(0,0,0);
            }
            // æ›´æ–° GUI
            updateGUI();
            document.getElementById('mode-text').innerText = PARAMS.viewMode;
        }

        function setupGUI() {
            gui = new GUI({ title: 'æ§åˆ¶é¢æ¿' });
            
            const fView = gui.addFolder('ğŸ¥ è§†è§’ (æ”¯æŒåŒå‡»ç«è½¦åˆ‡æ¢)');
            fView.add(PARAMS, 'viewMode', ['è‡ªç”±è§†è§’', 'è·Ÿéšç«è½¦']).name('æ¨¡å¼').listen().onChange(v => {
                document.getElementById('mode-text').innerText = v;
                if(v === 'è‡ªç”±è§†è§’') controls.target.set(0,0,0);
            });

            const fEnv = gui.addFolder('ğŸ’¡ ç¯å…‰ä¸ç¯å¢ƒ');
            fEnv.add(PARAMS, 'moonIntensity', 0, 5).onChange(v=>lights.moon.intensity=v);
            fEnv.add(PARAMS, 'bulbBrightness', 1, 30).onChange(updateEmissives);
            fEnv.add(PARAMS, 'trainLightPower', 1, 60).onChange(updateEmissives);
            
            const fPhys = gui.addFolder('âš™ï¸ è¿è¡Œ');
            fPhys.add(PARAMS, 'trainSpeed', 0, 0.4).name('é€Ÿåº¦');
        }

        function updateEmissives() {
            emissiveObjects.forEach(o => {
                if(o.userData.type==='bulb') o.material.emissiveIntensity = PARAMS.bulbBrightness;
                if(o.userData.type==='star') o.material.emissiveIntensity = PARAMS.starBrightness;
                if(o.userData.type==='headlight') o.material.emissiveIntensity = PARAMS.trainLightPower;
                if(o.userData.type==='lamp') o.material.emissiveIntensity = PARAMS.lampBrightness;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        class FireworkManager {
            constructor(scene) {
                this.scene = scene; this.list = [];
                const c=document.createElement('canvas'); c.width=32;c.height=32;
                const ctx=c.getContext('2d');
                const g=ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                this.tex=new THREE.CanvasTexture(c);
            }
            launch(target) {
                const c = new THREE.Color().setHSL(Math.random(),1,0.6);
                this.list.push({
                    phase:'up', pos: target.clone().add(new THREE.Vector3((Math.random()-0.5)*5,0,(Math.random()-0.5)*5)),
                    vel: new THREE.Vector3(0, 1+Math.random(), 0), destY: 30+Math.random()*20, color:c,
                    trail: new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:c})),
                    parts: null
                });
                this.scene.add(this.list[this.list.length-1].trail);
            }
            update() {
                for(let i=this.list.length-1; i>=0; i--) {
                    const fw = this.list[i];
                    if(fw.phase==='up') {
                        fw.pos.add(fw.vel); fw.vel.y*=0.98; fw.trail.position.copy(fw.pos);
                        if(fw.vel.y<0.1||fw.pos.y>fw.destY) { this.scene.remove(fw.trail); fw.phase='pop'; this.explode(fw); }
                    } else {
                        const p = fw.parts.geometry.attributes.position.array; fw.life-=0.015;
                        for(let k=0; k<p.length/3; k++) {
                            p[k*3]+=fw.vels[k*3]; p[k*3+1]+=fw.vels[k*3+1]; p[k*3+2]+=fw.vels[k*3+2];
                            fw.vels[k*3+1]-=0.005;
                        }
                        fw.parts.geometry.attributes.position.needsUpdate=true; fw.parts.material.opacity=fw.life;
                        if(fw.life<=0) { this.scene.remove(fw.parts); this.list.splice(i,1); }
                    }
                }
            }
            explode(fw) {
                const cnt=200; const pos=[], vels=[];
                for(let i=0; i<cnt; i++) {
                    pos.push(fw.pos.x, fw.pos.y, fw.pos.z);
                    const s = 0.2+Math.random()*0.3; const th=Math.random()*6.28; const ph=Math.acos(2*Math.random()-1);
                    vels.push(Math.sin(ph)*Math.cos(th)*s, Math.sin(ph)*Math.sin(th)*s, Math.cos(ph)*s);
                }
                const geo=new THREE.BufferGeometry(); geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
                const mat=new THREE.PointsMaterial({color:fw.color, size:2, map:this.tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
                fw.parts=new THREE.Points(geo,mat); fw.life=1.0; fw.vels=vels; this.scene.add(fw.parts);
            }
        }
        
        class SnowSystem {
            constructor(s){
                const p=[]; for(let i=0;i<6000;i++) p.push(Math.random()*600-300, Math.random()*200, Math.random()*600-300);
                const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.Float32BufferAttribute(p,3));
                this.m=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.5,transparent:true,opacity:0.6}));
                s.add(this.m);
            }
            update(){
                const p=this.m.geometry.attributes.position.array;
                for(let i=1;i<p.length;i+=3) { p[i]-=0.2; if(p[i]<0) p[i]=200; }
                this.m.geometry.attributes.position.needsUpdate=true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();

            // ğŸ¥ å…³é”®å‡çº§ï¼šç›®æ ‡é”å®šå¼è·Ÿéš
            if (PARAMS.viewMode === 'è·Ÿéšç«è½¦' && train) {
                // 1. æ›´æ–° OrbitControls çš„ä¸­å¿ƒç‚¹ (Target) åˆ°ç«è½¦å¤´
                controls.target.copy(train.loco.position);
                
                // 2. åªæœ‰åœ¨éœ€è¦å¼ºè¡Œé‡ç½®è§†è§’ä½ç½®æ—¶æ‰ä¿®æ”¹ camera.position
                // è¿™é‡Œæˆ‘ä»¬å¸Œæœ›ç”¨æˆ·å¯ä»¥æ—‹è½¬ï¼Œæ‰€ä»¥ä¸å¼ºåˆ¶æ¯å¸§è¦†ç›– camera.position
                // ä»…é€šè¿‡ OrbitControls çš„é˜»å°¼æ¥å®ç°å¹³æ»‘è·Ÿéš
                controls.update(); 
            } else {
                controls.update();
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
