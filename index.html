<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Express - Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* --- å¯åŠ¨é¡µæ ·å¼ --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: white; transition: opacity 0.6s ease-out;
        }
        h1 { 
            font-size: 36px; color: #ffb300; margin-bottom: 20px; letter-spacing: 4px; 
            text-shadow: 0 0 30px rgba(255, 165, 0, 0.5); text-transform: uppercase; text-align: center;
        }
        .intro-card {
            background: rgba(255,255,255,0.05); padding: 30px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); text-align: center; max-width: 90%; width: 400px;
        }
        .tips { color: #ccc; font-size: 14px; line-height: 2.2; margin-bottom: 30px; text-align: left; }
        .key { color: #4fc3f7; font-weight: bold; margin-right: 8px; border-bottom: 1px dashed #4fc3f7; }
        
        #start-btn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            color: white; border: none; padding: 15px 80px; font-size: 20px; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px rgba(211, 47, 47, 0.4);
            transition: transform 0.1s; border: 1px solid rgba(255,255,255,0.2);
        }
        #start-btn:active { transform: scale(0.95); }

        /* --- æ¸¸æˆå†… UI --- */
        #hud { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            pointer-events: none; opacity: 0; transition: opacity 1s; 
        }
        .tag { 
            background: rgba(0,0,0,0.6); color: #fff; padding: 8px 16px; 
            border-radius: 30px; font-size: 14px; border: 1px solid #ffffff22; 
            backdrop-filter: blur(4px); display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 8px; height: 8px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 5px #00ff00; }

        #settings-btn {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            width: 44px; height: 44px; background: rgba(255,255,255,0.1); 
            backdrop-filter: blur(10px); border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
            color: white; font-size: 22px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; opacity: 0; transition: opacity 1s;
        }
        
        /* --- è®¾ç½®å¼¹çª— --- */
        #settings-modal { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            z-index: 30; display: none; width: 340px; 
        }
        #modal-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 25; display: none; background: rgba(0,0,0,0.5); 
        }
        
        #loading { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #666; font-size: 12px; letter-spacing: 2px; }
    </style>
</head>
<body>

    <!-- å¯åŠ¨é¡µ -->
    <div id="start-screen">
        <div class="intro-card">
            <h1>åœ£è¯èŠ‚ğŸš‚å°ç«è½¦</h1>
            <div class="tips">
                <div><span class="key">ğŸ† ç‚¹å‡»å±å¹•</span> ç‡ƒæ”¾èŠ‚æ—¥çƒŸèŠ±</div>
                <div><span class="key">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾</span> è°ƒæ•´è·Ÿéšè·ç¦» (è·ç¦»è®°å¿†)</div>
                <div><span class="key">ğŸ‘† å•æŒ‡æ‹–åŠ¨</span> 360Â° è§‚å¯Ÿåˆ—è½¦ (æ¾æ‰‹å›æ­£)</div>
                <div><span class="key">âš¡ åŒå‡»å±å¹•</span> åˆ‡æ¢ ä¸Šå¸/é©¾é©¶ è§†è§’</div>
            </div>
            <button id="start-btn">å¼€å§‹æ—…ç¨‹</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="tag">
            <div class="dot"></div>
            <span id="view-text">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span>
        </div>
    </div>
    <div id="settings-btn">âš™ï¸</div>

    <div id="modal-overlay"></div>
    <div id="settings-modal"></div>
    
    <div id="loading">æ­£åœ¨è£…è½½çƒŸèŠ±ä¸ç¤¼ç‰©...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- æ ¸å¿ƒå‚æ•° ---
        const PARAMS = {
            // ğŸš‚ åˆ—è½¦
            trainSpeed: 0.15,
            carriageGap: 0.009, 
            wheelSpeed: 2.0,
            
            // ğŸ¥ ç›¸æœº
            camFollowDist: 2.0,  
            camHeightOffset: 40.0, 
            camSmooth: 0.02,      
            
            // ğŸ’¡ ç¯å¢ƒ
            moonIntensity: 1.8,
            fogDensity: 0.002,
            bloomStrength: 0.8,
            bloomThreshold: 1.0,
            
            // âœ¨ ç¯å…‰
            trainLightPower: 60.0,
            bulbBrightness: 15.0,
            starBrightness: 25.0,
            
            // ğŸ† çƒŸèŠ±æ§åˆ¶
    		autoFireworks: false,   // è‡ªåŠ¨å¼€å…³
    		fwInterval: 5.0,        // å‘å°„é—´éš”(ç§’)
        };

        const STATE = { 
            started: false, 
            viewMode: 'FOLLOW', 
            settingsOpen: false,
            isUserInteracting: false 
        };

        let scene, camera, renderer, composer, controls, gui;
        let train, fireworkMgr, snowSystem;
        let lights = {}, bloomPass;
        let groundMesh;
        let emissiveObjects = []; 
        let trackCurve, trackPointsSample = [];
        let autoFwTimer = null; // ç”¨äºå­˜å‚¨å®šæ—¶å™¨ID
        const clock = new THREE.Clock();
        const _vec3 = new THREE.Vector3();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020408);
            scene.fog = new THREE.FogExp2(0x020408, PARAMS.fogDensity);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 25, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ¨¡å—åˆå§‹åŒ– (å°†åœ¨åç»­éƒ¨åˆ†å®šä¹‰)
            setupLights();
            generateTrack();
            createTrackMesh();
            createEnvironment(); 

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 1.0;
            bloomPass.strength = PARAMS.bloomStrength;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            train = new TrainSystem(scene, trackCurve);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene);

            setupControls();
            setupUI();

            document.getElementById('loading').style.display = 'none';
            animate();
        }
        
        // (Part 1 ç»“æŸï¼Œè¯·å›å¤ "2" ç»§ç»­)
// (æ¥ Part 1)

        // ============================
        // ğŸŒ ä¸–ç•Œæ„å»ºç³»ç»Ÿ
        // ============================
        function setupLights() {
            // æœˆå…‰ (HDR)
            lights.moon = new THREE.DirectionalLight(0xaaccff, PARAMS.moonIntensity);
            lights.moon.position.set(-80, 120, -80);
            lights.moon.castShadow = true;
            lights.moon.shadow.mapSize.set(2048, 2048);
            lights.moon.shadow.camera.left = -200; lights.moon.shadow.camera.right = 200;
            lights.moon.shadow.camera.top = 200; lights.moon.shadow.camera.bottom = -200;
            scene.add(lights.moon);

            // ç¯å¢ƒå…‰
            const ambient = new THREE.AmbientLight(0x404060, 0.3);
            scene.add(ambient);

            // åœ°é¢
            groundMesh = new THREE.Mesh(
    			new THREE.CircleGeometry(600, 64), 
    			new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 1.0, metalness: 0.0 })
			);
			groundMesh.rotation.x = -Math.PI / 2; 
			groundMesh.receiveShadow = true;
			scene.add(groundMesh); // 2. è¿™é‡Œä¹Ÿè¦æ”¹æˆ groundMesh
        }

        function generateTrack() {
            // ç”Ÿæˆå¤æ‚çš„â€œä¸‰å¶è‰â€é—­åˆå›è·¯
            const s = 1.4; // ç¼©æ”¾ç³»æ•°
            const points = [
                new THREE.Vector3(10*s, 0, 20*s), new THREE.Vector3(50*s, 2, 50*s), new THREE.Vector3(90*s, 0, 0),
                new THREE.Vector3(50*s, 0, -50*s), new THREE.Vector3(10*s, 0, -20*s), new THREE.Vector3(-20*s, 0, -20*s),
                new THREE.Vector3(-50*s, 3, -70*s), new THREE.Vector3(-90*s, 0, -50*s), new THREE.Vector3(-60*s, 0, -10*s),
                new THREE.Vector3(-60*s, 0, 10*s), new THREE.Vector3(-90*s, 0, 50*s), new THREE.Vector3(-50*s, 3, 70*s),
                new THREE.Vector3(-20*s, 0, 20*s), new THREE.Vector3(0, 0, 0)
            ];
            trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
            // é‡‡æ ·600ä¸ªç‚¹ç”¨äºé¿éšœè®¡ç®—
            trackPointsSample = trackCurve.getPoints(600);
        }

        function createTrackMesh() {
            const divisions = 600;
            // 1. è·¯åŸº (é»‘è‰²é˜²ç©¿å¸®)
            const bed = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, divisions, 3.5, 8, true), 
                new THREE.MeshStandardMaterial({color: 0x080808, roughness: 1})
            );
            bed.position.y = -0.2; bed.scale.y = 0.1; 
            scene.add(bed);

            // 2. æ•æœ¨ (InstanceMesh ä¼˜åŒ–æ€§èƒ½)
            const plankGeo = new THREE.BoxGeometry(5.5, 0.3, 1.2);
            const plankMat = new THREE.MeshStandardMaterial({color: 0x3e2723});
            const planks = new THREE.InstancedMesh(plankGeo, plankMat, divisions);
            const dummy = new THREE.Object3D();
            
            for(let i=0; i<divisions; i++) {
                const t = i/divisions;
                const pos = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t);
                dummy.position.copy(pos); 
                dummy.lookAt(pos.clone().add(tangent)); 
                dummy.updateMatrix();
                planks.setMatrixAt(i, dummy.matrix);
            }
            planks.receiveShadow = true; 
            scene.add(planks);
        }

        // ğŸ›¡ï¸ æ ¸å¿ƒé¿éšœç®—æ³•ï¼šæ£€æŸ¥åæ ‡æ˜¯å¦å®‰å…¨
        function isSafePosition(x, z) {
            const safeDistSq = 18 * 18; // 18ç±³å®‰å…¨è·ç¦»
            for(let i=0; i<trackPointsSample.length; i+=3) { // æ­¥è¿›3ä¼˜åŒ–æ€§èƒ½
                const dx = trackPointsSample[i].x - x;
                const dz = trackPointsSample[i].z - z;
                if ((dx*dx + dz*dz) < safeDistSq) return false;
            }
            return true;
        }

        function createEnvironment() {
            // 1. æ”¾ç½®åœ°æ ‡å·¨æ ‘ (ä½äºç¯è·¯ä¸­å¿ƒ)
            createHeroTree(60, 0, 1.5, 0xff0000); 
            createHeroTree(-70, 50, 1.3, 0x00ff00);
            createHeroTree(-70, -50, 1.4, 0xffcc00);
            
            // 2. ç”Ÿæˆæ£®æ—èƒŒæ™¯ (è‡ªåŠ¨é¿éšœ)
            let planted = 0, attempts = 0;
            while(planted < 150 && attempts < 4000) {
                attempts++;
                const r = 35 + Math.random() * 180;
                const a = Math.random() * 6.28;
                const x = Math.cos(a)*r; const z = Math.sin(a)*r;
                
                if(isSafePosition(x, z)) {
                    createNatureTree(x, z);
                    planted++;
                }
            }

            // 3. ç”Ÿæˆè£…é¥°å“ (ç¤¼ç‰©/é›ªäºº/è·¯ç¯)
            for(let i=0; i<40; i++) {
                const x = (Math.random()-0.5)*350; 
                const z = (Math.random()-0.5)*350;
                if(isSafePosition(x, z)) {
                    const r = Math.random();
                    if(r < 0.3) createGift(x, z);
                    else if(r < 0.6) createSnowman(x, z);
                    else createLamp(x, z);
                }
            }
        }

        // --- ç‰©ä½“å·¥å‚å‡½æ•° ---

        function createHeroTree(x, z, s, c) {
            const g = new THREE.Group(); g.position.set(x, 0, z); g.scale.set(s,s,s);
            const t = new THREE.Mesh(new THREE.CylinderGeometry(1,2,4,8), new THREE.MeshStandardMaterial({color:0x3e2723})); t.position.y=2; g.add(t);
            const lm = new THREE.MeshStandardMaterial({color:0x0f4d0f, roughness:0.8});
            
            // æ ‘å† å±‚çº§
            for(let i=0;i<4;i++){
                const cone = new THREE.Mesh(new THREE.ConeGeometry(10-i*2, 6, 10), lm);
                cone.position.y = 4 + i*3.5; cone.castShadow = true; g.add(cone);
                
                // æŒ‚å½©ç¯
                const count = 5 + i;
                for(let k=0; k<count; k++){
                    const a = (k/count) * 6.28 + i; 
                    const br = 10 - i*2 - 0.5;
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.35,4,4), new THREE.MeshStandardMaterial({
                        color:0, emissive: Math.random()>0.5 ? c : 0xffffff, emissiveIntensity: PARAMS.bulbBrightness
                    }));
                    b.position.set(Math.cos(a)*br, 4+i*3.5-2.5, Math.sin(a)*br);
                    b.userData = {type:'bulb'}; emissiveObjects.push(b);
                    g.add(b);
                }
            }
            // æ ‘é¡¶æ˜Ÿ
            const st = new THREE.Mesh(new THREE.OctahedronGeometry(1.5), new THREE.MeshStandardMaterial({
                color:0xffff00, emissive:0xffaa00, emissiveIntensity:20
            }));
            st.position.y = 20; st.userData = {type:'star'}; emissiveObjects.push(st); g.add(st);
            
            // æ ‘åº•å…‰ç…§
            const pl = new THREE.PointLight(c, 2, 30); pl.position.y = 5; g.add(pl);
            scene.add(g);
        }

        function createNatureTree(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); 
            const s = 0.8 + Math.random()*0.8; g.scale.set(s,s,s);
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.8,3,5), new THREE.MeshStandardMaterial({color:0x3e2723})); 
            t.position.y=1.5; g.add(t);
            const m = new THREE.MeshStandardMaterial({color:0x1b3e20});
            for(let i=0;i<3;i++){
                const c = new THREE.Mesh(new THREE.ConeGeometry(4-i, 5, 7), m); 
                c.position.y = 3.5 + i*3; c.castShadow = true; g.add(c);
            }
            scene.add(g);
        }

        function createGift(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); g.rotation.y = Math.random();
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({color:Math.random()*0xffffff}));
            b.position.y = 0.75; b.castShadow = true; g.add(b); scene.add(g);
        }

        function createSnowman(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z); g.rotation.y = Math.random();
            const m = new THREE.MeshStandardMaterial({color:0xffffff});
            const b1 = new THREE.Mesh(new THREE.SphereGeometry(1.2,8,8), m); b1.position.y=1; g.add(b1);
            const b2 = new THREE.Mesh(new THREE.SphereGeometry(0.8,8,8), m); b2.position.y=2.5; g.add(b2);
            scene.add(g);
        }

        function createLamp(x, z) {
            const g = new THREE.Group(); g.position.set(x,0,z);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,7), new THREE.MeshStandardMaterial({color:0x111})); 
            p.position.y=3.5; g.add(p);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({
                color:0xffaa00, emissive:0xffaa00, emissiveIntensity:10
            }));
            b.position.y=7; b.userData={type:'bulb'}; emissiveObjects.push(b); g.add(b); 
            scene.add(g); 
        }

        // (Part 2 ç»“æŸï¼Œè¯·å›å¤ "3" ç»§ç»­)
      
      // (æ¥ Part 2)

        // ============================
        // ğŸš‚ ç«è½¦ç³»ç»Ÿ (æ ¸å¿ƒé€»è¾‘)
        // ============================
        class TrainSystem {
            constructor(scene, curve) {
                this.scene = scene; 
                this.curve = curve;
                this.group = new THREE.Group();
                this.smokes = []; 
                this.progress = 0;
                
                // 1. åˆ›å»ºè½¦å¤´
                this.loco = this.createDetailedLoco();
                this.group.add(this.loco);
                
                // 2. åˆ›å»ºè½¦å¢ (8èŠ‚)
                this.cars = [];
                for(let i=1; i<=8; i++) {
                    const car = this.createDetailedCar(i);
                    this.group.add(car);
                    this.cars.push(car);
                }
                
                // 3. åˆå§‹åŒ–é—´è·
                this.refreshGap();
                scene.add(this.group);
            }

            // åŠ¨æ€æ›´æ–°è½¦å¢é—´è· (ç”¨äºGUIè°ƒèŠ‚)
            refreshGap() { 
                this.cars.forEach((c, i) => {
                    // é—´è·ç´¯åŠ 
                    c.userData.tOffset = (i + 1) * PARAMS.carriageGap;
                }); 
            }
            
            createDetailedLoco() {
                const g = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.4});
                const black = new THREE.MeshStandardMaterial({color:0x1a1a1a});
                
                // é”…ç‚‰ & é©¾é©¶å®¤
                const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 5.5, 16), mat);
                boiler.rotation.x = Math.PI/2; boiler.position.set(0, 3.2, 1); g.add(boiler);
                const cab = new THREE.Mesh(new THREE.BoxGeometry(3.4, 4.5, 2.8), mat);
                cab.position.set(0, 3.5, -2.5); g.add(cab);
                
                // çƒŸå›± (è½¦å¤´æ–¹å‘ +Z)
                this.chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5), black);
                this.chimney.position.set(0, 4.2, 2.5); g.add(this.chimney);
                this.smokeSource = this.chimney; // è®°å½•å†’çƒŸç‚¹
                
                // æ’éšœå™¨ (ä¸‰è§’å½¢)
                const cow = new THREE.Mesh(new THREE.ConeGeometry(1.6, 1.5, 4), black);
                cow.rotation.x = -Math.PI/2; cow.rotation.y = Math.PI/4; 
                cow.scale.set(1, 0.5, 1); cow.position.set(0, 1, 4.5); g.add(cow);

                // è½¦ç¯ä¸å…‰æº
                const lamp = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.3), black);
                lamp.rotation.x = -Math.PI/2; lamp.position.set(0, 4.5, 3.8); g.add(lamp);
                
                const bulb = new THREE.Mesh(new THREE.CircleGeometry(0.35, 16), new THREE.MeshStandardMaterial({
                    color:0xffaa00, emissive:0xffdd88, emissiveIntensity:PARAMS.trainLightPower
                }));
                bulb.position.set(0, 4.5, 3.96); 
                bulb.userData={type:'headlight'}; 
                emissiveObjects.push(bulb); 
                g.add(bulb);
                
                const s = new THREE.SpotLight(0xffdd88, 50, 80, 0.6, 0.5); 
                s.position.set(0, 4.5, 4); s.target.position.set(0, 0, 30); 
                g.add(s); g.add(s.target);
                
                // åè¿æ¥æ†
                const coup = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 2.5), black);
                coup.position.set(0, 2, -3.5); g.add(coup);

                // è½®å­
                this.wheels = [];
                const addWheel = (x, z, s) => { 
                    const w = new THREE.Mesh(new THREE.CylinderGeometry(s, s, 0.4, 12), black); 
                    w.rotation.z = Math.PI/2; w.position.set(x, s, z); 
                    g.add(w); this.wheels.push(w); 
                };
                addWheel(1.7, 2, 1); addWheel(-1.7, 2, 1);
                addWheel(1.7, 0, 1); addWheel(-1.7, 0, 1);
                addWheel(1.7, 3.5, 0.6); addWheel(-1.7, 3.5, 0.6);
                
                return g;
            }

            createDetailedCar(i) {
                const g = new THREE.Group();
                const col = i % 2 === 0 ? 0x1565c0 : 0x2e7d32;
                const mat = new THREE.MeshStandardMaterial({color: col});
                const black = new THREE.MeshStandardMaterial({color: 0x111111});
                
                // è½¦èº«ä¸è½¦é¡¶
                const body = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.5, 5.0), mat); 
                body.position.y = 2.8; g.add(body);
                const roof = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 5.1, 8, 1, false, 0, Math.PI), new THREE.MeshStandardMaterial({color:0x333333}));
                roof.rotation.z = Math.PI/2; roof.rotation.y = Math.PI/2; 
                roof.position.set(0, 4.55, 0); g.add(roof);
                
                // çª—æˆ·
                const wg = new THREE.PlaneGeometry(0.8, 1.0);
                const addWin = (x, z) => { 
                    const w = new THREE.Mesh(wg, black); 
                    w.position.set(x, 3.2, z); 
                    w.rotation.y = x > 0 ? 1.57 : -1.57; 
                    g.add(w);
                };
                addWin(1.51, 1.2); addWin(1.51, -1.2); 
                addWin(-1.51, 1.2); addWin(-1.51, -1.2);

                // è¿æ¥æ† (åŒå‘äº’æ’ï¼Œé˜²ç©¿å¸®)
                const fc = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.7, 1.5), black); 
                fc.position.set(0, 2, 2.5); g.add(fc);
                const bc = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.7, 2.0), black); 
                bc.position.set(0, 2, -3.0); g.add(bc);
                
                // è½®å­
                const wGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.4, 12); wGeo.rotateZ(Math.PI/2);
                const w1 = new THREE.Mesh(wGeo, black); w1.position.set(1.6, 0.7, 1.5); g.add(w1);
                const w2 = new THREE.Mesh(wGeo, black); w2.position.set(-1.6, 0.7, 1.5); g.add(w2);
                if(!this.wheels) this.wheels=[]; this.wheels.push(w1, w2);
                
                return g;
            }

            update(delta) {
                // ç§»åŠ¨è¿›åº¦
                const speed = PARAMS.trainSpeed * delta * 0.2;
                this.progress = (this.progress + speed) % 1;
                
                // æ”¾ç½®è½¦å¤´
                this.place(this.loco, this.progress);
                
                // æ”¾ç½®è½¦å¢
                this.cars.forEach(c => {
                    let t = this.progress - c.userData.tOffset; 
                    if(t < 0) t += 1;
                    this.place(c, t);
                });

                // è½¦è½®åŠ¨ç”»
                if(this.wheels) {
                    this.wheels.forEach(w => w.rotation.x -= speed * 100 * PARAMS.wheelSpeed);
                }

                // å†’çƒŸé€»è¾‘
                if(Math.random() > 0.88) { 
                    _vec3.setFromMatrixPosition(this.smokeSource.matrixWorld); 
                    _vec3.y += 0.5; 
                    this.spawnSmoke(_vec3); 
                }
                this.updateSmoke();
            }

            place(obj, t) {
                const pos = this.curve.getPointAt(t);
                const tangent = this.curve.getTangentAt(t);
                obj.position.copy(pos);
                // ä¿®æ­£æœå‘ï¼šè®© +Z (è½¦å¤´) æŒ‡å‘åˆ‡çº¿æ–¹å‘
                // lookAt é»˜è®¤è®© -Z å¯¹å‡†ç›®æ ‡ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å¯¹å‡† "ä½ç½® - åˆ‡çº¿" çš„æ–¹å‘
                obj.lookAt(pos.clone().add(tangent)); 
            }

            spawnSmoke(pos) {
                const m = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.3 + Math.random()*0.4), 
                    new THREE.MeshStandardMaterial({color:0xcccccc, transparent:true, opacity:0.4})
                );
                m.position.copy(pos); 
                this.scene.add(m); 
                this.smokes.push({m, life:1.2});
            }

            updateSmoke() {
                for(let i=this.smokes.length-1; i>=0; i--) {
                    const s = this.smokes[i]; 
                    s.life -= 0.02; 
                    s.m.position.y += 0.06; 
                    s.m.scale.multiplyScalar(1.02); 
                    s.m.material.opacity = s.life * 0.3;
                    if(s.life <= 0){ 
                        this.scene.remove(s.m); 
                        this.smokes.splice(i, 1); 
                    }
                }
            }
        }

        // ============================
        // ğŸ‡ çƒŸèŠ±ç®¡ç†å™¨
        // ============================
        class FireworkManager {
    constructor(scene) {
        this.scene = scene;
        this.rockets = [];   // å­˜å‚¨ä¸Šå‡é˜¶æ®µçš„çƒŸèŠ±
        this.sparkles = [];  // å­˜å‚¨çˆ†ç‚¸åçš„ç²’å­
        
        // 1. ç”Ÿæˆé«˜æ¸…å…‰æ™•è´´å›¾ (128x128ï¼Œè¾¹ç¼˜æ›´æŸ”å’Œ)
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        g.addColorStop(0, 'rgba(255,255,255,1)');    // ä¸­å¿ƒæäº®
        g.addColorStop(0.2, 'rgba(255,255,255,0.8)'); // è¿‡æ¸¡
        g.addColorStop(0.5, 'rgba(255,255,255,0.2)'); // å…‰æ™•
        g.addColorStop(1, 'rgba(0,0,0,0)');           // è¾¹ç¼˜é€æ˜
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, 128, 128);
        this.texture = new THREE.CanvasTexture(canvas);

        // 2. é¢„è®¾ä¸“ä¸šèŠ‚æ—¥é…è‰²ç›˜
        this.palettes = [
            [0xff0000, 0xffaa00, 0xffffff], // ç»å…¸é‡‘çº¢
            [0x00ffff, 0x0000ff, 0xffffff], // å†°é›ªè“
            [0xff00ff, 0xaa00ff, 0xffaaaa], // èµ›åšç´«
            [0x00ff00, 0xffff00, 0xffffff], // åœ£è¯ç»¿
            [0xffffff, 0xffdd88, 0x88ccff], // é“¶æ²³ç™½
        ];
    }

    // å‘å°„é€»è¾‘ï¼šæ”¯æŒç‚¹å‡»åæ ‡ï¼Œä¹Ÿæ”¯æŒè‡ªåŠ¨è®¡ç®—
    launch(targetPos) {
        let startPos;
        // å¦‚æœæ²¡æœ‰ä¼ å…¥åæ ‡ï¼ˆæ¯”å¦‚è‡ªåŠ¨å‘å°„ï¼‰ï¼Œåˆ™åœ¨ç›¸æœºå‰æ–¹éšæœºç”Ÿæˆ
        if (!targetPos) {
            const vec = new THREE.Vector3(0, 0, -60).applyQuaternion(camera.quaternion).add(camera.position);
            startPos = vec.add(new THREE.Vector3((Math.random()-0.5)*80, -20, (Math.random()-0.5)*80));
        } else {
            startPos = targetPos.clone();
        }

        // éšæœºçˆ†ç‚¸é«˜åº¦ï¼š30 ~ 60
        const targetHeight = startPos.y + 60 + Math.random() * 30;
        
        // éšæœºé€‰æ‹©ä¸€ç§é…è‰²
        const palette = this.palettes[Math.floor(Math.random() * this.palettes.length)];

        // åˆ›å»ºä¸Šå‡çš„â€œç«ç®­â€ç²’å­
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
        const mat = new THREE.PointsMaterial({
            color: 0xffddaa, // ç«ç®­å°¾ç„°é¢œè‰²
            size: 2.5,
            map: this.texture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });
        
        const rocket = {
            mesh: new THREE.Points(geo, mat),
            pos: startPos.clone(),
            // ç‰©ç†å…¬å¼ï¼šåˆé€Ÿåº¦ = sqrt(2 * é‡åŠ› * é«˜åº¦å·®)ï¼Œç¡®ä¿åˆšå¥½é£åˆ°ç›®æ ‡é«˜åº¦
            vel: new THREE.Vector3(
                (Math.random()-0.5)*0.5, 
                Math.sqrt(2 * 0.02 * (targetHeight - startPos.y)), 
                (Math.random()-0.5)*0.5
            ),
            targetY: targetHeight,
            palette: palette
        };
        
        rocket.mesh.position.copy(startPos);
        this.scene.add(rocket.mesh);
        this.rockets.push(rocket);
    }

    // è‡ªåŠ¨é½å°„ï¼šä¿ç•™äº†ä½ å†™çš„â€œé¡ºç€é“è½¨å‰æ–¹â€çš„ä¼˜ç§€é€»è¾‘
    launchBurst() {
        if (!train || !trackCurve) return;
        
        // éšæœº 3-5 å‘
        const count = 3 + Math.floor(Math.random() * 3);
        
        for(let i=0; i<count; i++) {
            // 1. é¢„æµ‹ç«è½¦å‰æ–¹ä½ç½® (5% ~ 15% çš„è·¯ç¨‹)
            const lookAhead = 0.05 + Math.random() * 0.10;
            const t = (train.progress + lookAhead) % 1.0;

            // 2. è·å–é“è½¨åæ ‡
            const trackPos = trackCurve.getPointAt(t);

            // 3. æ•£å¸ƒåœ¨é“è½¨ä¸¤ä¾§ 40ç±³èŒƒå›´
            const spread = 40; 
            const randomX = (Math.random() - 0.5) * spread;
            const randomZ = (Math.random() - 0.5) * spread;

            // 4. è®¾å®šèµ·ç‚¹ (Y=-5 è®©å®ƒçœ‹èµ·æ¥ä»é›ªåœ°é‡Œé’»å‡ºæ¥)
            const startPos = new THREE.Vector3(trackPos.x + randomX, -5, trackPos.z + randomZ);
            
            // 5. é”™å³°å‘å°„ï¼Œé¿å…åŒæ—¶å‡ç©ºå¤ªæ­»æ¿
            setTimeout(() => {
                this.launch(startPos);
            }, Math.random() * 800);
        }
    }

    update() {
        // --- é˜¶æ®µ1ï¼šæ›´æ–°ä¸Šå‡çš„ç«ç®­ ---
        for (let i = this.rockets.length - 1; i >= 0; i--) {
            const r = this.rockets[i];
            
            // ç‰©ç†è¿åŠ¨
            r.pos.add(r.vel);
            r.vel.y -= 0.02; // é‡åŠ›ï¼šè¶Šæ¥è¶Šæ…¢
            r.mesh.position.copy(r.pos);

            // å½“é€Ÿåº¦æ¥è¿‘0ï¼ˆåˆ°è¾¾æœ€é«˜ç‚¹ï¼‰æ—¶å¼•çˆ†
            if (r.vel.y <= 0.5) {
                this.scene.remove(r.mesh);
                this.explode(r.pos, r.palette); // ä¼ å…¥ä½ç½®å’Œé¢œè‰²ç›˜
                this.rockets.splice(i, 1);
            }
        }

        // --- é˜¶æ®µ2ï¼šæ›´æ–°çˆ†ç‚¸åçš„çƒŸèŠ±ç²’å­ ---
        for (let i = this.sparkles.length - 1; i >= 0; i--) {
            const s = this.sparkles[i];
            const positions = s.mesh.geometry.attributes.position.array;
            const sizes = s.mesh.geometry.attributes.size.array;
            
            // å¯¿å‘½è¡°å‡
            s.life -= 0.008; 

            for (let k = 0; k < s.count; k++) {
                const idx = k * 3;
                
                // ä½ç½® += é€Ÿåº¦
                positions[idx]   += s.velocities[idx];
                positions[idx+1] += s.velocities[idx+1];
                positions[idx+2] += s.velocities[idx+2];

                // å…³é”®ç‰©ç†ï¼šç©ºæ°”é˜»åŠ› (æ¨¡æ‹Ÿçˆ†ç‚¸åçš„æ€¥å‰§å‡é€Ÿ)
                s.velocities[idx]   *= 0.96;
                s.velocities[idx+1] *= 0.96;
                s.velocities[idx+2] *= 0.96;

                // å…³é”®ç‰©ç†ï¼šé‡åŠ›ä¸‹å 
                s.velocities[idx+1] -= 0.03;

                // è§†è§‰ç‰¹æ•ˆï¼šé—ªçƒ (Twinkle)
                if(Math.random() > 0.5) {
                    // åŸºäºåŸºç¡€å¤§å°è¿›è¡Œéšæœºç¼©æ”¾
                    sizes[k] = s.baseSizes[k] * (0.5 + Math.random() * 0.5) * s.life;
                }
            }

            s.mesh.geometry.attributes.position.needsUpdate = true;
            s.mesh.geometry.attributes.size.needsUpdate = true;
            s.mesh.material.opacity = s.life;

            if (s.life <= 0) {
                // æ¶ˆå¤±å¤„ç†
                this.scene.remove(s.mesh);
                if(s.light) this.scene.remove(s.light);
                this.sparkles.splice(i, 1);
            } else if (s.light) {
                // ç¯å…‰è·Ÿéšç²’å­ä¸­å¿ƒå¹¶æ¸éš
                s.light.intensity = s.life * 15; 
                s.light.position.set(positions[0], positions[1], positions[2]);
            }
        }
    }

    explode(pos, palette) {
        const count = 1000; // ç²’å­æ•°é‡ (æ›´å¤š)
        const positions = new Float32Array(count * 3);
        const velocities = []; 
        const colors = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        const baseSizes = []; // è®°å½•åŸºç¡€å¤§å°ç”¨äºé—ªçƒ

        const colorObj = new THREE.Color();

        for (let i = 0; i < count; i++) {
            positions[i * 3] = pos.x;
            positions[i * 3 + 1] = pos.y;
            positions[i * 3 + 2] = pos.z;

            // çƒå½¢çˆ†ç‚¸é€Ÿåº¦è®¡ç®—
            // é€Ÿåº¦èŒƒå›´ 0.5 ~ 2.2 (ç‚¸å¾—æ›´å¼€)
            const speed = 0.5 + Math.random() * 2.2;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;

            velocities.push(
                speed * Math.sin(phi) * Math.cos(theta),
                speed * Math.sin(phi) * Math.sin(theta),
                speed * Math.cos(phi)
            );

            // ä»è°ƒè‰²ç›˜éšæœºå–è‰²
            const hex = palette[Math.floor(Math.random() * palette.length)];
            colorObj.setHex(hex);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;

            // éšæœºç²’å­å¤§å°
            const s = 1.5 + Math.random() * 2.5; 
            sizes[i] = s;
            baseSizes.push(s);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // æè´¨ï¼šä½¿ç”¨ vertexColors å’Œ AdditiveBlending å®ç°é«˜äº®å åŠ 
        const mat = new THREE.PointsMaterial({
            size: 1.0,
            map: this.texture,
            transparent: true,
            depthWrite: false, // é˜²æ­¢é®æŒ¡
            blending: THREE.AdditiveBlending, // è¶Šé‡å è¶Šäº®
            vertexColors: true // å¯ç”¨é¡¶ç‚¹é¢œè‰²
        });

        const mesh = new THREE.Points(geo, mat);
        this.scene.add(mesh);

        // é¢å¤–ç‰¹æ•ˆï¼šæ·»åŠ ä¸€ä¸ªç‚¹å…‰æºï¼Œç…§äº®å‘¨å›´çš„é›ªå’Œè½¦
        const light = new THREE.PointLight(palette[0], 15, 60);
        light.position.copy(pos);
        this.scene.add(light);

        this.sparkles.push({
            mesh, 
            light,
            count, 
            velocities, 
            baseSizes,
            life: 1.5 + Math.random() * 0.5 // å¯¿å‘½ 1.5~2.0ç§’
        });
    }
}

        // ============================
        // â„ï¸ å¤©æ°”ç³»ç»Ÿ
        // ============================
        class SnowSystem {
            constructor(scene) {
                const count = 3000;
                const pos = [];
                for(let i=0; i<count; i++) {
                    pos.push(Math.random()*600-300, Math.random()*200, Math.random()*600-300);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                // 1. ç”Ÿæˆä¸€ä¸ªç®€å•çš„åœ†å½¢è´´å›¾
const canvas = document.createElement('canvas');
canvas.width = 32; canvas.height = 32;
const context = canvas.getContext('2d');
context.fillStyle = '#ffffff';
context.beginPath();
context.arc(16, 16, 16, 0, Math.PI * 2);
context.fill();
const snowTexture = new THREE.CanvasTexture(canvas);

// 2. åº”ç”¨åˆ°æè´¨
this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({
    color: 0xaaaaaa, // ç°è‰²
    map: snowTexture, // åº”ç”¨åœ†å½¢è´´å›¾
    alphaMap: snowTexture, // ä½¿ç”¨é€æ˜åº¦è´´å›¾
    transparent: true,
    opacity: 0.6,
    size: 0.8, // æœ‰äº†è´´å›¾åï¼Œsize å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ç‚¹
    depthWrite: false, // å…³é”®ï¼šç¦æ­¢å†™å…¥æ·±åº¦ï¼Œé˜²æ­¢é›ªèŠ±é®æŒ¡çƒŸèŠ±æ—¶äº§ç”Ÿé»‘è¾¹
    blending: THREE.AdditiveBlending // å¯é€‰ï¼šå åŠ æ··åˆæ¨¡å¼ï¼Œä¼šè®©é‡å çš„é›ªèŠ±å˜äº®ä¸€ç‚¹ï¼Œä½†ä¸åƒçƒŸèŠ±é‚£ä¹ˆäº®
}));
                scene.add(this.mesh);
            }
            update() {
                const p = this.mesh.geometry.attributes.position.array;
                for(let i=1; i<p.length; i+=3) {
                    p[i] -= 0.25; 
                    if(p[i] < 0) p[i] = 200; // å¾ªç¯ä¸‹è½
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        // (Part 3 ç»“æŸï¼Œè¯·å›å¤ "4" ç»§ç»­)
      
      // (æ¥ Part 3)

        // ============================
        // âš™ï¸ äº¤äº’ä¸ UI è®¾ç½®
        // ============================
        function setupUI() {
            // 1. å¯åŠ¨æŒ‰é’®
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                STATE.started = true;
                // UI åŠ¨ç”»
                document.getElementById('start-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 600);
                document.getElementById('hud').style.opacity = '1';
                document.getElementById('settings-btn').style.opacity = '1';
            });

            // 2. è®¾ç½®å¼¹çª—
            const btn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const overlay = document.getElementById('modal-overlay');
            
            const toggleSettings = () => { 
                STATE.settingsOpen = !STATE.settingsOpen; 
                const disp = STATE.settingsOpen ? 'block' : 'none';
                modal.style.display = disp; 
                overlay.style.display = disp; 
            };
            btn.addEventListener('click', toggleSettings); 
            overlay.addEventListener('click', toggleSettings);

            // 3. GUI å‚æ•°é¢æ¿
            gui = new GUI({ container: modal, width: '100%' });
            gui.title('ğŸ”§ é©¾é©¶å‘˜æ§åˆ¶å°');

            const f1 = gui.addFolder('ğŸ¥ æ™ºèƒ½é•œå¤´');
            f1.add(PARAMS, 'camSmooth', 0.01, 0.1).name('å›æ­£æŸ”å’Œåº¦');
            f1.add(PARAMS, 'camHeightOffset', 2, 20).name('è§†è§’åŸºç¡€é«˜åº¦');

            const f2 = gui.addFolder('ğŸš‚ åˆ—è½¦ç‰©ç†');
            f2.add(PARAMS, 'trainSpeed', 0, 0.4).name('å¼•æ“é€Ÿåº¦');
            f2.add(PARAMS, 'carriageGap', 0.005, 0.02).name('è½¦å¢é—´è·').onChange(() => train.refreshGap());

            const f3 = gui.addFolder('ğŸ’¡ å…‰å½±æ°›å›´');
            f3.add(PARAMS, 'moonIntensity', 0, 5).name('æœˆå…‰äº®åº¦').onChange(v => lights.moon.intensity = v);
            f3.add(PARAMS, 'fogDensity', 0, 0.01).name('å¤§é›¾æµ“åº¦').onChange(v => scene.fog.density = v);
            f3.add(PARAMS, 'bloomStrength', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
            
            const updateEmis = () => emissiveObjects.forEach(o => {
                if(o.userData.type === 'bulb') o.material.emissiveIntensity = PARAMS.bulbBrightness;
                if(o.userData.type === 'headlight') o.material.emissiveIntensity = PARAMS.trainLightPower;
            });
            f3.add(PARAMS, 'bulbBrightness', 0, 50).name('å½©ç¯äº®åº¦').onChange(updateEmis);
            f3.add(PARAMS, 'trainLightPower', 0, 100).name('è½¦å¤´ç¯äº®åº¦').onChange(updateEmis);

			const f4 = gui.addFolder('ğŸ† èŠ‚æ—¥åº†å…¸');
			
			// 1. æ‰‹åŠ¨é½å°„æŒ‰é’®
			const fwControls = {
			    burst: () => fireworkMgr.launchBurst()
			};
			f4.add(fwControls, 'burst').name('âœ¨ ç«‹å³é½å°„');
			
			// 2. è‡ªåŠ¨æ’­æ”¾å¼€å…³é€»è¾‘
			const toggleAuto = (enabled) => {
			    if(autoFwTimer) clearInterval(autoFwTimer); // å…ˆæ¸…é™¤æ—§çš„
			    
			    if(enabled) {
			        // ç«‹å³å‘å°„ä¸€æ¬¡
			        fireworkMgr.launchBurst();
			        // å¼€å¯å®šæ—¶å™¨
			        autoFwTimer = setInterval(() => {
			            if(STATE.started) fireworkMgr.launchBurst();
			        }, PARAMS.fwInterval * 1000);
			    }
			};
			
			f4.add(PARAMS, 'autoFireworks').name('è‡ªåŠ¨çƒŸèŠ±ç§€').onChange(toggleAuto);
			
			// 3. é¢‘ç‡è°ƒæ•´
			f4.add(PARAMS, 'fwInterval', 0.5, 5.0).name('å‘å°„é—´éš”(ç§’)').onChange(() => {
			    // å¦‚æœå½“å‰æ˜¯å¼€å¯çŠ¶æ€ï¼Œéœ€è¦é‡ç½®å®šæ—¶å™¨è®©æ–°æ—¶é—´ç”Ÿæ•ˆ
			    if(PARAMS.autoFireworks) toggleAuto(true);
			});

            // 4. å…¨å±€äº¤äº’ç›‘å¬
            // ç‚¹å‡»æ”¾çƒŸèŠ± (é¿å¼€è®¾ç½®å¼¹çª—)
            // éœ€è¦å¼•å…¥ Raycaster æ¥æ£€æµ‹ç‚¹å‡»ä½ç½®
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			
			window.addEventListener('pointerdown', (e) => {
			    if(STATE.started && !STATE.settingsOpen) {
			        // 1. å°†é¼ æ ‡åæ ‡å½’ä¸€åŒ–ä¸º -1 åˆ° +1
			        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
			        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
			
			        // 2. å‘å°„å°„çº¿
			        raycaster.setFromCamera(mouse, camera);
			
			        // 3. æ£€æµ‹å°„çº¿æ˜¯å¦å‡»ä¸­åœ°é¢
			        // æ³¨æ„ï¼šå¦‚æœä½ æ”¹äº† groundMesh å˜é‡åï¼Œè¿™é‡Œè¦å¯¹åº”
			        const intersects = raycaster.intersectObject(groundMesh);
			
			        if (intersects.length > 0) {
			            // 4. è·å–å‡»ä¸­ç‚¹çš„åæ ‡ï¼Œå¹¶è®©çƒŸèŠ±ä»è¿™é‡Œå‘å°„
			            // y è½´ç¨å¾®åŠ ä¸€ç‚¹é«˜åº¦ï¼Œé¿å…å®Œå…¨è´´åœ¨åœ°ä¸Š
			            const point = intersects[0].point;
			            point.y += 0.5; 
			            fireworkMgr.launch(point);
			        } else {
			            // å¦‚æœç‚¹åˆ°äº†å¤©ç©ºï¼Œå°±éšæœºå‘å°„ï¼ˆå¯é€‰ï¼‰
			            fireworkMgr.launch();
			        }
			    }
			});
            
            // åŒå‡»åˆ‡æ¢è§†è§’
            window.addEventListener('dblclick', () => {
                if(!STATE.started) return;
                STATE.viewMode = STATE.viewMode === 'FOLLOW' ? 'GOD' : 'FOLLOW';
                
                // æ›´æ–° HUD æ–‡å­—
                const text = STATE.viewMode === 'FOLLOW' ? "æ™ºèƒ½é©¾é©¶æ¨¡å¼" : "ä¸Šå¸ä¿¯ç°æ¨¡å¼";
                document.getElementById('hud').querySelector('span').innerText = text;
                
                // åˆ‡æ¢åˆ°ä¸Šå¸è§†è§’æ—¶ï¼Œé‡ç½®ç›®æ ‡åˆ°ä¸­å¿ƒï¼Œæ–¹ä¾¿æ“ä½œ
                if(STATE.viewMode === 'GOD') controls.target.set(0,0,0);
            });
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // é˜²æ­¢ç©¿åœ°
            controls.minDistance = 10; 
            controls.maxDistance = 600;
            
            // å…³é”®ï¼šç›‘å¬ç”¨æˆ·äº¤äº’çŠ¶æ€
            // å½“ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨å±å¹•æ—¶ï¼Œæš‚åœç›¸æœºçš„è‡ªåŠ¨å›æ­£ï¼Œé¿å…â€œæŠ¢å¤ºâ€æ§åˆ¶æƒ
            controls.addEventListener('start', () => STATE.isUserInteracting = true);
            controls.addEventListener('end', () => STATE.isUserInteracting = false);
        }

        // ============================
        // ğŸ¥ æ ¸å¿ƒåŠ¨ç”»å¾ªç¯
        // ============================
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. æ›´æ–°å„ç³»ç»Ÿ
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();

            // 2. æ™ºèƒ½è·Ÿéšé€»è¾‘ (Smart TPS)
            if (STATE.started && STATE.viewMode === 'FOLLOW' && train) {
                const locoPos = train.loco.position;
                
                // æ ¸å¿ƒ A: é”å®šæ§åˆ¶å™¨ä¸­å¿ƒåˆ°ç«è½¦å¤´
                controls.target.copy(locoPos);

                // æ ¸å¿ƒ B: è‡ªåŠ¨å›æ­£ (ä»…å½“ç”¨æˆ·æ¾æ‰‹æ—¶)
                if (!STATE.isUserInteracting) {
                    // è·å–å½“å‰ç”¨æˆ·ç¼©æ”¾çš„è·ç¦» (Distance Memory)
                    const currentDist = camera.position.distanceTo(locoPos);
                    
                    // è·å–ç«è½¦æ­£åæ–¹å‘é‡ (-Zæ–¹å‘)
                    // (è½¦å¤´æ˜¯æŒ‡å‘åˆ‡çº¿çš„ï¼Œæˆ‘ä»¬å‡è®¾è½¦å¤´æ¨¡å‹çš„+Zæ˜¯å‰æ–¹)
                    // æ³¨æ„ï¼šåœ¨ TrainSystem.place ä¸­æˆ‘ä»¬ç”¨äº† lookAt(pos - tangent)
                    // è¿™æ„å‘³ç€ç‰©ä½“çš„ -Z æŒ‡å‘äº†åæ–¹ï¼Œ+Z æŒ‡å‘äº†å‰æ–¹ã€‚
                    // æ‰€ä»¥è·å–åæ–¹å¯ä»¥ç›´æ¥å–ç‰©ä½“åæ ‡ç³»çš„ -Z è½´ã€‚
                    const backVec = new THREE.Vector3(0, 0, -1).applyQuaternion(train.loco.quaternion).normalize();
                    
                    // è®¡ç®—ç†æƒ³ä½ç½®
                    // ä¿æŒå½“å‰çš„ç¼©æ”¾è·ç¦» (currentDist)
                    // å¹¶åŠ ä¸ŠåŸºç¡€é«˜åº¦åç§»
                    const idealPos = locoPos.clone()
                        .add(backVec.multiplyScalar(currentDist)) 
                        .add(new THREE.Vector3(0, PARAMS.camHeightOffset, 0)); 

                    // æŸ”å’Œæ’å€¼ç§»åŠ¨ (Soft Lock)
                    camera.position.lerp(idealPos, PARAMS.camSmooth);
                }
            } 
            // 3. å¾…æœºåŠ¨ç”» (æœªå¼€å§‹æ—¶)
            else if (!STATE.started) {
                const t = Date.now() * 0.0001;
                camera.position.set(Math.sin(t)*200, 120, Math.cos(t)*200);
                camera.lookAt(0,0,0);
            }

            controls.update();
            composer.render();
        }

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body> 
</html>
