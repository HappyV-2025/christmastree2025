<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8"><meta name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Christmas Express: Definitive Edition</title>
        <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "Microsoft YaHei", sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center, #1b2028 0%, #000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.8s; }
        .card { background: rgba(255, 255, 255, 0.06); padding: 40px; border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.1); text-align: center; backdrop-filter: blur(20px); box-shadow: 0 40px 80px rgba(0, 0, 0, 0.6); width: 400px; max-width: 90%; }
        h1 { color: #ffb300; margin: 0 0 20px; letter-spacing: 4px; text-shadow: 0 0 30px rgba(255, 165, 0, 0.5); text-transform: uppercase; font-size: 28px; }
        .tips { color: #ccc; font-size: 14px; line-height: 2.2; text-align: left; margin-left: 10px; margin-bottom: 30px; }
        .k { color: #4fc3f7; font-weight: bold; margin-right: 8px; border-bottom: 1px dashed #4fc3f7; }
        button#start-btn { background: linear-gradient(135deg, #d32f2f, #b71c1c); color: #fff; border: none; padding: 16px 60px; font-size: 20px; border-radius: 50px; cursor: pointer; box-shadow: 0 10px 30px rgba(211, 47, 47, 0.4); transition: 0.2s; font-weight: bold; letter-spacing: 1px; }
        button#start-btn:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(211, 47, 47, 0.6); }

        /* HUD & Top Bar */
        #top-bar { position: absolute; top: 0; left: 0; right: 0; z-index: 15; display: flex; justify-content: space-between; align-items: flex-start; padding: 20px; pointer-events: none; }
        #top-bar > * { pointer-events: auto; }
        #hud { opacity: 0; transition: 1s; }
        .tag { background: rgba(0, 0, 0, 0.7); color: #fff; padding: 8px 18px; border-radius: 30px; font-size: 14px; border: 1px solid #ffffff22; backdrop-filter: blur(5px); display: flex; align-items: center; gap: 10px; }
        .dot { width: 8px; height: 8px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 8px #00ff00; transition: 0.3s; }
        .dot.stop { background: #ff3300; box-shadow: 0 0 8px #ff3300; }
        #train-toggle { background: none; border: none; color: #fff; font-size: 18px; cursor: pointer; padding: 4px 8px; margin-left: 8px; border-radius: 8px; transition: 0.2s; }
        #train-toggle:hover { background: rgba(255, 255, 255, 0.15); }
        #hud-status { cursor: pointer; transition: 0.2s; }
        #hud-status:hover { color: #4fc3f7; }

        /* Settings Button */
        #settings-btn { width: 44px; height: 44px; background: rgba(255, 255, 255, 0.1); border-radius: 50%; border: 1px solid #ffffff33; color: #fff; font-size: 20px; display: flex; justify-content: center; align-items: center; cursor: pointer; opacity: 0; backdrop-filter: blur(5px); transition: 0.3s; }
        #settings-btn:hover { background: rgba(255, 255, 255, 0.2); transform: rotate(90deg); }

        /* Settings Modal (Modern Tabbed UI) */
        #modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 25; display: none; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(3px); }
        #settings-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; display: none; width: 380px; max-width: 90%; background: rgba(20, 20, 25, 0.95); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); overflow: hidden; flex-direction: column; }

        .settings-header { padding: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.02); }
        .settings-header h2 { margin: 0; font-size: 18px; color: #ffd700; letter-spacing: 1px; }
        .close-btn { background: none; border: none; color: #999; font-size: 24px; cursor: pointer; padding: 0; line-height: 1; }
        .close-btn:hover { color: #fff; }

        .settings-tabs { display: flex; background: rgba(0,0,0,0.3); padding: 5px; gap: 5px; }
        .tab-btn { flex: 1; background: none; border: none; color: #888; padding: 10px 0; font-size: 14px; cursor: pointer; border-radius: 8px; transition: 0.3s; }
        .tab-btn.active { background: rgba(255,255,255,0.1); color: #fff; font-weight: bold; }
        .tab-btn:hover:not(.active) { background: rgba(255,255,255,0.05); color: #ccc; }

        .settings-body { padding: 20px; max-height: 60vh; overflow-y: auto; }
        .tab-content { display: none; animation: fadeIn 0.3s; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .control-group { margin-bottom: 20px; }
        .control-label { display: flex; justify-content: space-between; color: #ccc; font-size: 13px; margin-bottom: 8px; }
        .control-val { color: #4fc3f7; font-family: monospace; }
        
        /* Custom Range Slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffd700; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }
        input[type=range]:focus { outline: none; }

        /* Custom Select */
        select { width: 100%; padding: 8px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; outline: none; }

        /* Toggle Switch */
        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .toggle-label { color: #ccc; font-size: 14px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #d32f2f; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Firework Button */
        #firework-btn { position: absolute; bottom: 30px; right: 30px; z-index: 20; width: 60px; height: 60px; background: radial-gradient(circle at 30% 30%, #ff6b6b, #d32f2f); border-radius: 50%; border: 2px solid #ff8a80; color: #fff; font-size: 28px; display: flex; justify-content: center; align-items: center; cursor: pointer; opacity: 0; transition: all 0.3s; box-shadow: 0 4px 20px rgba(211, 47, 47, 0.5); }
        #firework-btn:hover { transform: scale(1.1); box-shadow: 0 6px 30px rgba(211, 47, 47, 0.7); }
        #firework-btn:active { transform: scale(0.95); }
        #firework-btn.burst { animation: burst 0.4s ease-out; }
        @keyframes burst { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }

        /* Countdown */
        #countdown-wrap { position: absolute; top: 70px; right: 20px; opacity: 0; transition: opacity 0.5s; }
        #countdown-trigger { background: linear-gradient(135deg, rgba(183, 28, 28, 0.85), rgba(139, 0, 0, 0.85)); color: #fff; padding: 6px 14px; border-radius: 20px; font-size: 13px; cursor: pointer; border: 1px solid rgba(255, 215, 0, 0.5); box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3); display: flex; align-items: center; gap: 6px; transition: all 0.3s; backdrop-filter: blur(5px); }
        #countdown-trigger:hover { transform: scale(1.05); box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4); }
        #countdown-trigger .arrow { font-size: 10px; transition: transform 0.3s; }
        #countdown-trigger.expanded .arrow { transform: rotate(180deg); }
        #countdown-panel { position: absolute; top: 100%; right: 0; margin-top: 10px; background: linear-gradient(145deg, rgba(20, 60, 20, 0.95), rgba(139, 0, 0, 0.9)); border-radius: 16px; padding: 16px 24px; text-align: center; opacity: 0; visibility: hidden; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); border: 2px solid rgba(255, 215, 0, 0.4); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); pointer-events: none; min-width: 200px; }
        #countdown-panel.show { opacity: 1; visibility: visible; pointer-events: auto; }
        #countdown-panel .title { color: #ffd700; font-size: 14px; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        #countdown-panel .time { color: #fff; font-size: 28px; font-weight: bold; text-shadow: 0 0 20px rgba(255, 255, 255, 0.3); letter-spacing: 2px; }
        #countdown-panel .hint { color: #aaa; font-size: 12px; margin-top: 5px; } 
        #loading { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #666; font-size: 12px; letter-spacing: 2px; }

        @media(max-width: 480px) {
            .card { width: 90%; padding: 30px 20px; }
            #countdown-trigger .text { display: none; }
            #settings-modal { width: 95%; }
        }

        /* ğŸ„ åœ£è¯è´ºå¡ä¸“å±æ ·å¼ (å±…ä¸­ã€ä¼˜é›…ã€ä¸é¬¼ç•œ) ğŸ„ */
        #countdown-panel.christmas-card {
            /* æ ¸å¿ƒå®šä½ï¼šå…¨å±å±…ä¸­ */
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            right: auto !important;
            margin-top: 0 !important;
            transform: translate(-50%, -50%) scale(1);
            
            /* è§†è§‰æ ·å¼ï¼šçº¢é‡‘é…è‰²è´ºå¡ */
            background: linear-gradient(145deg, #4a0000 0%, #1a0000 100%);
            border: 2px solid #ffd700;
            box-shadow: 0 0 60px rgba(255, 0, 0, 0.4), inset 0 0 30px rgba(255, 215, 0, 0.1);
            padding: 40px 60px;
            min-width: 400px;
            z-index: 200; /* ä¿è¯åœ¨æœ€ä¸Šå±‚ */
            
            /* åŠ¨ç”»ï¼šä¼˜é›…å¼¹å…¥ */
            animation: cardPop 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* éšè—åŸæœ¬çš„å°ä¸‰è§’ */
        #countdown-panel.christmas-card::before { display: none; }

        /* ä¼˜é›…çš„é‡‘è‰²ä¸»æ ‡é¢˜ */
        .xmas-main-title {
            font-family: "Georgia", "Times New Roman", serif;
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 15px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
            /* ç®€å•çš„å‘¼å¸åŠ¨æ•ˆï¼Œä¸é¬¼ç•œ */
            animation: gentleBreath 3s ease-in-out infinite;
        }

        /* å‰¯æ ‡é¢˜ */
        .xmas-sub-title {
            font-size: 14px;
            color: #ffb7b7;
            text-align: center;
            letter-spacing: 2px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            font-style: italic;
        }

        /* å…³é—­æŒ‰é’® (å¯é€‰ï¼Œé˜²æ­¢ç”¨æˆ·æƒ³çœ‹é£æ™¯å…³ä¸æ‰) */
        .xmas-close-hint {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            text-align: center;
            cursor: pointer;
            transition: 0.3s;
        }
        .xmas-close-hint:hover { color: #fff; }

        @keyframes cardPop {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @keyframes gentleBreath {
            0%, 100% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.3); transform: scale(1); }
            50% { text-shadow: 0 0 25px rgba(255, 215, 0, 0.6); transform: scale(1.02); }
        }

        /* å€’è®¡æ—¶æœ€å5ç§’ç‰¹æ•ˆ */
        #final-countdown {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 150px;
            font-weight: 900;
            font-family: "Arial Black", "Impact", sans-serif;
            z-index: 200;
            pointer-events: none;
            display: none;
            
            /* é‡‘çº¢æ¸å˜å­— */
            background: linear-gradient(to bottom, #ffd700 0%, #ff8c00 50%, #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
        }
        #final-countdown.pop {
            animation: numPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes numPop {
            0% { transform: translateX(-50%) scale(0.2); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.4); opacity: 1; }
            100% { transform: translateX(-50%) scale(1.0); opacity: 1; }
        }

        /* --- ğŸš‚ é£æ ¼A: è½¦ç«™ç¿»ç‰Œ (Split-Flap) --- */
        .style-flap .time {
            font-family: "Courier New", monospace;
            background: #222;
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            border: 4px solid #444;
            box-shadow: 0 10px 20px rgba(0,0,0,0.8), inset 0 2px 0 rgba(255,255,255,0.1);
            letter-spacing: 4px;
            display: inline-block;
            position: relative;
        }
        /* æ¨¡æ‹Ÿä¸­é—´åˆ†å‰²çº¿ */
        .style-flap .time::after {
            content: ''; position: absolute; left:0; right:0; top: 50%; height: 2px; background: rgba(0,0,0,0.6);
        }

        /* --- âœ¨ é£æ ¼B: çš‡å®¶çƒ«é‡‘ (Royal Gold) --- */
        .style-royal .title {
            font-family: "Georgia", serif;
            font-style: italic;
            letter-spacing: 2px;
            color: #ffd700 !important;
        }
        .style-royal .time {
            font-family: "Times New Roman", serif;
            font-weight: bold;
            background: linear-gradient(to bottom, #cfc09f 22%, #634f2c 24%, #cfc09f 26%, #cfc09f 27%, #ffecb3 40%, #3a2c0f 78%); 
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            letter-spacing: 2px;
        }
        .style-royal {
            border: 2px solid rgba(255, 215, 0, 0.3) !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.1), inset 0 0 20px rgba(255, 215, 0, 0.1) !important;
        }

        /* --- ğŸ§Š é£æ ¼C: èµ›åšå†°æ™¶ (Cyber Ice) --- */
        .style-cyber .time {
            font-family: "Consolas", "Monaco", monospace;
            color: #e0f7fa;
            text-shadow: 0 0 5px #00e5ff, 0 0 10px #00e5ff, 0 0 20px #00e5ff;
            letter-spacing: 3px;
        }
        .style-cyber {
            border: 1px solid #00e5ff !important;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.3) !important;
            background: rgba(0, 20, 40, 0.9) !important;
        }
        .style-cyber .title { color: #00e5ff !important; }
    </style>
    </head>
    <body>
        <div id="start-screen"><div class="card">
                <h1>ğŸ„ åœ£è¯å¿«ä¹</h1>
                <div class="tips">
                    <div><span class="k">ğŸš‚ ç‚¹å‡»è½¦å¤´</span> èƒŒæ™¯éŸ³ä¹ å¼€/å…³</div>
                    <div><span class="k">ğŸ”” ç‚¹å‡»è½¦å¢</span> é“ƒé“›å“èµ· + æ‰”å‡ºç¤¼ç›’</div>
                    <div><span class="k">ğŸ† å³ä¸‹æŒ‰é’®</span> ç‡ƒæ”¾çƒŸèŠ±</div>
                    <div><span class="k">ğŸ‘† æ‹–åŠ¨æ—‹è½¬</span> 360Â° è‡ªç”±è§‚å¯Ÿ</div>
                </div>
                <button id="start-btn">é¸£ç¬›å‘è½¦</button>
            </div>
        </div>
        <div id="top-bar">
            <div id="hud"><div class="tag"><div id="d-status" class="dot"></div><span id="hud-status">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span><button id="train-toggle">â¸ï¸</button></div></div>
            <div id="countdown-wrap">
                <div id="countdown-trigger">
                    <span>ğŸ„</span>
                    <span class="text">åœ£è¯</span>
                    <span id="countdown-days">--</span>å¤©
                    <span class="arrow">â–¼</span>
                </div>
                <div id="countdown-panel">
                    <div class="decorations">ğŸ…</div>
                    <div class="title">âœ¨ è·ç¦»åœ£è¯èŠ‚è¿˜æœ‰ âœ¨</div>
                    <div class="time" id="countdown-detail">--å¤© --:--:--</div>
                    <div class="hint">ç‚¹å‡»ä»»æ„å¤„æ”¶èµ·</div>
                </div>
            </div>
            <div id="settings-btn">âš™ï¸</div>
        </div>
        <div id="firework-btn">ğŸ†</div>
        <div id="modal-overlay"></div><div id="settings-modal"></div>
        <div id="loading">æ­£åœ¨è£…è½½ç¤¼ç‰©ä¸é­”æ³•...</div>
        <div id="canvas-container"></div>
        <div id="final-countdown"></div>

        <script
            type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
        <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

// ğŸš€ ç¤¼ç‰©é£è¡Œå°¾è¿¹ (SimpleTrail Class)
class GiftParticleTrail {
    static getTexture() {
        if (!GiftParticleTrail._tex) {
            const cv = document.createElement('canvas'); 
            cv.width = 32; cv.height = 32;
            const ctx = cv.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            GiftParticleTrail._tex = new THREE.CanvasTexture(cv);
        }
        return GiftParticleTrail._tex;
    }

    constructor(scene, colorHex) {
        this.scene = scene;
        this.maxParticles = 100; // ç²’å­æ•°é‡
        this.particles = [];
        
        // å‡ ä½•ä½“
        this.geo = new THREE.BufferGeometry();
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));
        this.geo.setAttribute('opacity', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));

        // æè´¨ (æ”¯æŒé€æ˜åº¦å˜åŒ–)
        this.mat = new THREE.ShaderMaterial({
            uniforms: { map: { value: GiftParticleTrail.getTexture() } },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                attribute float opacity;
                varying vec3 vColor;
                varying float vOpacity;
                void main() {
                    vColor = color;
                    vOpacity = opacity;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                varying vec3 vColor;
                varying float vOpacity;
                void main() {
                    vec4 tex = texture2D(map, gl_PointCoord);
                    if (tex.a < 0.1) discard;
                    gl_FragColor = vec4(vColor, vOpacity * tex.a);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.mesh = new THREE.Points(this.geo, this.mat);
        this.mesh.frustumCulled = false;
        
        // åˆå§‹åŒ–éšè—æ‰€æœ‰ç‚¹
        const posAttr = this.geo.attributes.position;
        for(let i=0; i<this.maxParticles; i++) posAttr.setXYZ(i, 0, -9999, 0);

        this.scene.add(this.mesh);
        
        // åŸºç¡€é¢œè‰²
        this.baseColor = new THREE.Color(colorHex);
    }

    // åœ¨æ¯ä¸€å¸§è°ƒç”¨ï¼Œä¼ å…¥ç¤¼ç‰©å½“å‰ä½ç½®
    update(currentPos, globalOpacity = 1.0) {
        // 1. å‘å°„æ–°ç²’å­ (æ¯å¸§å‘å°„ 2 ä¸ªï¼Œå¢åŠ å¯†åº¦)
        for(let k=0; k<2; k++) {
            if (globalOpacity > 0.01) { // åªæœ‰ç¤¼ç‰©å­˜åœ¨æ—¶æ‰å‘å°„
                const p = {
                    pos: currentPos.clone(),
                    // æ·»åŠ ä¸€ç‚¹éšæœºæ•£å¸ƒï¼Œä¸è¦å®Œå…¨å‘ˆä¸€æ¡ç›´çº¿
                    vel: new THREE.Vector3(
                        (Math.random()-0.5) * 0.5,
                        (Math.random()-0.5) * 0.5,
                        (Math.random()-0.5) * 0.5
                    ),
                    life: 1.0, // å¯¿å‘½
                    maxLife: 1.0,
                    size: 2.0 + Math.random() * 2.0 // éšæœºå¤§å°
                };
                // ç¨å¾®åç§»ä¸€ç‚¹åˆå§‹ä½ç½®ï¼Œçœ‹èµ·æ¥æ›´åƒä½“ç§¯å…‰
                p.pos.x += (Math.random()-0.5) * 1.5;
                p.pos.y += (Math.random()-0.5) * 1.5;
                p.pos.z += (Math.random()-0.5) * 1.5;
                
                this.particles.push(p);
            }
        }

        // 2. æ›´æ–°æ‰€æœ‰ç²’å­çŠ¶æ€
        const positions = this.geo.attributes.position;
        const colors = this.geo.attributes.color;
        const sizes = this.geo.attributes.size;
        const opacities = this.geo.attributes.opacity;

        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.life -= 0.03; // è¡°å‡é€Ÿåº¦

            if (p.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }

            // ç‰©ç†è¿åŠ¨ (è®©ç²’å­ç¨å¾®æ»ç•™æˆ–ä¸‹æ²‰)
            p.pos.add(p.vel);
            p.vel.multiplyScalar(0.95); // é˜»åŠ›

            const age = p.life / p.maxLife;

            // å†™å…¥ Buffer (å¦‚æœæ˜¯æ´»è·ƒç²’å­)
            if (i < this.maxParticles) {
                positions.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);
                
                // é¢œè‰²ç¨å¾®å˜äº®/å˜ç™½
                colors.setXYZ(i, this.baseColor.r, this.baseColor.g, this.baseColor.b);
                
                // å¤§å°éšæ—¶é—´å˜å°
                sizes.setX(i, p.size * age);
                
                // é€æ˜åº¦éšæ—¶é—´æ¶ˆå¤±
                opacities.setX(i, age * globalOpacity);
            }
        }

        // 3. éšè—å¤šä½™çš„ç²’å­ç‚¹
        for (let i = this.particles.length; i < this.maxParticles; i++) {
            positions.setXYZ(i, 0, -9999, 0);
            sizes.setX(i, 0);
        }

        positions.needsUpdate = true;
        colors.needsUpdate = true;
        sizes.needsUpdate = true;
        opacities.needsUpdate = true;
    }

    dispose() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.geo.dispose();
            this.mat.dispose();
        }
    }
}

// çƒŸèŠ±éŸ³æ•ˆé¢„è®¾
const SOUND_STYLES = [
    // 0. æ ‡å‡†å¹³è¡¡ (Standard)
    { name: "æ ‡å‡†", noise: {f:800, q:1, vol:3, dur:1.5}, kick: {f:60, vol:2.5, dur:0.3} },

    // 1. å·¨å‹é‡ç‚® (Heavy/Deep) - é€‚åˆå¤§çƒŸèŠ±ï¼Œä½éŸ³é‡ï¼Œå›å£°é•¿
    { name: "å·¨å‹é‡ç‚®", noise: {f:300, q:0.5, vol:4, dur:2.5}, kick: {f:50, vol:4.0, dur:0.5} },

    // 2. é—·å“ (Muffled/Distant) - åƒæ˜¯åœ¨è¿œå¤„çš„çˆ†ç‚¸
    { name: "è¿œå¤„é—·å“", noise: {f:200, q:0, vol:3, dur:1.0}, kick: {f:40, vol:2.0, dur:0.4} },

    // 3. é‡‘å±å›éŸ³ (Metallic) - å¸¦æœ‰å…±é¸£æ„Ÿ
    { name: "é‡‘å±å›éŸ³", noise: {f:1200, q:10, vol:2, dur:1.8}, kick: {f:80, vol:1.5, dur:0.2} },

    // 4. ç©ºæ°”çˆ†ç ´ (Airy) - ä¸»è¦æ˜¯æ°”æµå£°ï¼Œæ¯”è¾ƒæŸ”å’Œ
    { name: "ç©ºæ°”çˆ†ç ´", noise: {f:600, q:0.1, vol:2, dur:0.8}, kick: {f:30, vol:3.0, dur:0.4} },

    // 5. ç¤¼èŠ±å¼¹ (Shell) - å…ˆæœ‰ä¸€æ®µå°–å•¸ï¼ˆæ¨¡æ‹Ÿï¼‰ï¼Œè¿™é‡Œä¸»è¦è¡¨ç°ç‚¸å¼€çš„æ•£è½æ„Ÿ
    { name: "ç¤¼èŠ±æ•£è½", noise: {f:1000, q:0.5, vol:1.5, dur:3.0}, kick: {f:55, vol:2.0, dur:0.2} },

    // 6. æè‡´éœ‡æ’¼ (Impact) - ç”šè‡³ä¼šæœ‰ç‚¹ç ´éŸ³çš„æ„Ÿè§‰
    { name: "æè‡´éœ‡æ’¼", noise: {f:500, q:2, vol:6, dur:2.0}, kick: {f:45, vol:5.0, dur:0.6} },
];

// ğŸ¥ æ‘„åƒæœºå¯¼æ¼”ç³»ç»Ÿ (Camera Director)
const CameraDirector = {
    camera: null,
    controls: null,
    train: null,
    trackCurve: null,
    
    // é…ç½®
    config: {
        droneCount: 6,
        droneCoverage: 0.18,
        switchDur: 1.0,
        height: 40,
        distance: 100,
        smoothSpeed: 0.08
    },

    // çŠ¶æ€
    state: {
        currentDrone: 0,
        switching: false,
        switchT: 0,
        fromPos: new THREE.Vector3(),
        toPos: new THREE.Vector3(),
        fromTarget: new THREE.Vector3(),
        toTarget: new THREE.Vector3(),
        // ä¸´æ—¶å˜é‡
        _tempPos: new THREE.Vector3(),
        _tempTarget: new THREE.Vector3()
    },

    init(cam, ctrl, tr, curve) {
        this.camera = cam;
        this.controls = ctrl;
        this.train = tr;
        this.trackCurve = curve;
        
        if (!this.controls || !this.controls.target) {
            console.error("CameraDirector: Controls or controls.target is undefined after init.");
        }
    },

    // è®¡ç®—æŒ‡å®šæ— äººæœºçš„ç†æƒ³ä½ç½®
    getDronePosition(droneIndex, trainProg, outPos, outTarget) {
        if (!this.trackCurve) return;
        const trainPos = this.trackCurve.getPointAt(trainProg);
        const vec = new THREE.Vector3(trainPos.x, 0, trainPos.z).normalize();
        
        outPos.copy(trainPos);
        outPos.addScaledVector(vec, this.config.distance);
        outPos.y = this.config.height;
        outTarget.set(0, 15, 0); // çœ‹å‘ä¸­å¿ƒ
    },

    // å¹³æ»‘æ’å€¼
    smoothStep(t) { return t * t * (3 - 2 * t); },

    // æ ¸å¿ƒæ›´æ–°å¾ªç¯
    update(dt) {
        if (!this.train || !STATE.started) return;

        // 1. èšç„¦ç¤¼ç›’æ¨¡å¼
        if (STATE.viewMode === 'FOCUS_GIFT') {
            const giftCamPos = new THREE.Vector3(0, 15, 60); 
            const giftTarget = new THREE.Vector3(0, 8, 20); 
            this.camera.position.lerp(giftCamPos, 0.05);
            this.controls.target.lerp(giftTarget, 0.05);
            return;
        }

        // 2. åº†ç¥æ¨¡å¼ (Drone Pull-Back)
        if (STATE.viewMode === 'CELEBRATION') {
            // æ ¹æ®å±å¹•æ¯”ä¾‹è°ƒæ•´æ‹‰è¿œè·ç¦» (ç§»åŠ¨ç«¯æ›´è¿œä»¥çœ‹åˆ°å®Œæ•´æ–‡å­—)
            const aspect = this.camera.aspect;
            const distZ = aspect < 1.0 ? 160 : 110; 
            const heightY = aspect < 1.0 ? 80 : 50; 

            const targetPos = new THREE.Vector3(0, heightY, distZ);
            const targetLook = new THREE.Vector3(0, 0, 10); // çœ‹å‘æ–‡å­—ä¸­å¿ƒ (ç¨å¾®é å‰)

            this.camera.position.lerp(targetPos, 0.03); // æ…¢é€Ÿæ‹‰è¿œ
            this.controls.target.lerp(targetLook, 0.03);
            return;
        }

        // 3. æ™ºèƒ½è·Ÿæ‹æ¨¡å¼ (Drone Follow)
        if (STATE.viewMode === 'FOLLOW' && !STATE.interacting) {
            this.updateDroneFollow(dt);
        } 
        
        // 4. äº¤äº’ä¸­ (åªå¹³æ»‘ Target)
        else if (STATE.viewMode === 'FOLLOW' && STATE.interacting) {
            this.getDronePosition(this.state.currentDrone, this.train.prog, this.state._tempPos, this.state._tempTarget);
            this.controls.target.lerp(this.state._tempTarget, this.config.smoothSpeed * 1.2);
        }
    },

    updateDroneFollow(dt) {
        const trainProg = this.train.prog;
        const st = this.state;

        // ç®€åŒ–ä¸”å¥å£®çš„åˆ‡æ¢é€»è¾‘ï¼šåŸºäºæ‰‡åŒºç´¢å¼•
        // å°†è½¨é“åˆ†ä¸º droneCount ä¸ªæ‰‡åŒºï¼Œè®¡ç®—ç«è½¦å½“å‰å¤„äºå“ªä¸ªæ‰‡åŒº
        let idealDrone = Math.floor(trainProg * this.config.droneCount) % this.config.droneCount;
        
        // å¦‚æœå½“å‰æ— äººæœºä¸æ˜¯ç†æƒ³æ— äººæœºï¼Œä¸”ä¸åœ¨åˆ‡æ¢ä¸­ï¼Œåˆ™è§¦å‘åˆ‡æ¢
        if (idealDrone !== st.currentDrone && !st.switching) {
            st.fromPos.copy(this.camera.position);
            st.fromTarget.copy(this.controls.target);
            st.currentDrone = idealDrone;
            
            // ç«‹å³è®¡ç®—æ–°æ— äººæœºçš„ä½ç½®ä½œä¸ºç»ˆç‚¹
            this.getDronePosition(st.currentDrone, trainProg, st.toPos, st.toTarget);
            
            st.switching = true;
            st.switchT = 0;
        }

        if (st.switching) {
            st.switchT += dt / this.config.switchDur;
            if (st.switchT >= 1) {
                st.switchT = 1;
                st.switching = false;
            }
            const k = this.smoothStep(st.switchT);
            this.getDronePosition(st.currentDrone, trainProg, st.toPos, st.toTarget);
            this.camera.position.lerpVectors(st.fromPos, st.toPos, k);
            this.controls.target.lerpVectors(st.fromTarget, st.toTarget, k);
        } else {
            this.getDronePosition(st.currentDrone, trainProg, st._tempPos, st._tempTarget);
            const speedFactor = 1 + STATE.curSpeed * 3;
            const posSmooth = Math.min(this.config.smoothSpeed * speedFactor, 0.25);
            const targetSmooth = Math.min(this.config.smoothSpeed * speedFactor * 1.5, 0.35);
            
            this.camera.position.lerp(st._tempPos, posSmooth);
            if (this.controls && this.controls.target) {
                this.controls.target.lerp(st._tempTarget, targetSmooth);
            } else {
                console.error("CameraDirector.updateDroneFollow: this.controls or this.controls.target is null/undefined during lerp.", this.controls);
            }
        }
    },

    // å¼ºåˆ¶å¼€å§‹å·¡èˆª (ç”¨äºä»å…¶ä»–æ¨¡å¼åˆ‡å›)
    startCruise() {
        if (!this.train) return;
        if (!this.controls || !this.controls.target) {
            console.error("CameraDirector.startCruise: this.controls or this.controls.target is null/undefined. Cannot start cruise.");
            return;
        }
        STATE.viewMode = 'FOLLOW';
        
        const st = this.state;
        st.currentDrone = Math.floor(this.train.prog * this.config.droneCount) % this.config.droneCount;
        st.fromPos.copy(this.camera.position);
        st.fromTarget.copy(this.controls.target);
        this.getDronePosition(st.currentDrone, this.train.prog, st.toPos, st.toTarget);
        st.switching = true;
        st.switchT = 0;
    },
    
    // èšç„¦ç¤¼ç›’
    focusGift() {
        STATE.viewMode = 'FOCUS_GIFT';
    },

    // åº†ç¥è§†è§’ (ç©¿è¶Šæœºæ‹‰å›)
    celebrate() {
        STATE.viewMode = 'CELEBRATION';
    }
};

// ğŸµ BGM æ—‹å¾‹æ•°æ® (Jingle Bells)
const BGM_MELODY = (() => {
    // æ ‡å‡†éŸ³é«˜ (Cå¤§è°ƒ)
    const N = { 
        G3:196, A3:220, B3:247, 
        C4:262, D4:294, E4:330, F4:349, G4:392, A4:440, B4:494, 
        C5:523, D5:587, E5:659 
    };
    // åŸºç¡€æ‹é€Ÿ
    const Q = 360, H = 720, W = 1080;
    
    return [
        // === ä¸»æ­Œ Verse ===
        {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.B3,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
        {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q},
        {n:N.A4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:H}, {n:N.G4,d:H},
        // === å‰¯æ­Œ Chorus ===
        {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
        {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
        {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
        {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
        {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
        {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:H}, {n:N.G4,d:H},
        {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
        {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
        {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
        {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
        {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
        {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:W}, {n:0,d:W}
    ];
})();

class AudioEngine {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.nextChug = 0;
        this.bgmTimer = null;
        this.isBgmPlaying = false;
        this.lastNoiseVal = 0;

        // ğŸšï¸ é»˜è®¤éŸ³é‡é…ç½®
        this.vol = {
            master: 0.7,    // æ€»éŸ³é‡ç¨å¤§
            bgm: 0.6,       // BGM é€‚ä¸­ï¼Œä¸è¦ç›–è¿‡éŸ³æ•ˆ
            train: 0.8,     // ç«è½¦å£°æ¸…æ™°
            firework: 1.0   // çƒŸèŠ±éœ‡æ’¼
        };
        this.bgmSpeed = 1.0; // BGM æ’­æ”¾é€Ÿåº¦å€ç‡
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // æ··éŸ³é“¾è·¯
            this.nodes.master = this.ctx.createGain();
            this.nodes.bgm = this.ctx.createGain();
            this.nodes.train = this.ctx.createGain();
            this.nodes.fw = this.ctx.createGain();

            this.nodes.bgm.connect(this.nodes.master);
            this.nodes.train.connect(this.nodes.master);
            this.nodes.fw.connect(this.nodes.master);
            this.nodes.master.connect(this.ctx.destination);

            this.updateVols();

            // ç”Ÿæˆé€šç”¨å™ªéŸ³ Buffer (ç”¨äºæ¨¡æ‹Ÿæ°”æµã€çˆ†ç‚¸)
            const bSize = this.ctx.sampleRate * 2;
            this.noiseBuf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const out = this.noiseBuf.getChannelData(0);
            for (let i = 0; i < bSize; i++) {
                // æ··åˆç™½å™ªéŸ³å’Œç²‰çº¢å™ªéŸ³ï¼Œè´¨æ„Ÿæ›´å¥½
                const white = Math.random() * 2 - 1;
                out[i] = (this.lastNoiseVal + (0.02 * white)) / 1.02; // ç®€å•çš„ä½é€šæ»¤æ³¢æ¨¡æ‹Ÿç²‰çº¢å™ªéŸ³
                this.lastNoiseVal = out[i];
                out[i] *= 3.5; // è¡¥å¿éŸ³é‡
            }
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    
    updateVols() {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        this.nodes.master.gain.setTargetAtTime(this.vol.master, t, 0.1);
        this.nodes.bgm.gain.setTargetAtTime(this.vol.bgm, t, 0.1);
        this.nodes.train.gain.setTargetAtTime(this.vol.train, t, 0.1);
        this.nodes.fw.gain.setTargetAtTime(this.vol.firework, t, 0.1);
    }

    setBgmSpeed(speed) {
        this.bgmSpeed = speed;
    }

    // ğŸµ BGM: ç»å¯¹æ ‡å‡†ç‰ˆã€ŠJingle Bellsã€‹ (ä¸»æ­Œ+å‰¯æ­Œå®Œæ•´å¾ªç¯)
    playBGM() {
        if(!this.ctx || this.isBgmPlaying) return;
        this.isBgmPlaying = true;
        
        let idx = 0;
        const playNext = () => {
            if(!this.isBgmPlaying) return;
            const note = BGM_MELODY[idx];
            
            // è®¡ç®—å˜é€Ÿåçš„æ—¶é•¿
            const realDurationMs = note.d / this.bgmSpeed;
            const realDurationSec = realDurationMs / 1000;

            if(note.n > 0) {
                const t = this.ctx.currentTime;
                
                // ğŸ¹ éŸ³è‰²æ ¸å¿ƒï¼šé«˜é¢‘æ³›éŸ³å åŠ 
                const playLayer = (freq, type, vol, decay) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = type;
                    osc.frequency.value = freq;
                    const gain = this.ctx.createGain();
                    gain.connect(this.nodes.bgm);
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(vol, t + 0.01); // æå¿«èµ·éŸ³
                    
                    // decay ä¹Ÿè¦éšé€Ÿåº¦ç¼©æ”¾ï¼Œä¿æŒå¬æ„Ÿä¸€è‡´
                    const realDecay = decay / this.bgmSpeed;
                    gain.gain.exponentialRampToValueAtTime(0.001, t + realDecay);
                    osc.start(t); osc.stop(t + realDecay + 0.1);
                };

                // 1. åŸºéŸ³ (Sine) - æ¸©æš–çš„ä¸»ä½“
                playLayer(note.n, 'sine', 0.6, realDurationSec * 1.5);
                // 2. äºŒæ¬¡è°æ³¢ (Sine) - å¢åŠ åšåº¦
                playLayer(note.n * 2, 'sine', 0.3, realDurationSec * 1.2);
                // 3. æ•²å‡»å£° (Triangle) - ç¬é—´çš„é«˜é¢‘ï¼Œæ¨¡æ‹Ÿæ•²å‡»é‡‘å±ç‰‡ (ç¬æ€ä¸éšé€Ÿåº¦å˜)
                playLayer(note.n * 4, 'triangle', 0.06, 0.1); 
                // 4. ç©ºçµæ„Ÿ (Detuned Sine)
                playLayer(note.n + 5, 'sine', 0.6, realDurationSec);
            }
            this.bgmTimer = setTimeout(playNext, realDurationMs);
            idx = (idx + 1) % BGM_MELODY.length;
        };
        playNext();
    }
    
    stopBGM() { this.isBgmPlaying = false; clearTimeout(this.bgmTimer); }

    // ğŸš‚ åšé‡è’¸æ±½é¸£ç¬› (Steam Blast)
    whistle() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        // è®¾å®šé¸£ç¬›æ—¶é•¿ä¸º 2.5 ç§’ (ä¹‹å‰çš„ 12ç§’å¤ªé•¿äº†ï¼Œä¸çœŸå®)
        const duration = 2.5; 

        const masterGain = this.ctx.createGain();
        masterGain.connect(this.nodes.train);

        // 1. æ ¸å¿ƒéŸ³è°ƒï¼šä½¿ç”¨â€œé”¯é½¿æ³¢â€åŒéŸ³ (æ¨¡æ‹Ÿé“œç®¡å…±é¸£)
        // é¢‘ç‡é€‰æ‹©ï¼šF4 (349Hz) å’Œ G#4 (415Hz) æ„æˆå°ä¸‰åº¦ï¼Œç»å…¸æ±½ç¬›å£°
        [349, 415].forEach(freq => {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth'; // é”¯é½¿æ³¢æ¯”æ­£å¼¦æ³¢æ›´ç²—çŠ·
            
            // åŠ¨æ€é¢‘ç‡ï¼šæ¨¡æ‹Ÿæ°”å‹å†²å‡»ï¼Œèµ·éŸ³æ—¶éŸ³è°ƒå¾®å‡
            osc.frequency.setValueAtTime(freq, t);
            osc.frequency.linearRampToValueAtTime(freq + 5, t + 0.2); 
            osc.frequency.linearRampToValueAtTime(freq, t + duration);

            // ä½é€šæ»¤æ³¢ï¼šå»æ‰é”¯é½¿æ³¢è¿‡äºåˆºè€³çš„é«˜é¢‘ï¼Œè®©å£°éŸ³å˜â€œé—·â€å˜åš
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            osc.connect(filter);
            filter.connect(masterGain);
            
            osc.start(t);
            osc.stop(t + duration + 0.5); // ç•™å‡ºå°¾éŸ³æ—¶é—´
        });

        // 2. å–·æ°”å™ªéŸ³ï¼šæ¨¡æ‹Ÿè’¸æ±½å–·å‡ºçš„â€œå˜¶å˜¶â€å£°
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        
        // å™ªéŸ³æ»¤æ³¢ï¼šåªä¿ç•™ä¸­é¢‘ï¼Œæ¨¡æ‹Ÿåšé‡çš„è’¸æ±½æŸ±ï¼Œè€Œä¸æ˜¯å°–é”çš„æ¼æ°”
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.value = 600; 
        noiseFilter.Q.value = 1.0; // å®½å¸¦
        
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.value = 0.6; // å™ªéŸ³å æ¯”é€‚ä¸­

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(masterGain);
        
        noise.start(t);
        noise.stop(t + duration + 0.5);

        // 3. å…³é”®ä¿®å¤ï¼šADSR åŒ…ç»œ (ä¿æŒéŸ³é‡ï¼)
        masterGain.gain.setValueAtTime(0, t);
        
        // Attack: å¿«é€Ÿè¾¾åˆ°æœ€å¤§éŸ³é‡ (0.2ç§’)
        masterGain.gain.linearRampToValueAtTime(0.8, t + 0.2);
        
        // Sustain: ä¿æŒéŸ³é‡å¹³ç¨³ (ç›´åˆ° duration ç»“æŸ)
        masterGain.gain.setValueAtTime(0.8, t + duration);
        
        // Release: å¿«é€Ÿæ·¡å‡º (0.4ç§’) - æ¨¡æ‹Ÿé˜€é—¨å…³é—­
        masterGain.gain.exponentialRampToValueAtTime(0.001, t + duration + 0.4);
    }

    // ğŸš‚ ç«è½¦å–·æ°”å£°
    chug(speed) {
        if (!this.ctx || speed < 0.01) return;
        const t = this.ctx.currentTime;
        const interval = Math.max(0.1, 1.0 / (speed * 40)); 
        
        if (t >= this.nextChug) {
            this.nextChug = t + interval;
            const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuf;
            
            // ä½é€šæ»¤æ³¢ï¼Œæ¨¡æ‹Ÿé‡ç‰©æ’å‡»
            const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; 
            f.frequency.value = 150 + speed * 1500; 

            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.5 + speed, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); // é•¿ä¸€ç‚¹çš„å°¾éŸ³

            src.connect(f); f.connect(g); g.connect(this.nodes.train);
            src.start(t); src.stop(t + 0.2);
        }
    }

    // ğŸ”” åœ£è¯é“ƒé“›å£°ï¼ˆJingle Bell é£æ ¼ï¼‰
    bell() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;

        // åœ£è¯é“ƒé“›çš„ç‰¹å¾ï¼šæ¸…è„†ã€æ˜äº®ã€æœ‰é‡‘å±å…±é¸£
        // ä½¿ç”¨æ›´é«˜çš„é¢‘ç‡å’Œéè°æ³¢æ³›éŸ³æ¨¡æ‹ŸçœŸå®é“ƒé“›
        const bellFreqs = [
            { f: 2600, vol: 0.25, decay: 0.6 },   // åŸºé¢‘
            { f: 3900, vol: 0.15, decay: 0.4 },   // 1.5å€æ³›éŸ³ï¼ˆéè°æ³¢ï¼Œé“ƒé“›ç‰¹å¾ï¼‰
            { f: 5200, vol: 0.08, decay: 0.3 },   // 2å€æ³›éŸ³
            { f: 6500, vol: 0.04, decay: 0.2 },   // é«˜é¢‘é—ªå…‰
        ];

        bellFreqs.forEach(({ f, vol, decay }) => {
            const osc = this.ctx.createOscillator();
            osc.type = 'sine';
            // è½»å¾®é¢‘ç‡æŠ–åŠ¨ï¼Œæ¨¡æ‹Ÿé“ƒé“›éœ‡åŠ¨
            osc.frequency.setValueAtTime(f, t);
            osc.frequency.exponentialRampToValueAtTime(f * 0.998, t + decay);

            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + decay);

            osc.connect(gain);
            gain.connect(this.nodes.train);
            osc.start(t);
            osc.stop(t + decay + 0.1);
        });

        // æ•²å‡»ç¬æ€ï¼šçŸ­ä¿ƒçš„å™ªéŸ³æ¨¡æ‹Ÿé‡‘å±ç¢°æ’
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 4000;
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(0.08, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.nodes.train);
        noise.start(t);
        noise.stop(t + 0.05);
    }

    // styleIndex: ä¼ å…¥åˆ™é€‰æ‹©ç‰¹å®šé£æ ¼ï¼Œä¸ä¼ åˆ™éšæœº
    explode(styleIndex = -1) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // 1. é€‰æ‹©é£æ ¼
        if (styleIndex === -1) {
            // éšæœºé€‰æ‹©
            styleIndex = Math.floor(Math.random() * SOUND_STYLES.length);
        }
        // é˜²æ­¢è¶Šç•Œ
        const style = SOUND_STYLES[styleIndex % SOUND_STYLES.length];
        
        // éšæœºå£°åƒ (Pan): -0.8(å·¦) ~ 0.8(å³)
        const pan = (Math.random() - 0.5) * 1.6;
        
        // -------------------------------------------
        // å±‚çº§ A: çˆ†è£‚å™ªéŸ³ (Texture Layer)
        // -------------------------------------------
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuf;
        // ç¨å¾®éšæœºä¸€ç‚¹éŸ³è°ƒï¼Œé¿å…æ¯æ¬¡å®Œå…¨ä¸€æ ·
        src.playbackRate.value = 0.8 + Math.random() * 0.4; 

        // æ»¤æ³¢å™¨ (å†³å®šæ˜¯é—·å“è¿˜æ˜¯è„†å“)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = style.noise.q; // å…±æŒ¯å³°
        
        // é¢‘ç‡åŒ…ç»œ
        if (style.noise.slide) {
            // ç§‘å¹»æ•ˆæœï¼šé¢‘ç‡å¿«é€Ÿæ»‘åŠ¨
            filter.frequency.setValueAtTime(style.noise.f * 2, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + style.noise.dur);
        } else {
            // è‡ªç„¶æ•ˆæœï¼šé¢‘ç‡éšæ—¶é—´ç•¥å¾®è¡°å‡
            filter.frequency.setValueAtTime(style.noise.f, t);
            filter.frequency.exponentialRampToValueAtTime(style.noise.f * 0.5, t + style.noise.dur);
        }

        // å£°åƒå®šä½
        const panner = this.ctx.createStereoPanner();
        panner.pan.value = pan;

        // éŸ³é‡åŒ…ç»œ
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, t);
        env.gain.linearRampToValueAtTime(style.noise.vol, t + 0.02); // æå¿«èµ·éŸ³
        env.gain.exponentialRampToValueAtTime(0.01, t + style.noise.dur); // è¡°å‡

        // è¿æ¥ A
        src.connect(filter);
        filter.connect(panner);
        panner.connect(env);
        env.connect(this.nodes.fw);
        
        src.start(t);
        src.stop(t + style.noise.dur + 0.1);

        // -------------------------------------------
        // å±‚çº§ B: ä½é¢‘å†²å‡» (Kick Layer) - ç‰©ç†æ‰“å‡»æ„Ÿ
        // -------------------------------------------
        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // æ­£å¼¦æ³¢æœ€é€‚åˆåšä½éŸ³
        
        // é¢‘ç‡ä¸‹æ½œ (Kickçš„æ ¸å¿ƒ)
        osc.frequency.setValueAtTime(style.kick.f, t);
        osc.frequency.exponentialRampToValueAtTime(1, t + style.kick.dur);
        
        const oscGain = this.ctx.createGain();
        oscGain.gain.setValueAtTime(0, t);
        oscGain.gain.linearRampToValueAtTime(style.kick.vol, t + 0.02);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + style.kick.dur);
        
        // è¿æ¥ B
        osc.connect(oscGain);
        oscGain.connect(this.nodes.fw); // ä¹Ÿè¦è¿åˆ° fw èŠ‚ç‚¹å—æ€»éŸ³é‡æ§åˆ¶
        
        osc.start(t);
        osc.stop(t + style.kick.dur + 0.1);
    }
}

const audio = new AudioEngine();

const CFG = {
    // ğŸš‚ ç‰©ç†
    maxSpeed: 0.10, accel: 0.005, decel: 0.003, wheelMult: 2.0, carriageGap: 0.009,
    
    // ğŸ¥ ç›¸æœº (å¤–ä¾§å‘å¿ƒè§†è§’)
    camHeight: 22,    // ç¨å¾®æŠ¬é«˜ï¼Œé˜²æ­¢ç«è½¦æŒ¡ä½å¤ªå¤šæ ‘çš„æ ¹éƒ¨
    camDist: 85,      // æ‹‰å¤§è·ç¦»ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨å¤–åœˆçœ‹ï¼Œéœ€è¦è§†é‡åŒ…ä½ä¸­å¤®
    camSmooth: 0.02,   // å¢å¤§é˜»å°¼ç³»æ•°ï¼Œè®©è·Ÿéšæ›´ç´§å‡‘ï¼Œå‡å°‘â€œæ‹–æ‹½æ„Ÿâ€å¸¦æ¥çš„æŠ–åŠ¨
    
    // ğŸ’¡ è§†è§‰ä¿®æ­£
    moonInt: 1.0, // æœˆå…‰è°ƒæš—
    fogDen: 0.0016, // é›¾æµ“åº¦è°ƒå¤§
    bloomStr: 0.7,  
    bloomThr: 0.02, 
    lightPow: 100, bulbBri: 30,
    autoFw: true, fwRate: 4
};

const STATE = {
    started: false,
    viewMode: 'FOLLOW', // FOLLOW | FREE
    settings: false,
    interacting: false, // ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨
    running: true, // ç›®æ ‡çŠ¶æ€ï¼šæ˜¯å¦åº”è¯¥è·‘
    curSpeed: 0,   // å½“å‰å®é™…ç‰©ç†é€Ÿåº¦
    clickTime: 0,
    trainDir: Math.random() > 0.5 ? 1 : -1,  // ğŸš‚ éšæœºæ–¹å‘ï¼š1=é¡ºæ—¶é’ˆï¼Œ-1=é€†æ—¶é’ˆ
    forceChristmas : false,    // æµ‹è¯•åœ£è¯èŠ‚å½“æ—¥æ•ˆæœ
    giftPhase: 'NONE', // NONE | FALLING | WAITING | OPENED
    christmasParty: false,
    spawnedGiftsGroup: new THREE.Group() // ç”¨äºç»Ÿä¸€ç®¡ç†æ•£è½çš„ç¤¼ç›’ï¼Œæ–¹ä¾¿ä¸€é”®æ¸…é™¤
};

// â„ï¸ å†°æ™¶ç¥ç¦è¯­ç®¡ç†å™¨ (Crystal Ice Text)
const IceTextManager = {
    mesh: null,
    font: null,
    active: false,
    textGroup: null,
    
    // çŠ¶æ€ç®¡ç†
    state: {
        time: 0,
        opacity: 0,
        targetOpacity: 0
    },

    init(scene) {
        this.scene = scene;
        // å¼‚æ­¥åŠ è½½å­—ä½“ (ä½¿ç”¨ Regular æ›¿ä»£ Boldï¼Œæ›´æŸ”å’Œ)
        const loader = new FontLoader();
        loader.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            this.font = font;
        });
    },

    createGeo(text) {
        if (!this.font) return null;
        const geo = new TextGeometry(text, {
            font: this.font,
            size: 8,
            height: 0.2, // æè–„ï¼Œå‡ ä¹è´´çº¸
            curveSegments: 4,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.05,
            bevelOffset: 0,
            bevelSegments: 2
        });
        geo.center();
        return geo;
    },

    show() {
        if (!this.font) {
            console.warn("IceTextManager: Font not loaded yet.");
            return;
        }
        this.clear(); 
        this.active = true;

        this.textGroup = new THREE.Group();

        // â„ï¸ ç£¨ç ‚å†°é›ªæè´¨ (Frosted/Snowy Ice)
        // æ¨¡æ‹Ÿè¢«é›ªè¦†ç›–çš„æ„Ÿè§‰ï¼šé«˜ç²—ç³™åº¦ï¼Œæ¼«åå°„å¼ºï¼Œä¿ç•™ä¸€ç‚¹ç‚¹é€å…‰
        const matIce = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,       
            metalness: 0.1,
            roughness: 0.8,        // ç²—ç³™ï¼Œåƒç§¯é›ª
            transmission: 0.2,     // ä½é€å…‰
            thickness: 0.5,        
            ior: 1.3,              
            clearcoat: 0.0,        // æ— æ¸…æ¼†ï¼Œä¸åå…‰
            emissive: 0xccddff,    
            emissiveIntensity: 0.3, // å¹½å¹½çš„å†·å…‰
            flatShading: true
        });

        // ğŸ² éšæœºç¥ç¦è¯­
        const rawPhrases = [
            "MERRY CHRISTMAS", "HAPPY HOLIDAYS", "JOY TO THE WORLD", "LET IT SNOW",
            "SEASON'S GREETINGS", "PEACE AND LOVE", "HO HO HO", "MAGIC NIGHT",
            "WINTER WONDERLAND", "FESTIVE SPIRIT"
        ];
        const textStr = rawPhrases[Math.floor(Math.random() * rawPhrases.length)];

        // ğŸ“ æ™ºèƒ½åˆ†è¡Œ
        const words = textStr.split(' ');
        const lines = [];
        let currentLine = words[0];
        const maxCharsPerLine = 10; 

        for (let i = 1; i < words.length; i++) {
            if (currentLine.length + 1 + words[i].length <= maxCharsPerLine) {
                currentLine += " " + words[i];
            } else {
                lines.push(currentLine);
                currentLine = words[i];
            }
        }
        lines.push(currentLine);

        // ç”Ÿæˆå‡ ä½•ä½“
        const lineSpacing = 10.0; 
        const totalHeight = (lines.length - 1) * lineSpacing;
        const startY = totalHeight / 2;

        lines.forEach((lineText, idx) => {
            const geo = this.createGeo(lineText);
            if (geo) {
                const mesh = new THREE.Mesh(geo, matIce);
                // è¿™é‡Œçš„ Y æ˜¯æ–‡å­—è¡Œé«˜æ–¹å‘
                mesh.position.y = startY - (idx * lineSpacing); 
                this.textGroup.add(mesh);
            }
        });

        // ğŸ§Š æ”¾ç½®ï¼šå¹³é“ºåœ¨åœ°ä¸Š (Flat on ground)
        // y=0.15 å¾®å¾®éœ²å‡ºé›ªé¢ï¼ŒRotation X = -90åº¦
        this.textGroup.position.set(0, 0.15, 30); 
        this.textGroup.rotation.x = -Math.PI / 2; 
        
        this.scene.add(this.textGroup);
    },

    update(dt) {
        // é™æ€å±•ç¤ºï¼Œä¸éœ€è¦æ¯å¸§æ›´æ–° (No pulsing)
    },

    hide() {
        this.active = false;
        if (this.textGroup) {
            // ç®€å•çš„æ·¡å‡ºé€»è¾‘äº¤ç»™ clearï¼Œè¿™é‡Œç›´æ¥ç§»é™¤
            this.clear();
        }
    },

    clear() {
        if (this.textGroup) {
            this.scene.remove(this.textGroup);
            this.textGroup.traverse(c => {
                if (c.isMesh) {
                    if (c.geometry) c.geometry.dispose();
                    if (c.material) c.material.dispose();
                }
            });
            this.textGroup = null;
        }
        this.active = false;
    }
};

// ğŸ å·¨å‹ç¤¼ç›’ç®¡ç†å™¨
const MegaGiftManager = {
    mesh: null,
    glowMesh: null,
    scale: 0,
    targetScale: 15,
    y: 200,
    velY: 0,
    physicsItems: [], 
    spotLights: [], // èˆå°ç¯å…‰ç»„
    lightsFading: false, // ç¯å…‰æ·¡å‡ºæ ‡å¿—
    
    init(scene) {
        this.scene = scene;
        scene.add(STATE.spawnedGiftsGroup);
        
        // é¢„åˆ›å»ºå…‰æŸèµ„æº
        this.beamGeo = new THREE.ConeGeometry(8, 120, 32, 1, true);
        this.beamGeo.translate(0, -60, 0); 
        this.beamMat = new THREE.MeshBasicMaterial({
            color: 0x886633, 
            transparent: true,
            opacity: 0,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        this.beamClosing = false;
    },

    spawn() {
        if (STATE.giftPhase !== 'NONE') return;
        STATE.giftPhase = 'FALLING';
        
        this.velY = 0;
        this.lightsFading = false;
        
        // 1. åˆ›å»ºç¤¼ç›’æ¨¡å‹
        const grp = new THREE.Group();
        
        // æ ¸å¿ƒç›’å­ - å¢åŠ é‡‘è¾¹å’Œé«˜çº§æ„Ÿ
        const size = this.targetScale;
        const matBody = new THREE.MeshStandardMaterial({ 
            color: 0xaa0000, 
            roughness: 0.2, 
            metalness: 0.4,
            emissive: 0x440000,
            emissiveIntensity: 0.2
        });
        const box = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), matBody);
        box.castShadow = true;
        
        // å¢åŠ é‡‘è¾¹è£…é¥°
        // åªæœ‰çº¿æ¡†
        const edges = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size)), 
            new THREE.LineBasicMaterial({ color: 0xffd700 })
        );
        grp.add(edges);

        // é‡‘è‰²ä¸å¸¦ - æ›´å®½
        const matGold = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            roughness: 0.15, 
            metalness: 0.9,
            emissive: 0xaa6600,
            emissiveIntensity: 0.2
        });
        const ribbonW = size * 0.25;
        const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(size*1.02, size, ribbonW), matGold);
        const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(ribbonW, size, size*1.02), matGold);
        
        // è´è¶ç»“ - æ›´ç»†è‡´
        const bow = new THREE.Group();
        bow.position.y = size * 0.5;
        
        const bowGeo = new THREE.TorusGeometry(size*0.3, size*0.1, 16, 32);
        const b1 = new THREE.Mesh(bowGeo, matGold); 
        b1.position.set(size*0.25, size*0.25, 0); 
        b1.rotation.z = -Math.PI/4;
        
        const b2 = new THREE.Mesh(bowGeo, matGold); 
        b2.position.set(-size*0.25, size*0.25, 0); 
        b2.rotation.z = Math.PI/4;
        
        // å‚ä¸‹çš„ä¸å¸¦å°¾å·´
        const tailGeo = new THREE.BoxGeometry(size*0.15, size*0.8, size*0.05);
        
        const t1 = new THREE.Mesh(tailGeo, matGold); 
        t1.position.set(size*0.3, 0, size*0.3); 
        t1.rotation.set(0.5, 0, -0.5);
        
        const t2 = new THREE.Mesh(tailGeo, matGold);
        t2.position.set(-size*0.3, 0, size*0.3); 
        t2.rotation.set(0.5, 0, 0.5);

        const knot = new THREE.Mesh(new THREE.SphereGeometry(size*0.18), matGold);
        bow.add(b1, b2, t1, t2, knot);

        grp.add(box, ribbon1, ribbon2, bow);
        
        // å†…éƒ¨å‘¼å¸ç¯
        const glowGeo = new THREE.BoxGeometry(size*0.95, size*0.95, size*0.95);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0 });
        this.glowMesh = new THREE.Mesh(glowGeo, glowMat);
        grp.add(this.glowMesh);

        this.mesh = grp;
        this.mesh.position.set(0, this.y, 0);
        this.scene.add(this.mesh);

        // --- ğŸ­ èˆå°ç¯å…‰ç³»ç»Ÿ ---
        this.clearLights(); 

        const targetY = 7.5;
        const configs = [
            { x: 40, y: 60, z: 50, color: 0xffeeb1, intensity: 200 },
            { x: -40, y: 40, z: 50, color: 0xcceeff, intensity: 80 },
            { x: 0, y: 80, z: -40, color: 0xffffff, intensity: 150 }
        ];

        configs.forEach(cfg => {
            const sl = new THREE.SpotLight(cfg.color, 0, 300, 0.6, 0.4, 1);
            sl.position.set(cfg.x, cfg.y, cfg.z);
            sl.target.position.set(0, targetY, 0);
            sl.castShadow = false; 
            sl.userData = { targetIntensity: cfg.intensity };
            this.scene.add(sl);
            this.scene.add(sl.target);
            this.spotLights.push(sl);
        });

        this.beamMat.opacity = 0;
        this.beamClosing = false;
        this.beam = new THREE.Mesh(this.beamGeo, this.beamMat);
        this.beam.position.set(0, 100, 0);
        this.scene.add(this.beam);

        CameraDirector.focusGift();
    },

    update(dt, time) {
        // --- 1. ç¯å…‰åŠ¨ç”» ---
        if (this.spotLights.length > 0) {
            if (this.lightsFading) {
                let allDone = true;
                this.spotLights.forEach(sl => {
                    if (sl.intensity > 1) {
                        sl.intensity = THREE.MathUtils.lerp(sl.intensity, 0, dt * 1.5);
                        allDone = false;
                    } else {
                        sl.intensity = 0;
                    }
                });
                if (allDone) this.clearLights();
            } else {
                this.spotLights.forEach(sl => {
                    if (sl.intensity < sl.userData.targetIntensity) {
                        sl.intensity += sl.userData.targetIntensity * dt * 0.8;
                    }
                });
            }
        }

        // å…‰æŸ±åŠ¨ç”»
        if (this.beam) {
            if (this.beamClosing) {
                this.beam.scale.x *= 0.97;
                this.beam.scale.z *= 0.97;
                this.beam.material.opacity *= 0.95;
                if (this.beam.material.opacity < 0.01) {
                    this.scene.remove(this.beam);
                    this.beam = null;
                }
            } else if (this.beam.material.opacity < 0.08) { 
                this.beam.material.opacity += 0.08 * dt * 0.5;
            }
        }

        // --- 2. ç¤¼ç›’æœ¬ä½“æ›´æ–° ---
        if (this.mesh) {
            if (STATE.giftPhase === 'FALLING') {
                this.velY -= 80 * dt; 
                this.mesh.position.y += this.velY * dt;
                
                // æ—‹è½¬ï¼šç©ºä¸­è‡ªç”±æ—‹è½¬
                this.mesh.rotation.x += dt;
                this.mesh.rotation.z += dt * 0.5;

                // ğŸŒŸ è½åœ°é¢„åˆ¤ä¸å§¿æ€è°ƒæ•´
                // å½“é«˜åº¦å°äº 2å€ç›®æ ‡å°ºå¯¸æ—¶ï¼Œå¼€å§‹å¹³æ»‘å›æ­£ X å’Œ Z è½´ï¼Œå‡†å¤‡ç€é™†
                if (this.mesh.position.y < this.targetScale * 2.5) {
                    // ç›®æ ‡æ—‹è½¬ï¼š(0, currentY, 0) - åªä¿ç•™ Y è½´è‡ªæ—‹
                    // ä½¿ç”¨ç®€å•çš„é˜»å°¼é€¼è¿‘
                    this.mesh.rotation.x *= 0.9;
                    this.mesh.rotation.z *= 0.9;
                }

                if (this.mesh.position.y <= this.targetScale/2) {
                    this.mesh.position.y = this.targetScale/2;
                    this.velY = 0;
                    STATE.giftPhase = 'WAITING';
                    
                    // è½åœ°ç¬é—´ï¼šä¸è¦å¼ºåˆ¶ set(0,0,0)ï¼Œè€Œæ˜¯ä¿ç•™ Y è½´è§’åº¦ï¼ŒX/Z å½’é›¶
                    this.mesh.rotation.x = 0;
                    this.mesh.rotation.z = 0;
                    
                    if(camera) camera.position.y -= 2; 
                    audio.explode(1); 
                    
                    // è§¦å‘è½åœ° Squash åŠ¨ç”»
                    this.isSquashing = true;
                    this.scaleTime = 0;
                }
            } else if (STATE.giftPhase === 'WAITING') {
                // ğŸŒŸ è½åœ° Q å¼¹åŠ¨ç”» (Squash & Stretch)
                if (this.isSquashing) {
                    this.scaleTime += dt * 12.0; 
                    const decay = Math.exp(-this.scaleTime * 0.5);
                    // æŒ¯å¹…æ¯”å°ç¤¼ç‰©å°ä¸€ç‚¹ï¼Œä½“ç°é‡é‡æ„Ÿ
                    const wave = Math.sin(this.scaleTime) * 0.25 * decay; 
                    
                    const sy = 1.0 * (1.0 - wave);       
                    const sxz = 1.0 * (1.0 + wave * 0.3); 
                    this.mesh.scale.set(sxz, sy, sxz);

                    if (this.scaleTime > Math.PI * 3) { // ç¨å¾®ä¹…ä¸€ç‚¹
                        this.isSquashing = false;
                        this.mesh.scale.set(1, 1, 1); 
                    }
                } else {
                    // æ­£å¸¸å‘¼å¸å¾…æœº
                    const s = 1.0 + Math.sin(time * 3) * 0.03;
                    this.mesh.scale.set(s, s, s);
                }
                
                if (this.glowMesh) this.glowMesh.material.opacity = 0.2 + Math.sin(time * 5) * 0.2;
            }
        }

        // --- 3. æ›´æ–°å°ç¤¼ç‰©ç‰©ç†ä¸å…‰æ•ˆ ---
        if (this.physicsItems.length > 0) {
            for (let i = this.physicsItems.length - 1; i >= 0; i--) {
                const gift = this.physicsItems[i];
                
                // ç‰©ç† (å¦‚æœå·²è½åœ°åˆ™è·³è¿‡)
                if (!gift.landed) {
                    const justLanded = GiftFactory.updateGiftPhysics(gift, dt, { gravity: 20, groundY: 0.5 });
                    // å¦‚æœåˆšåˆšè½åœ°ï¼Œåˆå§‹åŒ–ä¸€äº›ä¸œè¥¿(å¦‚æœ‰å¿…è¦)
                }
                
                // å…‰æ•ˆï¼šå…ˆå˜æš—ï¼Œå†å‘¼å¸ (Fade Out -> Pulse)
                gift.life += dt;
                let intensity = 0;
                
                // é˜¶æ®µ1: åˆå§‹é«˜äº®å¿«é€Ÿå˜æš— (0~2ç§’)
                if (gift.life < 2.0) {
                    intensity = THREE.MathUtils.lerp(1.0, 0.2, gift.life / 2.0);
                } 
                // é˜¶æ®µ2: éšæœºå‘¼å¸ (2ç§’å)
                else {
                    intensity = 0.2 + Math.sin(time * 3.0 + gift.randomPhase) * 0.15;
                }
                
                // åº”ç”¨äº®åº¦
                if (gift.mesh) {
                    gift.mesh.traverse(c => {
                        if (c.isMesh && c.material.emissive) {
                            c.material.emissiveIntensity = intensity;
                        }
                    });
                }
                
                // æ€§èƒ½ä¿æŠ¤ï¼šè¿‡ä¹…ä¹‹åç§»é™¤ (ä¾‹å¦‚ 60ç§’å) æˆ–è€…é™åˆ¶æ€»æ•°
                // è¿™é‡Œæš‚æ—¶ä¸ç§»é™¤ï¼Œè®©å®ƒä»¬ä¸€ç›´é“ºç€
            }
        }
    },

    _disposeGroup(group) {
        if (!group) return;
        group.traverse(c => {
            if (c.isMesh) {
                if (c.geometry) c.geometry.dispose();
                if (c.material) {
                    if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
                    else c.material.dispose();
                }
            }
        });
    },

    open() {
        if (STATE.giftPhase !== 'WAITING') return;
        STATE.giftPhase = 'OPENED';

        audio.explode(6);
        
        // 1. ç§»é™¤å¤§ç¤¼ç›’å®ä½“
        this.scene.remove(this.mesh);
        this._disposeGroup(this.mesh);
        this.mesh = null;

        // 2. è§¦å‘ç¯å…‰æ·¡å‡º
        this.lightsFading = true;
        this.beamClosing = true;

        const template = GiftFactory.createTemplate({ size: 1.5 });
        const count = 60; 
        
        for(let i=0; i<count; i++) {
             const gift = GiftFactory.cloneWithUniqueMaterials(template);
             gift.position.set(0, 5, 0);
             
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.random() * Math.PI * 0.4; 
             const speed = 20 + Math.random() * 30;
             
             const vx = Math.cos(theta) * Math.sin(phi) * speed;
             const vy = Math.cos(phi) * speed;
             const vz = Math.sin(theta) * Math.sin(phi) * speed;

             // Add glow
             gift.traverse(c => {
                 if (c.isMesh) {
                     c.material.emissive = new THREE.Color(c.material.color);
                     c.material.emissiveIntensity = 1.0; // åˆå§‹æäº®
                     if (c.material.name !== 'gold') {
                          c.material.color.setHSL(Math.random(), 0.9, 0.6);
                          c.material.emissive.copy(c.material.color);
                     }
                 }
             });

             STATE.spawnedGiftsGroup.add(gift);
             
             this.physicsItems.push({
                 mesh: gift,
                 vel: new THREE.Vector3(vx, vy, vz),
                 rotVel: new THREE.Vector3(Math.random(), Math.random(), Math.random()),
                 landed: false,
                 targetY: 0.5,
                 life: 0, // è®¡æ—¶å™¨
                 randomPhase: Math.random() * 100 // éšæœºå‘¼å¸ç›¸ä½
             });
        }

        // 3. æ¿€æ´»ç‹‚æ¬¢æ¨¡å¼
        if (typeof activateChristmasMode === 'function') activateChristmasMode();
        
        // 4. æ˜¾ç¤ºå†°æ™¶ç¥ç¦è¯­
        IceTextManager.show();
        
        // 5. è§¦å‘åº†ç¥è§†è§’ (ç©¿è¶Šæœºæ‹‰å›)
        CameraDirector.celebrate();

        // 6. è‡ªåŠ¨æµç¨‹ï¼šç‹‚æ¬¢ 8ç§’åï¼Œè‡ªåŠ¨å›åˆ°æ— äººæœºè·Ÿæ‹
        setTimeout(() => {
            if (STATE.christmasParty) {
                const trig = document.getElementById('countdown-trigger');
                if(trig) trig.style.display = 'flex';
                CameraDirector.startCruise();
            }
        }, 8000);
    },

    clearLights() {
        if (this.spotLights.length > 0) {
            this.spotLights.forEach(sl => {
                this.scene.remove(sl);
                this.scene.remove(sl.target);
            });
            this.spotLights = [];
        }
    },

    clear() {
        // ç§»é™¤å¤§ç¤¼ç›’
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this._disposeGroup(this.mesh);
            this.mesh = null;
        }
        
        // ç§»é™¤ç¯å…‰
        this.clearLights();

        if (this.beam) {
            this.scene.remove(this.beam);
            if(this.beam.geometry) this.beam.geometry.dispose();
            if(this.beam.material) this.beam.material.dispose();
            this.beam = null;
        }
        // æ¸…ç©ºç‰©ç†åˆ—è¡¨
        this.physicsItems = [];
    }
};

// é‡æ–°æŠŠ rainGifts åŠ å›å…¨å±€ï¼Œç”¨äºç‰©ç†æ¨¡æ‹Ÿ
window.rainGifts = [];

let scene, camera, renderer, composer, controls;
let train, fwMgr, snowMgr, santaSleigh, trackCurve;
let lights={}, bloomPass;
let ground, trackPoints=[];
let autoTimer=null;
let isChristmasUIActive = false; // å…¨å±€ UI çŠ¶æ€é”
const clock = new THREE.Clock();
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const vec3 = new THREE.Vector3();
const emissives = [];

// ğŸ¨ å…¨å±€è£…é¥°ç‰©ç®¡ç†å™¨ - ä½¿ç”¨InstancedMeshä¼˜åŒ–æ€§èƒ½
const DecorManager = {
    // å…±äº«å‡ ä½•ä½“
    geos: {},
    // å…±äº«æè´¨
    mats: {},
    // InstancedMeshå®ä¾‹
    instances: {},
    // è®¡æ•°å™¨
    counts: {},
    // å¤ç”¨å¯¹è±¡ï¼ˆé¿å…æ¯æ¬¡è°ƒç”¨åˆ›å»ºæ–°å¯¹è±¡ï¼‰
    _dummy: null,
    _tempColor: null,
    // æœ€å¤§æ•°é‡é…ç½®ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
    maxCounts: {
        groundGift: 30,      // åœ°é¢ç¤¼ç›’
        snowman: 30,         // é›ªäºº
        lamp: 30,            // è·¯ç¯
    },

    init(sc) {
        this.scene = sc;
        // åˆå§‹åŒ–å¤ç”¨å¯¹è±¡
        this._dummy = new THREE.Object3D();
        this._tempColor = new THREE.Color();

        // åˆå§‹åŒ–å…±äº«å‡ ä½•ä½“ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
        this.geos.snowPatch = new THREE.SphereGeometry(0.5, 6, 4);  // è½¦å¢ç§¯é›ªä¹Ÿç”¨è¿™ä¸ª
        this.geos.giftBox = new THREE.BoxGeometry(1, 1, 1);
        this.geos.giftRibbon = new THREE.BoxGeometry(1.05, 0.15, 1.05);
        this.geos.lampPole = new THREE.CylinderGeometry(0.2, 0.2, 7, 8);
        this.geos.lampBulb = new THREE.SphereGeometry(0.5, 8, 8);

        // åˆå§‹åŒ–å…±äº«æè´¨ï¼ˆä»…ä¿ç•™å®é™…ä½¿ç”¨çš„ï¼‰
        this.mats.snow = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });   // é›ªäºº
        this.mats.white = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });  // ä¸å¸¦
        this.mats.black = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }); // ç¯æ†

        // åˆå§‹åŒ–InstancedMesh (åœ°é¢è£…é¥° - é™æ€)
        this.initGroundDecorations();
    },

    initGroundDecorations() {
        // åœ°é¢ç¤¼ç›’ - ä½¿ç”¨é¡¶ç‚¹é¢œè‰²æ”¯æŒ
        const giftMat = new THREE.MeshStandardMaterial({
            vertexColors: false,
            roughness: 0.3
        });
        this.instances.groundGiftBox = new THREE.InstancedMesh(
            this.geos.giftBox, giftMat, this.maxCounts.groundGift
        );
        this.instances.groundGiftBox.count = 0;
        this.instances.groundGiftBox.castShadow = true;
        this.scene.add(this.instances.groundGiftBox);

        this.instances.groundGiftRibbon = new THREE.InstancedMesh(
            this.geos.giftRibbon, this.mats.white, this.maxCounts.groundGift
        );
        this.instances.groundGiftRibbon.count = 0;
        this.scene.add(this.instances.groundGiftRibbon);

        // é›ªäººèº«ä½“
        this.instances.snowmanLower = new THREE.InstancedMesh(
            new THREE.SphereGeometry(1.2, 10, 10), this.mats.snow, this.maxCounts.snowman
        );
        this.instances.snowmanLower.count = 0;
        this.scene.add(this.instances.snowmanLower);

        this.instances.snowmanUpper = new THREE.InstancedMesh(
            new THREE.SphereGeometry(0.8, 10, 10), this.mats.snow, this.maxCounts.snowman
        );
        this.instances.snowmanUpper.count = 0;
        this.scene.add(this.instances.snowmanUpper);

        // è·¯ç¯æ†
        this.instances.lampPole = new THREE.InstancedMesh(
            this.geos.lampPole, this.mats.black, this.maxCounts.lamp
        );
        this.instances.lampPole.count = 0;
        this.scene.add(this.instances.lampPole);

        // åˆå§‹åŒ–è®¡æ•°
        this.counts.groundGift = 0;
        this.counts.snowman = 0;
        this.counts.lamp = 0;
    },

    // æ·»åŠ åœ°é¢ç¤¼ç›’
    addGroundGift(x, z) {
        if (this.counts.groundGift >= this.maxCounts.groundGift) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡
        const scale = 1.2 + Math.random() * 0.6;
        const rotY = Math.random() * Math.PI;

        // ç›’å­
        d.position.set(x, 0.75 * scale, z);
        d.scale.setScalar(scale);
        d.rotation.set(0, rotY, 0);
        d.updateMatrix();
        this.instances.groundGiftBox.setMatrixAt(this.counts.groundGift, d.matrix);

        // è®¾ç½®éšæœºé¢œè‰² - å¤ç”¨ tempColor
        this._tempColor.setHSL(Math.random(), 0.8, 0.5);
        this.instances.groundGiftBox.setColorAt(this.counts.groundGift, this._tempColor);

        // ä¸å¸¦
        d.updateMatrix();
        this.instances.groundGiftRibbon.setMatrixAt(this.counts.groundGift, d.matrix);

        this.counts.groundGift++;
        this.instances.groundGiftBox.count = this.counts.groundGift;
        this.instances.groundGiftRibbon.count = this.counts.groundGift;
        this.instances.groundGiftBox.instanceMatrix.needsUpdate = true;
        this.instances.groundGiftRibbon.instanceMatrix.needsUpdate = true;
        if (this.instances.groundGiftBox.instanceColor) {
            this.instances.groundGiftBox.instanceColor.needsUpdate = true;
        }
    },

    // æ·»åŠ é›ªäºº
    addSnowman(x, z) {
        if (this.counts.snowman >= this.maxCounts.snowman) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡

        // ä¸‹åŠèº«
        d.position.set(x, 1, z);
        d.scale.setScalar(1);
        d.rotation.set(0, 0, 0);
        d.updateMatrix();
        this.instances.snowmanLower.setMatrixAt(this.counts.snowman, d.matrix);

        // ä¸ŠåŠèº«
        d.position.set(x, 2.5, z);
        d.updateMatrix();
        this.instances.snowmanUpper.setMatrixAt(this.counts.snowman, d.matrix);

        this.counts.snowman++;
        this.instances.snowmanLower.count = this.counts.snowman;
        this.instances.snowmanUpper.count = this.counts.snowman;
        this.instances.snowmanLower.instanceMatrix.needsUpdate = true;
        this.instances.snowmanUpper.instanceMatrix.needsUpdate = true;
    },

    // æ·»åŠ è·¯ç¯
    addLamp(x, z) {
        if (this.counts.lamp >= this.maxCounts.lamp) return;

        const d = this._dummy;  // å¤ç”¨ dummy å¯¹è±¡
        d.position.set(x, 3.5, z);
        d.scale.setScalar(1);
        d.rotation.set(0, 0, 0);
        d.updateMatrix();
        this.instances.lampPole.setMatrixAt(this.counts.lamp, d.matrix);

        // ç¯æ³¡éœ€è¦å•ç‹¬å¤„ç†ï¼ˆå› ä¸ºéœ€è¦å‘å…‰æ•ˆæœï¼‰- ç¯æ³¡æè´¨å…±äº«
        if (!this._bulbMat) {
            this._bulbMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, fog: false });
            this._bulbBaseCol = new THREE.Color(0xffaa00);
        }
        const bulb = new THREE.Mesh(this.geos.lampBulb, this._bulbMat);
        bulb.position.set(x, 7, z);
        bulb.userData = { type: 'bulb', phase: Math.random() * Math.PI, baseCol: this._bulbBaseCol };
        emissives.push(bulb);
        this.scene.add(bulb);

        this.counts.lamp++;
        this.instances.lampPole.count = this.counts.lamp;
        this.instances.lampPole.instanceMatrix.needsUpdate = true;
    },

    // å®Œæˆåˆå§‹åŒ–åè°ƒç”¨
    finalize() {
        // æ›´æ–°æ‰€æœ‰å®ä¾‹çš„è¾¹ç•Œ
        Object.values(this.instances).forEach(inst => {
            if (inst.count > 0) {
                inst.computeBoundingSphere();
            }
        });
    }
};

// è½¦å¢ç§¯é›ªå…±äº«èµ„æºï¼ˆå¤ç”¨ DecorManager çš„å‡ ä½•ä½“å’Œæè´¨ï¼‰
const CarSnowResources = {
    get geo() { return DecorManager.geos.snowPatch; },
    get mat() { return DecorManager.mats.snow; }
};

// ğŸ„ è‹±é›„æ ‘å…±äº«èµ„æº - ä¼˜åŒ–å†…å­˜ä½¿ç”¨
const HeroTreeResources = {
    // æè´¨ï¼ˆè·¨æ‰€æœ‰æ ‘å…±äº«ï¼‰
    mats: null,
    // å‡ ä½•ä½“ï¼ˆè·¨æ‰€æœ‰æ ‘å…±äº«ï¼‰
    geos: null,

    init() {
        // å…±äº«æè´¨
        this.mats = {
            trunk: new THREE.MeshStandardMaterial({ color: 0x4a2e16, roughness: 1.0 }),
            foliage: new THREE.MeshStandardMaterial({ color: 0x0f5515, roughness: 0.8, flatShading: true }),
            red: new THREE.MeshStandardMaterial({ color: 0xe60000, roughness: 0.3 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 }),
            white: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }),
        };

        // å…±äº«å‡ ä½•ä½“
        this.geos = {
            // æ ‘å¹²
            trunk: new THREE.CylinderGeometry(3, 5, 15, 8),
            // è£…é¥°çƒ
            ball: new THREE.SphereGeometry(0.8, 12, 12),
            // æ‹æ–ç³–éƒ¨ä»¶
            caneStick: new THREE.CylinderGeometry(0.12, 0.12, 1.2, 8),
            caneHook: new THREE.TorusGeometry(0.35, 0.12, 8, 16, Math.PI),
            caneStripe: new THREE.TorusGeometry(0.13, 0.02, 4, 8),
            // ç¤¼ç›’éƒ¨ä»¶
            giftBox: new THREE.BoxGeometry(1.0, 1.0, 1.0),
            giftRibbon1: new THREE.BoxGeometry(1.05, 1.0, 0.25),
            giftRibbon2: new THREE.BoxGeometry(0.25, 1.0, 1.05),
            bowLoop: new THREE.TorusGeometry(0.2, 0.08, 6, 12),
            bowKnot: new THREE.BoxGeometry(0.15, 0.15, 0.15),
            // LEDç¯ç 
            bulb: new THREE.SphereGeometry(0.45, 8, 8),
        };
    }
};

// ğŸ å…±äº«ç¤¼ç›’å·¥å‚ - æ¶ˆé™¤ Train å’Œ SantaSleigh çš„é‡å¤ä»£ç 
const GiftFactory = {
    // å…±äº«æè´¨ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
    _mats: null,

    getMats() {
        if (!this._mats) {
            this._mats = {
                red: new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.5 }),
                gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.5 }),
                white: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
            };
        }
        return this._mats;
    },

    /**
     * åˆ›å»ºç¤¼ç›’æ¨¡æ¿
     * @param {Object} options - é…ç½®é€‰é¡¹
     * @param {number} options.size - ç›’å­å°ºå¯¸ (é»˜è®¤ 2)
     * @param {boolean} options.hasKnot - æ˜¯å¦æœ‰è´è¶ç»“ä¸­å¿ƒç»“ (é»˜è®¤ false)
     * @param {string} options.bowMat - è´è¶ç»“æè´¨ 'gold' | 'white' (é»˜è®¤ 'gold')
     */
    createTemplate(options = {}) {
        const { size = 2, hasKnot = false, bowMat = 'gold' } = options;
        const mats = this.getMats();
        const group = new THREE.Group();

        // ç›’å­ä¸»ä½“
        const box = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), mats.red);
        group.add(box);

        // åå­—ä¸å¸¦
        const ribbonThick = size * 0.15;
        const ribbonSize = size * 1.05;
        const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(ribbonSize, ribbonThick, ribbonSize), mats.gold);
        const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(ribbonThick, ribbonSize, ribbonSize), mats.gold);
        group.add(ribbon1, ribbon2);

        // è´è¶ç»“
        const bowRadius = size * 0.2;
        const bowTube = size * 0.06;
        const bowGeo = new THREE.TorusGeometry(bowRadius, bowTube, 6, 12);
        const bowMaterial = bowMat === 'white' ? mats.white : mats.gold;

        const bow1 = new THREE.Mesh(bowGeo, bowMaterial);
        bow1.position.set(size * 0.15, size * 0.55, 0);
        bow1.rotation.z = -Math.PI / 4;

        const bow2 = new THREE.Mesh(bowGeo, bowMaterial);
        bow2.position.set(-size * 0.15, size * 0.55, 0);
        bow2.rotation.z = Math.PI / 4;

        group.add(bow1, bow2);

        // å¯é€‰ï¼šè´è¶ç»“ä¸­å¿ƒç»“
        if (hasKnot) {
            const knot = new THREE.Mesh(new THREE.SphereGeometry(size * 0.1, 8, 8), mats.white);
            knot.position.y = size * 0.5;
            group.add(knot);
        }

        return group;
    },

    /**
     * å…‹éš†ç¤¼ç›’å¹¶ç‹¬ç«‹åŒ–æè´¨ï¼ˆç”¨äºè®¾ç½®ä¸åŒé¢œè‰²ï¼‰
     */
    cloneWithUniqueMaterials(template) {
        const gift = template.clone();
        gift.traverse(child => {
            if (child.isMesh) {
                child.material = child.material.clone();
            }
        });
        return gift;
    },

    // å¤ç”¨å‘é‡ï¼ˆé¿å…æ¯å¸§åˆ›å»ºï¼‰
    _physicsVel: new THREE.Vector3(),

    /**
     * ç»Ÿä¸€çš„ç¤¼ç‰©ç‰©ç†æ›´æ–°
     * @param {Object} giftData - ç¤¼ç‰©æ•°æ® { mesh, vel, rotVel, landed, targetY? }
     * @param {number} dt - æ—¶é—´å¢é‡
     * @param {Object} options - é…ç½®é€‰é¡¹
     * @param {number} options.gravity - é‡åŠ›åŠ é€Ÿåº¦ (é»˜è®¤ 25)
     * @param {number} options.groundY - è½åœ°é«˜åº¦ (é»˜è®¤ 1)
     * @returns {boolean} æ˜¯å¦åˆšåˆšè½åœ°
     */
    updateGiftPhysics(giftData, dt, options = {}) {
        if (giftData.landed) return false;

        const { gravity = 25, groundY = 1 } = options;
        const targetY = giftData.targetY ?? groundY;

        // é‡åŠ›
        giftData.vel.y -= gravity * dt;

        // ä½ç½®æ›´æ–°
        this._physicsVel.copy(giftData.vel).multiplyScalar(dt);
        giftData.mesh.position.add(this._physicsVel);

        // æ—‹è½¬
        giftData.mesh.rotation.x += giftData.rotVel.x;
        giftData.mesh.rotation.y += giftData.rotVel.y;
        giftData.mesh.rotation.z += giftData.rotVel.z;

        // è½åœ°æ£€æŸ¥
        if (giftData.mesh.position.y <= targetY) {
            giftData.mesh.position.y = targetY;
            giftData.landed = true;
            giftData.rotVel.set(0, 0, 0);
            giftData.mesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
            return true; // åˆšåˆšè½åœ°
        }

        return false;
    }
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
    scene.fog = new THREE.FogExp2(0x000000, CFG.fogDen);

    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 4000);
    camera.position.set(0, 150, 150);

    renderer = new THREE.WebGLRenderer({
        antialias: false, powerPreference: "high-performance", depth: true, stencil: false
    });
    renderer.setSize(innerWidth, innerHeight);

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // åˆå§‹åŒ–è£…é¥°ç‰©ç®¡ç†å™¨
    DecorManager.init(scene);
    HeroTreeResources.init();

    buildLights();
    buildTrack();
    buildEnv();

    // å®Œæˆè£…é¥°ç‰©åˆå§‹åŒ–
    DecorManager.finalize();

    MegaGiftManager.init(scene);
    IceTextManager.init(scene);

    const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight, { type: THREE.HalfFloatType, stencilBuffer: false });

    const rp = new RenderPass(scene, camera);
    bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = CFG.bloomThr; 
    bloomPass.strength = CFG.bloomStr; 
    bloomPass.radius = 0.5;

    composer = new EffectComposer(renderer, rt);
    composer.addPass(rp);
    composer.addPass(bloomPass);

    train = new Train(scene, trackCurve);
    fwMgr = new Fireworks(scene);
    snowMgr = new Snow(scene);
    santaSleigh = new SantaSleigh(scene);

    setupControls();

    CameraDirector.init(camera, controls, train, trackCurve);
    setupUI();
    
    document.getElementById('loading').style.display='none';
    animate();
}

// åœ¨ animate å‡½æ•°å¤–ï¼Œç¡®ä¿å®šä¹‰äº†è¿™äº›è¾…åŠ©å˜é‡ï¼Œç”¨äºå¤ç”¨
const _tempCol = new THREE.Color();

function animate() {
    requestAnimationFrame(animate);
    
    // Safety check
    if (!scene || !camera || !renderer) return;

    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // å¦‚æœä¸¤å¸§é—´éš”è¶…è¿‡ 0.1ç§’ï¼ˆæ¯”å¦‚åˆ‡åå°äº†ï¼‰ï¼Œå°±å¼ºåˆ¶æŒ‰ 0.1ç§’è®¡ç®—
    // è¿™æ ·é›ªèŠ±å°±ä¸ä¼šç¬é—´æ‰åˆ°åº•ï¼Œç«è½¦ä¹Ÿä¸ä¼šç¬ç§»
    const deltaTime = dt > 0.1 ? 0.1 : dt; 

    // 1. ç‰©ç†æƒ¯æ€§
    if(STATE.running) {
        // ç‹‚æ¬¢æ¨¡å¼æé€ŸåŠ æˆ (1.5å€)
        const targetMax = STATE.christmasParty ? CFG.maxSpeed * 1.5 : CFG.maxSpeed;
        
        // åŠ é€Ÿé€»è¾‘
        if(STATE.curSpeed < targetMax) {
            STATE.curSpeed += CFG.accel;
            if(STATE.curSpeed > targetMax) STATE.curSpeed = targetMax;
        }
        // å‡é€Ÿé€»è¾‘
        else if(STATE.curSpeed > targetMax) {
            STATE.curSpeed *= 0.98; // æ‘©æ“¦åŠ›å‡é€Ÿ
        }
    } else {
        // åœè½¦é€»è¾‘ï¼šæ‘©æ“¦åŠ›æ¨¡å‹ï¼ˆå¼€å§‹å¿«ï¼Œç»“æŸæ…¢ï¼Œæ›´è‡ªç„¶ï¼‰
        if(STATE.curSpeed > 0.001) {
            STATE.curSpeed *= 0.985; // æ¯å¸§è¡°å‡1.5%
        } else {
            STATE.curSpeed = 0;
        }
    }

    if(train) {
        train.update(deltaTime, STATE.curSpeed);
        // ğŸ„ åœ£è¯ç‹‚æ¬¢ç‰¹æ•ˆï¼šå½©è™¹çƒŸé›¾ + æ’’ç¤¼ç‰©
        if (STATE.christmasParty) {
            const hue = (time * 100) % 360; 
            if (train.smokeMesh && train.smokeMesh.material) {
                train.smokeMesh.material.color.setHSL(hue/360, 1.0, 0.6);
                train.smokeMesh.material.emissive.setHSL(hue/360, 1.0, 0.2);
            }
            if (Math.random() < 0.15) {
                const c = train.cars[Math.floor(Math.random()*train.cars.length)];
                if(train.throwGift(c)) train.flashWindows(c);
            }
        } else if (train.smokeMesh && train.smokeMesh.material && train.smokeMesh.material.color.getHex() !== 0xdddddd) {
             // æ¢å¤é»˜è®¤é¢œè‰²
             train.smokeMesh.material.color.setHex(0xdddddd);
             train.smokeMesh.material.emissive.setHex(0x000000);
        }
    }

    if(fwMgr) fwMgr.update();
    if(snowMgr) snowMgr.update(deltaTime);
    
    if(santaSleigh) {
        santaSleigh.update(deltaTime);
        // ğŸ„ åœ£è¯ç‹‚æ¬¢ç‰¹æ•ˆï¼šåœ£è¯è€äººç–¯ç‹‚åŠ ç­
        if (STATE.christmasParty && !santaSleigh.active && santaSleigh.nextTrigger > santaSleigh.elapsed + 15) {
             santaSleigh.nextTrigger = santaSleigh.elapsed + 10 + Math.random() * 5;
        }
    }

    // ğŸ å·¨å‹ç¤¼ç›’æ›´æ–° (å«å°ç¤¼ç‰©ç‰©ç†)
    MegaGiftManager.update(deltaTime, time);
    IceTextManager.update(deltaTime);

    // ç¯å…‰åŠ¨ç”»
    emissives.forEach(obj => {
        if(obj.userData.type === 'led_instanced') {
            const data = obj.userData.data;
            for(let i=0; i<obj.count; i++) {
                const item = data[i];
                const val = Math.sin(time * item.speed + item.offset);
                const intensity = 0.5 + 1.25 * (val + 1); 
                _tempCol.copy(item.baseCol).multiplyScalar(intensity);
                obj.setColorAt(i, _tempCol);
            }
            if(obj.instanceColor) obj.instanceColor.needsUpdate = true;
        }
        if(obj.userData.type === 'bulb' && obj.userData.baseCol) {
            const blink = 0.6 + 0.4 * Math.sin(time * 3.0 + obj.userData.phase);
            const intensity = 1.0 + blink * (CFG.bulbBri / 8); 
            obj.material.color.copy(obj.userData.baseCol).multiplyScalar(intensity);
        }
        if(obj.userData.type === 'star') obj.material.color.setHSL(0.14, 1.0, 0.6 + 0.3 * Math.sin(time));
        if(obj.userData.type === 'headlight_spot') obj.intensity = CFG.lightPow;
    });

    // ğŸ¥ ç›¸æœºæ›´æ–°å§”æ‰˜ç»™å¯¼æ¼”ç³»ç»Ÿ
    CameraDirector.update(deltaTime);

    controls.update();
    composer.render();
}

function buildLights() {
    const moon = new THREE.DirectionalLight(0xaaccff, CFG.moonInt);
    // è°ƒæ•´æœˆå…‰ä½ç½®ï¼šæ›´ä½ã€æ›´ä¾§å‘ï¼Œåˆ¶é€ é•¿é˜´å½±
    moon.position.set(-150, 80, -150);
    moon.castShadow=true; 
    moon.shadow.mapSize.set(1024,1024);
    moon.shadow.camera.left=-400; moon.shadow.camera.right=400;
    moon.shadow.camera.top=400; moon.shadow.camera.bottom=-400;
    scene.add(moon); lights.moon = moon;

    // æœˆäº®å®ä½“ï¼šè¶…çº§æœˆäº®æ•ˆæœï¼ŒæŒ‚åœ¨å¤©è¾¹ (æ¨è¿œä»¥æ¶ˆé™¤è§†å·®ï¼Œé˜²æ­¢è‡ªç”±æ¨¡å¼ç©¿å¸®)
    const mMesh = new THREE.Mesh(new THREE.SphereGeometry(120,32,32), new THREE.MeshBasicMaterial({color:0xffffee, fog:false}));
    mMesh.position.set(-2000, 600, -2000); 
    scene.add(mMesh);

    // æ˜Ÿç©º
    const sg = new THREE.BufferGeometry();
    const sp = [];
    for(let i=0;i<3000;i++) {
        const r=800+Math.random()*200;
        const th=Math.random()*Math.PI*2;
        const ph=Math.acos(2*Math.random()-1);
        if(Math.cos(ph)<0) continue; // åªåœ¨å¤©ä¸Š
        sp.push(r*Math.sin(ph)*Math.cos(th), Math.abs(r*Math.cos(ph)), r*Math.sin(ph)*Math.sin(th));
    }
    sg.setAttribute('position', new THREE.Float32BufferAttribute(sp,3));
    scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff, size:1.5, transparent:true, opacity:0.8, fog:false})));

    scene.add(new THREE.AmbientLight(0x303050, 0.4));
    
    // â›°ï¸ åœ°é¢åœ°å½¢ (Terrain)
    // ä½¿ç”¨é«˜ç»†åˆ†å¹³é¢æ¨¡æ‹Ÿèµ·ä¼é›ªåœ°
    const groundGeo = new THREE.PlaneGeometry(2000, 2000, 128, 128);
    const pos = groundGeo.attributes.position;
    
    // ç®€å•çš„ä¼ªéšæœºå™ªå£°ç”Ÿæˆå±±ä¸˜
    for(let i=0; i<pos.count; i++){
        const x = pos.getX(i);
        const y = pos.getY(i); // Planeå¹³æ”¾å‰æ˜¯XYå¹³é¢ï¼Œæ‰€ä»¥è¿™é‡ŒYå¯¹åº”ä¸–ç•ŒZ
        
        // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„è·ç¦»
        const dist = Math.sqrt(x*x + y*y);
        
        // æ ¸å¿ƒé€»è¾‘ï¼šè½¨é“é™„è¿‘ (R=120) ä¿æŒå¹³å¦ï¼Œè¿œå¤„èµ·ä¼
        // å¹³å¦åŒºï¼šR < 150
        // è¿‡æ¸¡åŒºï¼š150 < R < 250
        // å±±ä¸˜åŒºï¼šR > 250
        
        let height = 0;
        
        if (dist > 150) {
            // åŸºç¡€æ³¢æµª (å¤§å±±ä¸˜)
            const h1 = Math.sin(x * 0.005) * Math.cos(y * 0.005) * 30;
            // ç»†èŠ‚æ³¢æµª (å°èµ·ä¼)
            const h2 = Math.sin(x * 0.02 + y * 0.01) * 5;
            
            height = h1 + h2;
            
            // è¿‡æ¸¡å¹³æ»‘
            if (dist < 250) {
                const alpha = (dist - 150) / 100;
                height *= alpha; 
            }
        }
        
        // è®¾ç½® Z (å¯¹åº” Plane çš„æ³•å‘ï¼Œå³ä¸–ç•Œ Y)
        pos.setZ(i, height - 2.0); // æ•´ä½“ç¨å¾®ä¸‹æ²‰ä¸€ç‚¹ï¼Œé¿å…é®æŒ¡é“è½¨
    }
    
    groundGeo.computeVertexNormals();
    
    ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({
        color: 0xeef2f3, // é›ªç™½ç•¥å¸¦ç°
        roughness: 1.0, 
        metalness: 0.0
    }));
    ground.rotation.x = -Math.PI/2; 
    ground.receiveShadow = true;
    scene.add(ground);
}

function buildTrack() {
    const points = [];
    const segments = 12; 
    
    const BaseR = 120; 
    const Amp = 50; 

    // å…³é”®ä¿®æ”¹ï¼šç”Ÿæˆéšæœºç§å­ï¼Œè®©ä¸‰ä¸ªå¶ç‰‡çš„å¤§å°æ¯æ¬¡éƒ½ä¸å¤ªä¸€æ ·
    // r1, r2, r3 åˆ†åˆ«å½±å“ä¸‰ä¸ªå¶ç‰‡çš„ "çªå‡ºç¨‹åº¦"
    const r1 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r2 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r3 = 1.0 + (Math.random() - 0.5) * 0.4;

    for (let i = 0; i < segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        
        // å…³é”®ä¿®æ”¹ï¼šæ ¹æ®è§’åº¦é€‰æ‹©ä¸åŒçš„éšæœºç³»æ•°
        let randomScale = 1.0;
        // ç®€å•åˆ¤æ–­è§’åº¦è½åœ¨å“ªä¸ªå¶ç‰‡åŒºé—´ (0~2PI åˆ†ä¸‰æ®µ)
        if (theta < 2) randomScale = r1;
        else if (theta < 4) randomScale = r2;
        else randomScale = r3;

        // å…¬å¼ï¼šåŸºç¡€åŠå¾„ + (æŒ¯å¹… * éšæœºç³»æ•° * ä¸‰å¶è‰å½¢çŠ¶) + å¾®å°æŠ–åŠ¨
        const r = BaseR + (Amp * randomScale * Math.sin(3 * theta));
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        points.push(new THREE.Vector3(x, 0, z));
    }

    trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.4); 
    trackPoints = trackCurve.getPoints(1000);

    const divs = 600;
    const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 4.2, 8, true), new THREE.MeshStandardMaterial({color:0x080808, roughness:1}));
    bed.position.y = 0.1; bed.scale.y = 0.1; scene.add(bed);
    
    const pg = new THREE.BoxGeometry(6, 0.4, 1.2); 
    const pm = new THREE.MeshStandardMaterial({color:0x3e2723});
    const pi = new THREE.InstancedMesh(pg, pm, divs);
    const dum = new THREE.Object3D();
    for(let i=0; i<divs; i++){
        const t = i/divs; const p = trackCurve.getPointAt(t); const tan = trackCurve.getTangentAt(t);
        dum.position.set(p.x, 0.3, p.z); dum.lookAt(p.x + tan.x, 0.3, p.z + tan.z); dum.updateMatrix();
        pi.setMatrixAt(i, dum.matrix);
    }
    pi.receiveShadow = true; scene.add(pi);

    // --- ä¿®å¤ï¼šåŒè½¨ç”Ÿæˆé€»è¾‘ ---
    // é—®é¢˜æ ¹æºï¼šExtrudeGeometry ä¼šè‡ªåŠ¨æ—‹è½¬åæ ‡ç³»ï¼Œå¯¼è‡´é“è½¨å˜æˆäº†ä¸Šä¸‹æ’åˆ—è€Œä¸æ˜¯å·¦å³æ’åˆ—
    // è§£å†³æ–¹æ¡ˆï¼šæ‰‹åŠ¨è®¡ç®—ä¸¤æ¡å¹³è¡Œäºåœ°é¢çš„è·¯å¾„
    
    const railPointsL = [];
    const railPointsR = [];
    const railSamp = 400;
    const dist = 2.2; // è½¨è·

    // é¢„åˆ†é…å¤ç”¨å¯¹è±¡ï¼Œå‡å°‘ GC å‹åŠ›
    const upVec = new THREE.Vector3(0, 1, 0);
    const rightVec = new THREE.Vector3();
    const tempL = new THREE.Vector3();
    const tempR = new THREE.Vector3();

    for(let i=0; i<=railSamp; i++) {
        const t = i / railSamp;
        const pt = trackCurve.getPointAt(t);
        const tan = trackCurve.getTangentAt(t);

        // å¤ç”¨ rightVec è®¡ç®—å³ä¾§å‘é‡
        rightVec.crossVectors(tan, upVec).normalize();

        // ç”Ÿæˆå·¦å³åæ ‡ç‚¹
        tempL.copy(pt).addScaledVector(rightVec, -dist);
        tempR.copy(pt).addScaledVector(rightVec, dist);
        railPointsL.push(tempL.clone());
        railPointsR.push(tempR.clone());
    }

    // 4. åˆ›å»ºä¸¤æ¡å¹³è¡Œçš„æ›²çº¿å¯¹è±¡
    const curveL = new THREE.CatmullRomCurve3(railPointsL, true, 'catmullrom', 0.4);
    const curveR = new THREE.CatmullRomCurve3(railPointsR, true, 'catmullrom', 0.4);
    
    const railMat = new THREE.MeshStandardMaterial({
        color: 0x555555, 
        metalness: 0.8, 
        roughness: 0.4
    });

    // 5. ä½¿ç”¨æœ€ç¨³å¦¥çš„ TubeGeometry ç”Ÿæˆå®ä½“
    // 0.12 æ˜¯é“è½¨ç²—ç»†ï¼Œ8 æ˜¯æˆªé¢åœ†æ»‘åº¦
    const railMeshL = new THREE.Mesh(new THREE.TubeGeometry(curveL, railSamp, 0.12, 8, true), railMat);
    const railMeshR = new THREE.Mesh(new THREE.TubeGeometry(curveR, railSamp, 0.12, 8, true), railMat);
    
    // 6. è°ƒæ•´é«˜åº¦
    // æ•æœ¨é¡¶é¢çº¦ 0.5ï¼Œé“è½¨è®¾ä¸º 0.56ï¼Œåˆšå¥½å‹åœ¨æ•æœ¨ä¸Š
    railMeshL.position.y = 0.56;
    railMeshR.position.y = 0.56;

    scene.add(railMeshL);
    scene.add(railMeshR);
}

function buildEnv() {
    // 1. ä¸‹æ–¹æ”¾ç½®å¤§å·è‹±é›„æ ‘ (é…åˆå¤§åœ†å¼§)
    createHeroTree(0, -90, 2.8); 
    
    // 2. å·¦ä¸Šå’Œå³ä¸Šæ”¾ç½®å°å·è‹±é›„æ ‘
    createHeroTree(85, 55, 1.4); 
    createHeroTree(-85, 55, 1.4);

    // ğŸŒ² å‡çº§ç‰ˆæ£®æ— (Varied Forest)
    const matTree = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.9}); // ä½¿ç”¨ç™½è‰²åº•ï¼Œé  instanceColor æŸ“è‰²
    const matSnow = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.6}); 
    
    const count = 1200; // å¢åŠ æ•°é‡ï¼Œå› ä¸ºæœ‰äº†åœ°å½¢
    
    // æˆ‘ä»¬ä¸å†åˆ†ä¸‰å±‚ Meshï¼Œè€Œæ˜¯æŠŠä¸€æ£µæ ‘åˆå¹¶æˆä¸€ä¸ª Geometry æˆ–è€…ä½¿ç”¨ Group (InstancedMesh ä¸æ”¯æŒ Group)
    // ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬ä¿æŒ bot/mid/top åˆ†ç¦»çš„ InstancedMesh ç»“æ„ï¼Œä½†è¦åŒæ­¥å®ƒä»¬çš„å˜æ¢
    
    const meshBot = new THREE.InstancedMesh(new THREE.ConeGeometry(3.5, 5, 7), matTree, count);
    const meshMid = new THREE.InstancedMesh(new THREE.ConeGeometry(2.5, 4, 7), matTree, count);
    const meshTop = new THREE.InstancedMesh(new THREE.ConeGeometry(1.5, 3, 7), matSnow, count); 
    
    meshBot.castShadow=true; meshBot.receiveShadow=true;
    meshMid.castShadow=true; meshMid.receiveShadow=true;
    
    const dummy = new THREE.Object3D();
    const color = new THREE.Color();
    let idx = 0;
    
    // æ ‘æœ¨é¢œè‰²åº“ (å„ç§æ·±æµ…ä¸ä¸€çš„ç»¿è‰²)
    const treeGreens = [0x0f3315, 0x1a4a22, 0x0a2910, 0x2d5a36];

    for(let i=0; i<5000; i++) {
        if(idx >= count) break;
        const r = 160 + Math.random()*800; // æ‰©å¤§èŒƒå›´åˆ°å±±ä¸˜ä¸Š
        const a = Math.random()*6.28;
        const x = Math.cos(a)*r, z = Math.sin(a)*r;
        
        // é¿å¼€è½¨é“ (è½¨é“åŠå¾„ ~120ï¼Œä¿ç•™ç¼“å†²)
        const distSq = 25*25; 
        let safe = true;
        
        // ç®€å•çš„è·ç¦»æ£€æŸ¥
        if (r < 150) safe = false; // è½¨é“åŒº

        if(safe) {
            // è·å–åœ°å½¢é«˜åº¦
            // (è¿™æ˜¯ç®€å•çš„å¤ç”¨ buildLights é‡Œçš„å™ªå£°é€»è¾‘ï¼Œç†æƒ³æƒ…å†µåº”è¯¥å°è£…åœ°å½¢é«˜åº¦å‡½æ•°)
            // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–ï¼šå‡è®¾ y=0ï¼Œç„¶åæ ¹æ® x,z ç®€å•ä¼°ç®—ï¼Œæˆ–è€…ç›´æ¥ raycast (å¤ªæ…¢)
            // æˆ‘ä»¬é‡æ–°è®¡ç®—é«˜åº¦ï¼š
            const dist = Math.sqrt(x*x + z*z);
            let yBase = -2.0;
            if (dist > 150) {
                const h1 = Math.sin(x * 0.005) * Math.cos(z * 0.005) * 30;
                const h2 = Math.sin(x * 0.02 + z * 0.01) * 5;
                let h = h1 + h2;
                if (dist < 250) h *= (dist - 150) / 100;
                yBase = h - 2.0;
            }

            // éšæœºå˜æ¢
            const s = 0.8 + Math.random() * 1.5; 
            const sY = s * (0.8 + Math.random() * 0.6); // é«˜çŸ®èƒ–ç˜¦ä¸ä¸€
            const rotY = Math.random() * Math.PI * 2;
            
            // éšæœºé¢œè‰²
            const baseHex = treeGreens[Math.floor(Math.random() * treeGreens.length)];
            color.setHex(baseHex);
            // ç¨å¾®åŠ ä¸€ç‚¹éšæœºäº®åº¦
            color.offsetHSL(0, 0, (Math.random()-0.5)*0.1);

            // Bot
            dummy.position.set(x, yBase + 2.5*sY, z); 
            dummy.scale.set(s, sY, s); 
            dummy.rotation.y = rotY; 
            dummy.updateMatrix();
            meshBot.setMatrixAt(idx, dummy.matrix);
            meshBot.setColorAt(idx, color);

            // Mid
            dummy.position.set(x, yBase + 5.5*sY, z); 
            dummy.scale.set(s, sY, s); 
            dummy.updateMatrix();
            meshMid.setMatrixAt(idx, dummy.matrix);
            meshMid.setColorAt(idx, color);

            // Top (Snow)
            dummy.position.set(x, yBase + 8.0*sY, z); 
            dummy.scale.set(s, sY, s); 
            dummy.updateMatrix();
            meshTop.setMatrixAt(idx, dummy.matrix);
            // é›ªé¡¶ä¿æŒç™½è‰²ï¼Œæˆ–è€…ç¨å¾®å¸¦ç‚¹ç¯å¢ƒè“
            // meshTop.setColorAt(idx, ...); // é»˜è®¤ç™½

            idx++;
        }
    }
    
    scene.add(meshBot); scene.add(meshMid); scene.add(meshTop);

    // ğŸ¨ è£…é¥°å“ - ä½¿ç”¨DecorManagerä¼˜åŒ–
    for(let i=0; i<30; i++){
        const x=(Math.random()-0.5)*350, z=(Math.random()-0.5)*350;
        let safe=true;
        const r = Math.sqrt(x*x + z*z);
        if(r < 140) safe = false; // é¿å¼€è½¨é“

        if(safe) {
            // ç®€å•ä¼°ç®—é«˜åº¦ (åŒä¸Š)
            let yBase = -2.0;
            if (r > 150) {
                const h1 = Math.sin(x * 0.005) * Math.cos(z * 0.005) * 30;
                const h2 = Math.sin(x * 0.02 + z * 0.01) * 5;
                let h = h1 + h2;
                if (r < 250) h *= (r - 150) / 100;
                yBase = h - 2.0;
            }
            
            // ä¿®æ­£ DecorManager çš„æ–¹æ³•ï¼Œè®©å®ƒä»¬æ”¯æŒ Y è½´åç§»
            // ä½† DecorManager å½“å‰æ˜¯å†™æ­»çš„ Y=0.75 ç­‰ã€‚
            // è¿™æ˜¯ä¸€ä¸ªå°ç¼ºé™·ï¼Œä½†ä¸ºäº†ä¸é‡å†™ DecorManagerï¼Œæˆ‘ä»¬åªèƒ½æ¥å—è£…é¥°å“å¯èƒ½åŠåŸ‹åœ¨é›ªé‡Œ
            // æˆ–è€…æˆ‘ä»¬åªåœ¨å¹³å¦åŒº (150 < r < 250) æ”¾ç½®
            // è®©æˆ‘ä»¬ç®€å•ç‚¹ï¼š
            if (Math.abs(yBase) < 5) { // åªåœ¨ç›¸å¯¹å¹³å¦çš„åœ°æ–¹æ”¾
                 const rn=Math.random();
                 if(rn<0.3) DecorManager.addGroundGift(x,z);
                 else if(rn<0.6) DecorManager.addSnowman(x,z);
                 else DecorManager.addLamp(x,z);
            }
        }
    }
}

function createHeroTree(x, z, scale) {
    const g = new THREE.Group();
    g.position.set(x, 0, z);
    g.scale.set(scale, scale, scale);

    // ä½¿ç”¨å…±äº«èµ„æºå¼•ç”¨ï¼ˆç®€åŒ–ä»£ç ï¼‰
    const { mats, geos } = HeroTreeResources;

    // 1. æ ‘å¹² - ä½¿ç”¨å…±äº«å‡ ä½•ä½“å’Œæè´¨
    const trunk = new THREE.Mesh(geos.trunk, mats.trunk);
    trunk.position.y = 6;
    g.add(trunk);

    const bulbCols = [0xff0000, 0x00ff00, 0x0088ff, 0xffd700, 0xff00ff];

    // ğŸ¬ æ‹æ–ç³– - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    const createCandyCane = () => {
        const cane = new THREE.Group();

        // æ£èº« - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const stick = new THREE.Mesh(geos.caneStick, mats.white);
        stick.position.y = 0.6; // stickH / 2 = 1.2 / 2

        // å¼¯é’© - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const hook = new THREE.Mesh(geos.caneHook, mats.white);
        hook.position.set(0.35, 1.2, 0); // hookRadius, stickH

        // æ£èº«ä¸Šçš„æ¡çº¹ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        for(let i=0; i<5; i++) {
            const stripe = new THREE.Mesh(geos.caneStripe, mats.red);
            stripe.position.y = 0.2 + i * 0.22;
            stripe.rotation.x = Math.PI / 2;
            stripe.rotation.y = 0.3;
            cane.add(stripe);
        }

        // å¼¯é’©ä¸Šçš„æ¡çº¹
        const hookStripes = new THREE.Group();
        hookStripes.position.copy(hook.position);

        for(let i=1; i<4; i++) {
            const angle = (i / 4) * Math.PI;
            const stripe = new THREE.Mesh(geos.caneStripe, mats.red);
            stripe.position.set(Math.cos(angle) * 0.35, Math.sin(angle) * 0.35, 0);
            stripe.rotation.z = angle + Math.PI/2;
            hookStripes.add(stripe);
        }

        cane.add(stick, hook, hookStripes);
        cane.scale.set(1.2, 1.2, 1.2);
        cane.rotation.z = Math.PI / 6;

        return cane;
    };

    // ğŸ å°ç¤¼ç‰© - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    const createMiniGift = () => {
        const boxG = new THREE.Group();
        const mainMat = Math.random() > 0.5 ? mats.red : mats.gold;

        // ç›’å­ä¸»ä½“ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const box = new THREE.Mesh(geos.giftBox, mainMat);

        // åå­—ä¸å¸¦ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
        const r1 = new THREE.Mesh(geos.giftRibbon1, mats.white);
        const r2 = new THREE.Mesh(geos.giftRibbon2, mats.white);

        // è´è¶ç»“
        const bowG = new THREE.Group();
        bowG.position.y = 0.5;

        const b1 = new THREE.Mesh(geos.bowLoop, mats.white);
        b1.position.set(0.15, 0.15, 0);
        b1.rotation.set(0, 0, -Math.PI / 4);

        const b2 = new THREE.Mesh(geos.bowLoop, mats.white);
        b2.position.set(-0.15, 0.15, 0);
        b2.rotation.set(0, 0, Math.PI / 4);

        const knot = new THREE.Mesh(geos.bowKnot, mats.white);

        bowG.add(b1, b2, knot);
        boxG.add(box, r1, r2, bowG);
        boxG.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);

        return boxG;
    };

    const tiers = [
        { r: 24, h: 16, y: 14 }, { r: 20, h: 15, y: 24 },
        { r: 16, h: 14, y: 34 }, { r: 11, h: 12, y: 43 },
        { r: 6,  h: 10, y: 51 }
    ];
    let treeTopY = 0;

    tiers.forEach((tier, index) => {
        const geo = new THREE.ConeGeometry(tier.r, tier.h, 8);
        const mesh = new THREE.Mesh(geo, mats.foliage);
        mesh.position.y = tier.y;
        mesh.rotation.y = (index % 2) * (Math.PI / 8);
        mesh.castShadow = true; mesh.receiveShadow = true;
        g.add(mesh);
        treeTopY = tier.y + tier.h / 2;

        // --- è£…é¥°å“ï¼šä½¿ç”¨å…±äº«å‡ ä½•ä½“ ---
        const decorCount = Math.floor(tier.r * 0.8) + 2;
        for (let k = 0; k < decorCount; k++) {
            const angle = Math.random() * Math.PI * 2;
            const v = 0.1 + Math.random() * 0.5;
            const surfR = tier.r * (1 - v);
            const embed = 0.85 + Math.random() * 0.15;

            const lx = Math.cos(angle) * surfR * embed;
            const lz = Math.sin(angle) * surfR * embed;
            const ly = -tier.h / 2 + v * tier.h;

            const type = Math.random();
            let decor;
            if (type < 0.4) {
                // è£…é¥°çƒ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“
                decor = new THREE.Mesh(geos.ball, Math.random()>.5 ? mats.red : mats.gold);
                decor.position.set(lx, ly, lz);
            } else if (type < 0.7) {
                decor = createMiniGift();
                decor.position.set(lx, ly + 0.5, lz);
                decor.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
            } else {
                decor = createCandyCane();
                decor.position.set(lx, ly, lz);
                decor.lookAt(0, ly, 0);
                decor.rotateX(Math.PI/4);
            }
            mesh.add(decor);
        }
    });

    // --- ğŸŒŸ å®ä½“ç”µçº¿ (éšæœºå¸ƒçº¿é€»è¾‘) ---
    const wirePoints = [];
    wirePoints.push(new THREE.Vector3(0, 2, 2)); // èµ·ç‚¹
    let currentAngle = 0;

    tiers.forEach((tier) => {
        // ç›˜æ—‹ï¼š0.5 ~ 1.5 åœˆ
        const loops = 0.5 + Math.random() * 1.0; 
        const steps = 15; // ç»†åˆ†
        
        for(let s=0; s <= steps; s++) {
            const t = s / steps;
            
            // è§’åº¦æ¨è¿›
            const angleStep = (Math.PI * 2 * loops) / steps;
            currentAngle += angleStep;
            
            // é«˜åº¦ï¼šåœ¨å½“å‰å±‚çˆ¬å‡
            // åªçˆ¬åˆ° 70% é«˜åº¦ï¼Œç•™å‡ºé’»å›å»çš„ç©ºé—´
            const py = (tier.y - tier.h/2) + (tier.h * 0.7) * t;
            
            // åŠå¾„ï¼šä»è¡¨é¢ç¨å¾®æµ®èµ·
            const surfR = tier.r * (1 - t * 0.7); // éšé«˜åº¦å˜ç»†
            const r = surfR * 1.05 + Math.random(); // éšæœºæ¾å¼›
            
            const px = Math.cos(currentAngle) * r;
            const pz = Math.sin(currentAngle) * r;
            wirePoints.push(new THREE.Vector3(px, py, pz));
        }

        // C. é’»å›ï¼šå›åˆ°æ ‘å¹²é™„è¿‘ï¼Œå‡†å¤‡å»ä¸‹ä¸€å±‚
        const endH = tier.y + tier.h/2 - 1;
        wirePoints.push(new THREE.Vector3(2 * Math.cos(currentAngle), endH, 2 * Math.sin(currentAngle)));
    });
    // ç»ˆç‚¹
    wirePoints.push(new THREE.Vector3(0, treeTopY, 0));

    const curve = new THREE.CatmullRomCurve3(wirePoints);
    const tubeGeo = new THREE.TubeGeometry(curve, 300, 0.08, 6, false);
    const wireMesh = new THREE.Mesh(tubeGeo, mats.black); // ä½¿ç”¨å…±äº«æè´¨
    g.add(wireMesh);

    // --- ğŸŒŸ LED ç¯ç  (ç¨€ç–åˆ†å¸ƒ + å±€éƒ¨ç‚¹å…‰æº) ---
    const totalLength = curve.getLength();
    const bulbCountRaw = Math.floor(totalLength * 1.8);

    // LEDæè´¨éœ€è¦ç‹¬ç«‹åˆ›å»ºï¼ˆMeshBasicMaterial ç”¨äºå‘å…‰æ•ˆæœï¼‰
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
    const ledMesh = new THREE.InstancedMesh(geos.bulb, bulbMat, bulbCountRaw); // ä½¿ç”¨å…±äº«å‡ ä½•ä½“
    
    const dummy = new THREE.Object3D();
    const ledData = [];
    let realCount = 0;
    let clusterState = false; 
    let clusterCounter = 0;

    for(let i=0; i<bulbCountRaw; i++) {
        const t = i / bulbCountRaw;
        
        if (clusterCounter <= 0) {
            clusterState = !clusterState;
            clusterCounter = clusterState ? Math.floor(Math.random() * 5 + 4) : Math.floor(Math.random() * 12 + 8);
        }
        clusterCounter--;
        if (!clusterState) continue;

        const pos = curve.getPointAt(t);
        // éšæœºåç§»
        pos.x += (Math.random()-0.5)*0.3;
        pos.y += (Math.random()-0.5)*0.3;
        pos.z += (Math.random()-0.5)*0.3;

        dummy.position.copy(pos);
        dummy.scale.setScalar(1.0);
        dummy.updateMatrix();
        ledMesh.setMatrixAt(realCount, dummy.matrix);
        
        const colHex = bulbCols[Math.floor(Math.random() * bulbCols.length)];
        const color = new THREE.Color(colHex);
        ledMesh.setColorAt(realCount, color);
        
        ledData.push({ id: realCount, baseCol: color, speed: 0.5 + Math.random() * 3.0, offset: Math.random() * 100 });
        realCount++;
    }
    
    ledMesh.count = realCount;
    ledMesh.instanceColor.needsUpdate = true;
    ledMesh.userData = { type: 'led_instanced', data: ledData };
    emissives.push(ledMesh);
    g.add(ledMesh);

    if (scale > 2.0) {
        const innerLight = new THREE.PointLight(0xffaa33, 100, 50);
        innerLight.position.set(0, 15, 0);
        g.add(innerLight);
    }

    // --- ğŸŒŸ æ ‘é¡¶æ˜Ÿæ˜Ÿ (ä¿®å¤ç‰ˆï¼šæ— ç¼ºå£) ---
    const starShape = new THREE.Shape();
    const pts = 5;
    const outerR = 4.2; 
    const innerR = 2.0; 
    // ä»æ­£ä¸Šæ–¹å¼€å§‹ç”» (Angle = -PI/2)
    for (let i = 0; i < pts * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const a = (i / 10) * Math.PI * 2 - Math.PI/2;
        if(i===0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    starShape.closePath();

    // å‡å° bevel é˜²æ­¢è‡ªç›¸äº¤ç¼ºå£
    const starGeo = new THREE.ExtrudeGeometry(starShape, { 
        depth: 1.0, 
        bevelEnabled: true, 
        bevelThickness: 0.1, 
        bevelSize: 0.1, 
        bevelSegments: 1 
    });
    starGeo.center();
    
    const star = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffeb3b, fog: false }));
    star.position.set(0, treeTopY + 3.5, 0);
    star.userData = { type: 'star' }; 
    emissives.push(star); 
    g.add(star);
    
    scene.add(g);
}

class Train {
    constructor(sc, curve) {
        this.sc = sc; // Save scene reference for trails
        this.grp=new THREE.Group(); sc.add(this.grp);
        this.curve=curve; this.prog=0; this.wheels=[]; this.smokes=[];
        this.smokeMax = 30; // Reduced from 50
        this.smokeIdx = 0;
        this.smokeData = [];
        
        // ğŸ› ï¸ GC ä¼˜åŒ–ï¼šé¢„åˆ†é…å‡ ä½•ä½“å’Œæè´¨ (Flyweight Pattern)
        // é¿å…æ¯èŠ‚è½¦å¢éƒ½ new Geometryï¼Œå…±ç”¨ä¸€ä»½èµ„æº
        this.sharedResources = {
            bodyGeo: new THREE.BoxGeometry(3.4, 3.8, 7.8),
            goldBandGeo: new THREE.BoxGeometry(3.45, 0.2, 7.85),
            roofGeo: new THREE.CylinderGeometry(2.05, 2.05, 13, 13, 1, false, 0, Math.PI),
            snowGeo: new THREE.SphereGeometry(0.5, 10, 8), // ä¸“ç”¨ç§¯é›ªï¼šæ›´åœ†æ¶¦ï¼Œæ¶ˆé™¤å…­è¾¹å½¢æ„Ÿ
            winGeo: new THREE.PlaneGeometry(1.3, 1.6),
            borderGeo: new THREE.PlaneGeometry(1.4, 1.7),
            connectorGeo: new THREE.BoxGeometry(2.4, 2.8, 1.2),
            wheelGeo: new THREE.CylinderGeometry(0.65, 0.65, 0.4, 12).rotateZ(Math.PI / 2),
            // [MODIFIED] ä½¿ç”¨ StandardMaterial ä»¥æ”¯æŒå‘å…‰é—ªçƒ (emissive flash)
            winMat: new THREE.MeshStandardMaterial({ 
                color: 0xffcc00, // æ›´æ˜äº®çš„æš–é»„
                emissive: 0xffaa00, 
                emissiveIntensity: 1.0, // æå‡äº®åº¦
                roughness: 0.2, 
                metalness: 0.8 
            })
        };

        const sGeo = new THREE.IcosahedronGeometry(1, 0);
        const sMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd, transparent: true, opacity: 0.6, depthWrite: false, roughness: 1, flatShading: true
        });
        this.smokeMesh = new THREE.InstancedMesh(sGeo, sMat, this.smokeMax);
        this.smokeMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.smokeMesh.frustumCulled = false; // å…³é”®ä¿®å¤ï¼šé˜²æ­¢çƒŸé›¾è¢«é”™è¯¯å‰”é™¤
        this.grp.add(this.smokeMesh);

        // é¢„å…ˆåˆ›å»ºè¾…åŠ©å¯¹è±¡ï¼Œé¿å…åå¤åˆ›å»º
        this.dummy = new THREE.Object3D();
        this._trainDir = new THREE.Vector3(); // å¤ç”¨çš„æ–¹å‘å‘é‡
        this._tempVel = new THREE.Vector3();  // å¤ç”¨çš„é€Ÿåº¦å‘é‡ï¼ˆç”¨äºç‰©ç†æ›´æ–°ï¼‰ 
        this._tempQuat = new THREE.Quaternion(); // çƒŸé›¾å‘å°„å¤ç”¨
        this._tempUp = new THREE.Vector3();

        for(let i=0; i<this.smokeMax; i++) {
            // åˆå§‹ç§»åˆ°æ— é™è¿œ
            this.dummy.position.set(0, -1000, 0); 
            this.dummy.updateMatrix();
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            this.smokeData.push({ active: false, life: 0, vel: new THREE.Vector3(), scale: 1 });
        }

        // Glare
        const cv=document.createElement('canvas'); cv.width=64;cv.height=64;
        const cx=cv.getContext('2d'); const gr=cx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#fff'); gr.addColorStop(1,'transparent'); cx.fillStyle=gr; cx.fillRect(0,0,64,64);
        this.glare=new THREE.CanvasTexture(cv);

        this.loco=this.mkLoco(); this.grp.add(this.loco);
        this.cars=[]; for(let i=1;i<=12;i++) { const c=this.mkCar(i); this.grp.add(c); this.cars.push(c); }
        this.gap();
    }
    gap() { this.cars.forEach((c,i)=>c.userData.off=(i+1)*(0.0075+CFG.carriageGap*0.2)); }
    
    mkLoco() {
        const g = new THREE.Group();
        const matRed = new THREE.MeshStandardMaterial({ color: 0xb71c1c, roughness: 0.3, metalness: 0.1 });
        const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 });
        const matGrey = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
        // é©¾é©¶å®¤çª—æˆ·æè´¨ (æš–å…‰)
        const matWin = new THREE.MeshStandardMaterial({ 
            color: 0xffcc00, 
            emissive: 0xffaa00, 
            emissiveIntensity: 1.0, 
            roughness: 0.2 
        });

        // 1. åº•ç›˜ (Chassis)
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.8, 8.5), matBlack);
        chassis.position.y = 1.2;
        g.add(chassis);

        // 2. æ’éšœå™¨ (Cowcatcher) - å‰ç«¯
        const cowcatcher = new THREE.Group();
        cowcatcher.position.set(0, 0.5, 4.5);
        // æ¥”å½¢ä¸»ä½“
        const wedgeGeo = new THREE.CylinderGeometry(0.1, 1.8, 1.5, 4, 1); 
        wedgeGeo.rotateY(Math.PI/4);
        wedgeGeo.rotateX(Math.PI); 
        wedgeGeo.scale(1.2, 1, 0.5);
        const wedge = new THREE.Mesh(wedgeGeo, matBlack);
        cowcatcher.add(wedge);
        // çº¢è‰²æ¨ªæ¡çº¹
        const strip = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.1, 0.1), matRed);
        strip.position.set(0, 0.2, 0.4);
        cowcatcher.add(strip);
        g.add(cowcatcher);

        // 3. é”…ç‚‰ (Boiler)
        const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 5.5, 24), matRed);
        boiler.rotation.x = Math.PI / 2;
        boiler.position.set(0, 3.2, 1.2);
        g.add(boiler);

        // é”…ç‚‰é‡‘ç¯ (Gold Bands)
        [1.5, -0.5, -2.0].forEach(z => {
            const band = new THREE.Mesh(new THREE.CylinderGeometry(1.55, 1.55, 0.15, 24), matGold);
            band.rotation.x = Math.PI / 2;
            band.position.set(0, 3.2, z + 1.2);
            g.add(band);
        });

        // 4. é©¾é©¶å®¤ (Cab)
        const cabGroup = new THREE.Group();
        cabGroup.position.set(0, 2.5, -2.2);

        // ä¸‹åŠéƒ¨åˆ†
        const cabBase = new THREE.Mesh(new THREE.BoxGeometry(3.6, 2.5, 2.8), matRed);
        cabBase.position.y = 1.25;
        cabGroup.add(cabBase);

        // ä¸ŠåŠéƒ¨åˆ† (é»‘è‰²éƒ¨åˆ†)
        const cabTop = new THREE.Mesh(new THREE.BoxGeometry(3.6, 2.0, 2.8), matRed);
        cabTop.position.y = 3.5;
        cabGroup.add(cabTop);
        
        // çª—æˆ·åŒºåŸŸ (å‘å…‰)
        const winSide = new THREE.Mesh(new THREE.BoxGeometry(3.7, 1.4, 1.8), matWin);
        winSide.position.y = 3.5;
        cabGroup.add(winSide);

        // [FIXED] é©¾é©¶å®¤è½¦é¡¶ (Roof) - ç®€å•çš„åŠåœ†æŸ±
        // åŠå¾„ç¨å¾®å¤§ä¸€ç‚¹è¦†ç›–ä½ï¼Œé•¿åº¦æ²¿Zè½´(2.8+å‡ºæª)
        const roofGeo = new THREE.CylinderGeometry(2.2, 2.2, 3.4, 32, 1, false, 0, Math.PI);
        // é»˜è®¤è½´æ˜¯Yï¼Œæˆ‘ä»¬éœ€è¦è½´æ˜¯Z (è½¦é•¿æ–¹å‘)
        roofGeo.rotateZ(Math.PI / 2); // æ­¤æ—¶è½´æ˜¯X
        roofGeo.rotateY(Math.PI / 2); // æ­¤æ—¶è½´æ˜¯Zï¼Œä¸”å¼€å£å‘ä¸‹
        const cabRoof = new THREE.Mesh(roofGeo, matBlack);
        cabRoof.position.set(0, 4.6, 0); // æ”¾åœ¨é¡¶éƒ¨
        cabGroup.add(cabRoof);

        g.add(cabGroup);

        // 5. [FIXED] çƒŸå›± (Chimney) - æ›´ç¨³å›ºçš„è¿æ¥
        const chimGroup = new THREE.Group();
        chimGroup.position.set(0, 4.5, 3.0); // æ•´ä½“ä¸‹ç§»ä¸€ç‚¹ï¼Œç¡®ä¿æ’å…¥é”…ç‚‰
        
        // çƒŸå›±ç®¡ (åŠ ç²—åŠ é•¿)
        const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8), matBlack);
        pipe.position.y = 0.0; // ä¸­å¿ƒåœ¨ Group åŸç‚¹
        chimGroup.add(pipe);
        
        // é’»çŸ³é¡¶ (åŠ å¤§)
        const stack = new THREE.Mesh(new THREE.ConeGeometry(1.1, 1.4, 16, 1, true), matBlack);
        stack.position.y = 1.4; // æ¥åœ¨ pipe é¡¶ç«¯
        stack.rotation.x = Math.PI; // å€’é”¥
        chimGroup.add(stack);
        
        // é‡‘è‰²é¡¶åœˆ
        const rim = new THREE.Mesh(new THREE.TorusGeometry(1.1, 0.12, 4, 24), matGold);
        rim.position.y = 2.1; // é¡¶ç«¯è¾¹ç¼˜
        rim.rotation.x = Math.PI / 2;
        chimGroup.add(rim);

        g.add(chimGroup);
        this.chim = chimGroup;

        // 6. [IMPROVED] å‰å¤§ç¯ (Headlight) - çœŸå®å†…å‡¹ç»“æ„
        const lightGroup = new THREE.Group();
        lightGroup.position.set(0, 3.2, 4.2);

        // A. ç¯åº§å¤–å£³ (Housing) - åŠ é•¿ä»¥å®¹çº³å†…æ„
        const housing = new THREE.Mesh(new THREE.CylinderGeometry(0.65, 0.65, 1.0, 16).rotateX(Math.PI/2), matBlack);
        housing.position.z = -0.3; // å‘åå»¶ä¼¸
        lightGroup.add(housing);

        // B. åå…‰ç¢— (Reflector) - é“¶è‰²å†…é”¥
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 1.0 });
        const reflector = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.6, 0.5, 16, 1, true).rotateX(Math.PI/2), matSilver);
        reflector.position.z = -0.05; // åµŒåœ¨å£³å†…
        lightGroup.add(reflector);

        // C. é‡‘è‰²ç¯åœˆ (Rim)
        const lightRim = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.08, 4, 24), matGold);
        lightRim.position.z = 0.2;
        lightGroup.add(lightRim);

        // D. ç¯æ³¡ (Bulb) - å†…éƒ¨çš„å°å‘å…‰çƒ
        const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshStandardMaterial({ 
            color: 0xffffee, 
            emissive: 0xffffee,
            emissiveIntensity: 20.0, // æ ¸å¿ƒæäº®
            roughness: 0.1
        }));
        bulb.position.z = -0.1; // è—åœ¨æ·±å¤„
        lightGroup.add(bulb);

        // E. ç»ç’ƒç¯ç½© (Glass Lens) - å‰ç«¯çš„é€æ˜ç›–
        const glassCover = new THREE.Mesh(new THREE.CircleGeometry(0.6, 32), new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            opacity: 0.3, 
            transparent: true, 
            roughness: 0.0, 
            metalness: 0.9 
        }));
        glassCover.position.z = 0.2; // ä¸ç¯åœˆé½å¹³
        lightGroup.add(glassCover);

        // [MODIFIED] å¼ºåŠ›èšå…‰ç¯ (SpotLight)
        // å¼ºåº¦è¿›ä¸€æ­¥æå‡ï¼Œå°„ç¨‹åŠ å¤§
        const sl = new THREE.SpotLight(0xffffee, CFG.lightPow * 12.0, 800, 0.9, 0.4, 1.0);
        sl.position.set(0, 0, 0.5);
        sl.target.position.set(0, -3, 60); 
        sl.castShadow = true;
        sl.shadow.bias = -0.0001;
        sl.shadow.mapSize.width = 1024;
        sl.shadow.mapSize.height = 1024;
        sl.userData = { type: 'headlight_spot' };
        
        // [FIXED] å®šå‘å…‰æ™• (Directional Glare)
        // ä½¿ç”¨é¢å‘å‰æ–¹çš„ PlaneMesh æ›¿ä»£ Spriteã€‚
        // åªæœ‰ä»æ­£é¢çœ‹ï¼ˆæˆ–ä¾§é¢ä¸€å®šè§’åº¦ï¼‰æ‰èƒ½çœ‹åˆ°å…‰æ™•ï¼ŒèƒŒé¢ä¼šè¢«å‰”é™¤ã€‚
        const glareGeo = new THREE.PlaneGeometry(16, 16); // æ›´å¤§
        const glareMat = new THREE.MeshBasicMaterial({ 
            map: this.glare, 
            color: 0xffddaa, 
            transparent: true, 
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.FrontSide // åªæ¸²æŸ“æ­£é¢
        });
        const glareMesh = new THREE.Mesh(glareGeo, glareMat);
        glareMesh.position.z = 0.4;
        lightGroup.add(glareMesh);

        lightGroup.add(sl);
        lightGroup.add(sl.target);
        
        g.add(lightGroup);

        // 7. è½®å­ (Wheels) - å¢åŠ é€£æ† (Side Rods)
        const rodGeo = new THREE.BoxGeometry(0.15, 0.3, 4.5);
        const rodL = new THREE.Mesh(rodGeo, matGrey); rodL.position.set(2.0, 1.3, 1.0);
        const rodR = new THREE.Mesh(rodGeo, matGrey); rodR.position.set(-2.0, 1.3, 1.0);
        g.add(rodL, rodR);

        const addWheel = (z, r, isBig) => {
            const wGeo = new THREE.CylinderGeometry(r, r, 0.5, isBig ? 16 : 12).rotateZ(Math.PI/2);
            const wMat = isBig ? matRed : matBlack; 
            
            const wL = new THREE.Mesh(wGeo, wMat); wL.position.set(1.9, r, z);
            const wR = new THREE.Mesh(wGeo, wMat); wR.position.set(-1.9, r, z);
            
            if (isBig) {
                 const rimGeo = new THREE.TorusGeometry(r, 0.08, 4, 24);
                 const rimL = new THREE.Mesh(rimGeo, matGold); rimL.rotation.y = Math.PI/2; rimL.position.copy(wL.position); rimL.position.x += 0.26;
                 const rimR = new THREE.Mesh(rimGeo, matGold); rimR.rotation.y = Math.PI/2; rimR.position.copy(wR.position); rimR.position.x -= 0.26;
                 g.add(rimL, rimR);
            }

            g.add(wL, wR);
            this.wheels.push(wL, wR);
        };

        addWheel(3.2, 0.9, false);
        addWheel(0.5, 1.5, true);
        addWheel(-2.5, 1.5, true);

        return g;
    }

    mkCar(i) {
        const g = new THREE.Group();
        const cols = [0x8b0000, 0x004d26, 0x003366, 0xb8860b];
        const col = cols[(i - 1) % 4];
        
        const matBody = new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.2 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });

        // 1. è½¦èº« (å…±äº« Geo)
        const body = new THREE.Mesh(this.sharedResources.bodyGeo, matBody);
        body.position.y = 3.3;
        
        // 2. é‡‘è‰²è£…é¥° (å…±äº« Geo)
        const goldBand = new THREE.Mesh(this.sharedResources.goldBandGeo, matGold);
        goldBand.position.y = 3.0; 
        g.add(goldBand);
        
        // 3. è½¦é¡¶ (å…±äº« Geo)
        const roof = new THREE.Mesh(
            this.sharedResources.roofGeo,
            new THREE.MeshStandardMaterial({color:0x222, roughness:0.9}) 
        );
        roof.rotation.set(0, Math.PI/2, Math.PI/2);
        roof.scale.set(1, 0.65, 1);
        
        // ğŸ”§ ä¿®æ­£ï¼šæŠ¬é«˜è½¦é¡¶ä½ç½®
        // è½¦èº« body é«˜åº¦ 3.8ï¼Œä¸­å¿ƒåœ¨ 3.3ï¼Œé¡¶é¢åœ¨ 3.3 + 1.9 = 5.2
        // è½¦é¡¶æ˜¯åŠåœ†æŸ±ï¼Œè½´å¿ƒåº”è¯¥åˆšå¥½åœ¨ 5.2
        const roofBaseY = 5.2;
        roof.position.set(0, roofBaseY, 0);

        // 3.5 è½¦é¡¶ç§¯é›ª - å‡çº§ç‰ˆ (Improved Snow Blanket)
        // 1. åˆ›å»ºé«˜ç»†åˆ†çš„åŸºç¡€å‡ ä½•ä½“
        // [FIX] openEnded: true -> ç§»é™¤ä¸¤ç«¯ç›–å­
        const snowGeo = new THREE.CylinderGeometry(2.05, 2.05, 13, 64, 40, true, 0, Math.PI);
        
        const posAttr = snowGeo.attributes.position;
        const vertex = new THREE.Vector3();
        
        // --- éšæœºæ€§å¢å¼º (Enhanced Randomness) ---
        // ä¸ºæ¯èŠ‚è½¦å¢ç”Ÿæˆå®Œå…¨ä¸åŒçš„å™ªå£°ç‰¹å¾ (Unique noise signature per car)
        // 1. åŸºç¡€é¢‘ç‡å·®å¼‚
        const freqBase = 1.5 + Math.random() * 2.5; // ä¸»æ³¢æµªé¢‘ç‡å˜åŒ–èŒƒå›´å¤§
        const freqDetail = 5.0 + Math.random() * 5.0; // ç»†èŠ‚é¢‘ç‡
        // 2. æŒ¯å¹…å·®å¼‚
        const ampBase = 0.12 + Math.random() * 0.08; 
        const ampDetail = 0.04 + Math.random() * 0.04;
        // 3. ç›¸ä½åç§» (å·¦å³ä¸¤ä¾§ç‹¬ç«‹)
        const phaseL = Math.random() * 100;
        const phaseR = Math.random() * 100;
        // 4. åŸºç¡€åšåº¦å·®å¼‚
        const snowThickBase = 0.2 + Math.random() * 0.08;

        for (let k = 0; k < posAttr.count; k++) {
            vertex.fromBufferAttribute(posAttr, k);
            
            // 1. æ¢å¤åŸå§‹ Theta
            let theta = Math.atan2(vertex.x, vertex.z);
            if (theta < 0) theta += Math.PI * 2;
            
            // --- 2. è®¡ç®—è¾¹ç¼˜å™ªå£° (Complex Edge Noise) ---
            // ä½¿ç”¨å¤šå±‚æ­£å¼¦æ³¢å åŠ  + é¡¶ç‚¹ä½ç½®å“ˆå¸Œï¼Œå½»åº•æ‰“ç ´é‡å¤æ„Ÿ
            
            // å±€éƒ¨å¾®å°å™ªç‚¹ (Micro noise based on position)
            const microNoise = Math.sin(vertex.y * 20 + vertex.x * 10 + k) * 0.02;

            // å·¦ä¾§è¾¹ç¼˜å™ªå£°
            const noiseL = Math.sin(vertex.y * freqBase + phaseL) * ampBase + 
                           Math.sin(vertex.y * freqDetail + phaseL * 1.5) * ampDetail + 
                           Math.sin(vertex.y * 0.5 + phaseL) * 0.05 + // è¶…ä½é¢‘å¤§èµ·ä¼
                           microNoise;

            // å³ä¾§è¾¹ç¼˜å™ªå£° (å‚æ•°ç•¥å¾®ä¸åŒï¼Œé¿å…å·¦å³å¯¹ç§°)
            const noiseR = Math.sin(vertex.y * (freqBase * 1.1) + phaseR) * ampBase + 
                           Math.sin(vertex.y * (freqDetail * 0.9) + phaseR * 1.2) * ampDetail +
                           Math.sin(vertex.y * 0.6 + phaseR) * 0.05 +
                           microNoise;

            // åŠ¨æ€è°ƒæ•´è¦†ç›–èŒƒå›´
            // [Modified] æé«˜è¾¹ç¼˜ï¼šåŸºå‡† 0.3
            const startTheta = 0.3 + Math.abs(noiseL) * 0.6; // å¢åŠ å™ªå£°å½±å“æƒé‡
            const endTheta = Math.PI - (0.3 + Math.abs(noiseR) * 0.6);
            
            // 3. æ˜ å°„ Theta
            const newTheta = startTheta + (theta / Math.PI) * (endTheta - startTheta);
            
            // 4. é‡å»ºä½ç½®
            const r = 2.05;
            vertex.x = r * Math.sin(newTheta);
            vertex.z = r * Math.cos(newTheta);
            
            // 5. åº”ç”¨åšåº¦
            const nx = Math.sin(newTheta);
            const nz = Math.cos(newTheta);
            
            let thick = snowThickBase;
            // è¡¨é¢èµ·ä¼ (Surface Noise) - åŒæ ·å¢å¼ºéšæœºæ€§
            thick += Math.sin(vertex.x * 3 + vertex.y * 1.5 + phaseL) * 0.04; 
            thick += Math.sin(vertex.z * 4 + phaseR) * 0.02;
            thick += microNoise * 0.5; // è¡¨é¢ä¹Ÿå¢åŠ ä¸€ç‚¹å¾®å™ª
            
            // é¡¶éƒ¨åŠ åš
            const distFromTop = Math.abs(newTheta - Math.PI/2);
            thick += 0.12 * Math.max(0, 1.0 - distFromTop / (Math.PI/2)); 

            // è¾¹ç¼˜æ‰“è–„
            const edgeRatio = distFromTop / (Math.PI/2);
            if (edgeRatio > 0.6) {
                thick *= Math.max(0.2, 1.0 - (edgeRatio - 0.6) * 2.0); 
            }

            vertex.x += nx * thick;
            vertex.z += nz * thick;

            // 6. è¾¹ç¼˜å‚è½
            const edgeFactor = Math.pow(Math.max(0, distFromTop / (Math.PI/2)), 6);
            const droop = 0.05 * edgeFactor * (1 + Math.random()*0.2); 
            vertex.x -= droop;

            // 7. å‰åä¸¤ç«¯åœ†æ¶¦åŒ–
            const distFromEnd = 6.5 - Math.abs(vertex.y);
            if (distFromEnd < 0.8) {
                const t = (0.8 - distFromEnd) / 0.8;
                const endDroop = t * t * 0.6; 
                vertex.x -= endDroop;
            }

            posAttr.setXYZ(k, vertex.x, vertex.y, vertex.z);
        }
        
        snowGeo.computeVertexNormals();

        const snowCap = new THREE.Mesh(snowGeo, CarSnowResources.mat);
        snowCap.rotation.set(0, Math.PI/2, Math.PI/2);
        snowCap.scale.set(1, 0.65, 1); 
        snowCap.position.set(0, roofBaseY, 0);

        g.add(snowCap);

        // 4. è½¦çª— (å…±äº« Geo)
        const windows = [];
        for (let side = -1; side <= 1; side += 2) {
            for (let k = 0; k < 3; k++) {
                const w = new THREE.Mesh(this.sharedResources.winGeo, this.sharedResources.winMat.clone()); 
                const border = new THREE.Mesh(this.sharedResources.borderGeo, matGold);

                w.position.set(1.76 * side, 3.8, -2.5 + k * 2.5);
                w.rotation.y = side * Math.PI / 2;
                w.userData.isWindow = true; 
                windows.push(w);

                border.position.copy(w.position);
                border.position.x -= 0.01 * side; 
                border.rotation.copy(w.rotation);

                g.add(border);
                g.add(w);
            }
        }
        g.userData.windows = windows; 

        // 5. è¿æ¥å¤„ & è½®å­ (å…±äº« Geo)
        const gw = new THREE.Mesh(this.sharedResources.connectorGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
        gw.position.set(0, 3, 4.2);

        const ab = z => {
            const gr = new THREE.Group(); gr.position.set(0, 0, z);
            const w = new THREE.Mesh(this.sharedResources.wheelGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
            w.position.set(1.6, 0.65, 0);
            const w2 = w.clone(); w2.position.set(-1.6, 0.65, 0);
            gr.add(w, w2); g.add(gr); this.wheels.push(w, w2);
        };
        ab(2.8); ab(-2.8);

        g.add(body, roof, gw);
        return g;
    }

    update(dt, speed) {
        audio.chug(speed);

        // ğŸš‚ æ”¯æŒåŒå‘è¡Œé©¶ï¼šSTATE.trainDir = 1(é¡ºæ—¶é’ˆ) æˆ– -1(é€†æ—¶é’ˆ)
        const dist = speed * dt * 0.2 * STATE.trainDir;
        this.prog = (this.prog + dist + 1) % 1; // +1 ç¡®ä¿ç»“æœä¸ºæ­£

        this.place(this.loco, this.prog);
        this.cars.forEach(c => {
            // è½¦å¢è·Ÿéšï¼šæ ¹æ®æ–¹å‘å†³å®šåç§»æ–¹å‘
            let t = this.prog - c.userData.off * STATE.trainDir;
            t = ((t % 1) + 1) % 1; // ç¡®ä¿ t åœ¨ [0, 1) èŒƒå›´å†…
            this.place(c, t);
        });

        // è½®å­æ—‹è½¬æ–¹å‘ä¹Ÿè¦éšç«è½¦æ–¹å‘
        this.wheels.forEach(w => w.rotation.x -= dist * 150 * CFG.wheelMult);

        // ğŸ„ ç‹‚æ¬¢æ¨¡å¼ï¼šè½¦å¢æ‘‡æ‘† (Party Rocking)
        if (STATE.christmasParty) {
            const t = clock.getElapsedTime();
            [this.loco, ...this.cars].forEach((obj, i) => {
                // å·¦å³æ‘‡æ‘† (Roll) - å¢åŠ  Z è½´æ—‹è½¬
                obj.rotation.z += Math.sin(t * 18 + i) * 0.08;
                // æ¬¢å¿«è·³åŠ¨ (Bounce) - å¢åŠ  Y è½´ä½ç§»
                obj.position.y += Math.abs(Math.sin(t * 25 + i)) * 0.15;
            });
        }

        // ğŸš‚ çƒŸé›¾ç”Ÿæˆé€»è¾‘ä¼˜åŒ–
        // ç¡®ä¿çŸ©é˜µæ›´æ–°ï¼Œä»¥è·å–å‡†ç¡®çš„çƒŸå›±ä½ç½®
        this.loco.updateMatrixWorld(true);
        this.chim.updateMatrixWorld(true);

        // å†’çƒŸæ¦‚ç‡ï¼šä¿åº• 0.05 (é™æ­¢ä¹Ÿæœ‰å‘¼å¸æ„Ÿ) + é€Ÿåº¦åŠ æˆ
        const smokeProb = 0.05 + Math.min(speed * 5.0, 0.8);

        if(Math.random() < smokeProb) {
            vec3.setFromMatrixPosition(this.chim.matrixWorld);
            // ä»çƒŸå›±é¡¶éƒ¨å–·å‡º (yè½´å‘ä¸Šåç§»)
            vec3.y += 1.2;
            this.spawnSmoke(vec3, speed);
        }

        this.updateSmoke(speed);
        this.updateDroppedGifts(dt);
    }

    spawnSmoke(pos, trainSpeed) {
        const idx = this.smokeIdx;
        const s = this.smokeData[idx];

        s.active = true;
        s.life = 1.0 + Math.random() * 0.5; 
        s.scale = 0.6 + Math.random() * 0.4; 
        s.pos = pos.clone();
        s.trainSpeed = trainSpeed; 

        this.loco.getWorldQuaternion(this._tempQuat);
        this._tempUp.set(0, 1, 0).applyQuaternion(this._tempQuat).normalize();

        // ä¿®æ­£ï¼šå¤§å¹…é™ä½é€Ÿåº¦å¯¹å–·å°„åŠ›åº¦çš„å½±å“ç³»æ•°
        // åŸºç¡€ 2.5ï¼Œæœ€å¤§å¢é‡ä¹Ÿå°± +3.2 (å½“ speed=0.4æ—¶)
        // è¿™æ ·é«˜é€Ÿæ—¶è™½ç„¶å–·å¾—å¿«ï¼Œä½†ä¸ä¼šçªœä¸Šå¤©
        const burstPower = 2.5 + trainSpeed * 8.0; 

        s.vel.copy(this._tempUp).multiplyScalar(burstPower);

        // ä¿®æ­£ï¼šå‡å°éšæœºæ¹æµï¼Œè®©çƒŸæŸ±æ›´å‡èš
        s.vel.x += (Math.random() - 0.5) * 0.6;
        s.vel.z += (Math.random() - 0.5) * 0.6;

        this.smokeIdx = (this.smokeIdx + 1) % this.smokeMax;
    }

    updateSmoke(currentSpeed) {
        let dirty = false;

        // ğŸ’¨ åŠ¨æ€é£åœºè®¡ç®— (Dynamic Wind Field)
        const t = clock.getElapsedTime();
        // åŸºç¡€é£åŠ› + é˜µé£æ‰°åŠ¨ (ä½¿ç”¨ä¸åŒé¢‘ç‡çš„æ­£å¼¦æ³¢å åŠ )
        // æ¨¡æ‹Ÿä¸€é˜µé˜µçš„é£ï¼Œé£å‘å’ŒåŠ›åº¦éšæ—¶é—´å˜åŒ–
        const windX = (Math.sin(t * 0.8) + Math.sin(t * 2.5) * 0.6) * 0.015;
        const windZ = (Math.cos(t * 0.6) + Math.sin(t * 1.9) * 0.6) * 0.015;

        for(let i=0; i<this.smokeMax; i++) {
            const s = this.smokeData[i];
            if(!s.active) continue;

            // 1. åº”ç”¨é£åŠ› (åœ¨é˜»åŠ›ä¹‹å‰åº”ç”¨ï¼Œè®©é£æŒç»­æ¨åŠ¨)
            s.vel.x += windX;
            s.vel.z += windZ;

            // 2. ç‰©ç†è¿åŠ¨
            s.pos.add(s.vel);

            // 3. ç©ºæ°”é˜»åŠ› (Air Resistance)
            // é€Ÿåº¦æå¿«è¡°å‡ï¼Œæ¨¡æ‹Ÿæ’å‡»é™æ­¢ç©ºæ°”
            s.vel.multiplyScalar(0.85); 

            // 4. çƒ­æµ®åŠ› (Buoyancy)
            if (s.vel.y < 0.8) {
                s.vel.y += 0.02; 
            }

            // æ°”ä½“è†¨èƒ€
            const age = 1.0 - (s.life / 1.5); 
            const expansion = 1.0 + age * 3.0; 
            
            s.life -= 0.016;

            if(s.life <= 0) {
                s.active = false;
                this.dummy.position.set(0, -1000, 0);
                this.dummy.updateMatrix();
                this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
                dirty = true;
                continue;
            }

            // æ›´æ–°å˜æ¢
            this.dummy.position.copy(s.pos);
            this.dummy.scale.setScalar(s.scale * expansion);
            this.dummy.rotation.set(age, age, age); 
            this.dummy.updateMatrix();
            
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            dirty = true;
        }

        if(dirty) this.smokeMesh.instanceMatrix.needsUpdate = true;
    }
    place(o, t) {
        const p = this.curve.getPointAt(t);
        const tan = this.curve.getTangentAt(t);
        o.position.copy(p);
        // ğŸš‚ æ ¹æ®è¡Œé©¶æ–¹å‘è°ƒæ•´æœå‘ï¼šé€†æ—¶é’ˆæ—¶ç¿»è½¬åˆ‡çº¿æ–¹å‘
        const dir = STATE.trainDir > 0 ? 1 : -1;
        o.lookAt(p.x + tan.x * dir, p.y + tan.y * dir, p.z + tan.z * dir);
    }

    // ğŸ ä»è½¦å¢æ‰”å‡ºç¤¼ç›’
    throwGift(car) {
        if (!this.droppedGifts) {
            this.droppedGifts = [];
            this.giftCooldown = 0;
            this.buildGiftTemplate();
        }

        // å†·å´æ£€æŸ¥ (Partyæ¨¡å¼æ›´å¿«)
        const cooldownTime = STATE.christmasParty ? 50 : 200;
        if (Date.now() - this.giftCooldown < cooldownTime) return false;
        this.giftCooldown = Date.now();

        // åˆ›å»ºç¤¼ç›’
        const gift = GiftFactory.cloneWithUniqueMaterials(this.giftTemplate);

        // éšæœºé¢œè‰²
        const colors = [0xcc0000, 0x00aa00, 0x0066cc, 0xffaa00];
        const colHex = colors[Math.floor(Math.random() * colors.length)];
        const col = new THREE.Color(colHex);
        
        // è®¾ç½®é¢œè‰²å¹¶å¼€å¯è‡ªå‘å…‰
        gift.traverse(c => {
            if (c.isMesh) {
                // ä¸»ä½“é¢œè‰²
                if (c === gift.children[0]) c.material.color.set(col);
                
                // å¼€å¯å‘å…‰
                c.material.emissive = new THREE.Color(c.material.color);
                c.material.emissiveIntensity = 0.8; // åˆå§‹äº®åº¦
            }
        });

        // ä»è½¦å¢ä¸–ç•Œä½ç½®æ‰”å‡º
        const worldPos = new THREE.Vector3();
        car.getWorldPosition(worldPos);

        // éšæœºé€‰æ‹©å·¦ä¾§æˆ–å³ä¾§ (-1 æˆ– 1)
        const side = Math.random() > 0.5 ? 1 : -1;

        // è·å–è½¦å¢çš„â€œå³â€å‘é‡ (Local X axis)
        const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(car.quaternion);
        
        // è·å–è½¦å¢çš„â€œä¸Šâ€å‘é‡ (Local Y axis)
        const upVec = new THREE.Vector3(0, 1, 0).applyQuaternion(car.quaternion);

        // èµ·å§‹ä½ç½®ï¼šè½¦å¢ä¾§é¢çª—æˆ·é«˜åº¦
        gift.position.copy(worldPos);
        gift.position.addScaledVector(rightVec, side * 2.0); // å‘å¤–åç§»
        gift.position.addScaledVector(upVec, 1.0); // ç¨å¾®å‘ä¸Š
        gift.scale.set(0.5, 0.5, 0.5);

        this.sc.add(gift);

        // è®¡ç®—æŠ›å‡ºé€Ÿåº¦å‘é‡
        // 1. åŸºç¡€ä¾§å‘é€Ÿåº¦ (å‘å¤–)
        const throwVel = rightVec.clone().multiplyScalar(side * (8 + Math.random() * 8)); 
        
        // 2. å‚ç›´åˆ†é‡ (å‘ä¸ŠæŠ›)
        throwVel.add(upVec.clone().multiplyScalar(5 + Math.random() * 5));

        // 3. å‰åéšæœºåˆ†é‡ (é¿å…è½ç‚¹æˆä¸€æ¡ç›´çº¿)
        const forwardVec = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
        throwVel.add(forwardVec.multiplyScalar((Math.random() - 0.5) * 10));

        // æ·»åŠ å°¾è¿¹
        const trail = new GiftParticleTrail(this.sc, colHex);

        this.droppedGifts.push({
            mesh: gift,
            vel: throwVel,
            rotVel: new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            ),
            landed: false,
            trail: trail,
            life: 8.0, // å­˜æ´»æ—¶é—´ (ç”¨äºå‘å…‰è¡°å‡)
            maxLife: 8.0
        });

        return true;
    }

    buildGiftTemplate() {
        // ä½¿ç”¨å…±äº«å·¥å‚åˆ›å»ºå°å·ç¤¼ç›’æ¨¡æ¿
        this.giftTemplate = GiftFactory.createTemplate({ size: 2, bowMat: 'gold' });
    }

    updateDroppedGifts(dt) {
        if (!this.droppedGifts) return;

        // ä½¿ç”¨ç»Ÿä¸€çš„ç‰©ç†æ›´æ–°
        for (const g of this.droppedGifts) {
            const landed = GiftFactory.updateGiftPhysics(g, dt, { gravity: 25, groundY: 1 });
            
            // å‘å…‰è¡°å‡ logic
            if (g.life > 0) {
                g.life -= dt;
                // çº¿æ€§è¡°å‡å‘å…‰å¼ºåº¦
                const intensity = Math.max(0, (g.life / g.maxLife) * 0.8);
                g.mesh.traverse(c => {
                    if (c.isMesh) c.material.emissiveIntensity = intensity;
                });
            }

            // æ›´æ–°å°¾è¿¹
            if (g.trail) {
                // å¦‚æœå·²è½åœ°ï¼Œå°¾è¿¹å¿«é€Ÿæ¶ˆå¤±
                const trailOpacity = g.landed ? 0 : 1.0;
                // å¦‚æœæœªè½åœ°ï¼Œå°¾è¿¹é€æ˜åº¦ä¹Ÿå¯ä»¥éšæ—¶é—´ç•¥å¾®è¡°å‡
                g.trail.update(g.mesh.position, trailOpacity);
                
                // å¦‚æœå·²è½åœ°ä¸”å°¾è¿¹å‡ ä¹ä¸å¯è§ï¼ˆæˆ–ç®€å•åœ°è½åœ°å³é”€æ¯ï¼‰ï¼Œæ¸…ç†å°¾è¿¹
                if (g.landed) {
                     g.trail.dispose();
                     g.trail = null;
                }
            }
        }

        // é™åˆ¶åœ°é¢ç¤¼ç›’æ•°é‡ (å¢åŠ åˆ° 60)
        let removeCount = 0;
        const maxGifts = STATE.christmasParty ? 80 : 30;
        
        while (this.droppedGifts.length > maxGifts && removeCount < 2) {
            removeCount++;
            const oldest = this.droppedGifts.shift();
            scene.remove(oldest.mesh);
            if (oldest.trail) oldest.trail.dispose();

            // ğŸ—‘ï¸ å†…å­˜æ¸…ç†
            oldest.mesh.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        }
    }

    // ğŸ’¡ è½¦å¢çª—æˆ·é—ªçƒæ•ˆæœ
    flashWindows(car) {
        const windows = car.userData.windows;
        if (!windows || windows.length === 0) return;

        // è®°å½•åŸå§‹é¢œè‰²
        const originalColors = windows.map(w => w.material.color.getHex());

        // é—ªçƒåºåˆ—
        let flashCount = 0;
        const maxFlash = 6; // é—ª3æ¬¡ (on-off-on-off-on-off)
        const flashInterval = setInterval(() => {
            const bright = flashCount % 2 === 0;
            windows.forEach(w => {
                if (bright) {
                    // äº®çŠ¶æ€ï¼šé«˜å¼ºåº¦çˆ†é—ª
                    w.material.color.setHex(0xffffff);
                    w.material.emissive.setHex(0xffffff);
                    w.material.emissiveIntensity = 3.0; 
                } else {
                    // æš—çŠ¶æ€ï¼šæ¢å¤é»˜è®¤æš–å…‰ (è€Œä¸æ˜¯å…¨é»‘)
                    w.material.color.setHex(0xffccaa);
                    w.material.emissive.setHex(0xffaa00);
                    w.material.emissiveIntensity = 0.8;
                }
            });
            flashCount++;
            if (flashCount >= maxFlash) {
                clearInterval(flashInterval);
                // æ¢å¤åŸè‰² (é»˜è®¤æš–å…‰)
                windows.forEach((w, i) => {
                    w.material.color.setHex(originalColors[i]);
                    w.material.emissive.setHex(0xffaa00);
                    w.material.emissiveIntensity = 0.8;
                });
            }
        }, 80);
    }
}

class Fireworks {
    constructor(sc) {
        this.sc = sc;
        this.activeRockets = [];

        // çº¹ç†ç”Ÿæˆ
        const c = document.createElement('canvas'); c.width=32; c.height=32;
        const x = c.getContext('2d'); 
        const g = x.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent'); 
        x.fillStyle=g; x.fillRect(0,0,32,32);
        this.tex = new THREE.CanvasTexture(c);
        
        this.cols = [[0xff0000,0xffaa00],[0x00ffff,0x0000ff],[0xff00ff,0xffaaaa],[0x00ff00,0xffff00]];
        this.sharedMat = new THREE.PointsMaterial({
            size: 8.0, map: this.tex, transparent: true, depthWrite: false,
            blending: THREE.AdditiveBlending, vertexColors: true
        });

        // ç«ç®­å…±äº«æè´¨
        this.rocketMat = new THREE.PointsMaterial({
            color: 0xffddaa, size: 5, map: this.tex,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        });
        // ç«ç®­å…±äº«å‡ ä½•ä½“ï¼ˆå•ç‚¹ï¼‰
        this.rocketGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);

        // å¤ç”¨é¢œè‰²å¯¹è±¡
        this._tempColor = new THREE.Color();

        // --- å¯¹è±¡æ± åˆå§‹åŒ– ---
        this.poolSize = 10; // Reduced from 15
        this.pool = [];
        const particlesPerExplosion = 60; // Reduced from 80

        for(let i=0; i<this.poolSize; i++) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particlesPerExplosion * 3);
            const col = new Float32Array(particlesPerExplosion * 3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            
            const m = new THREE.Points(geo, this.sharedMat);
            m.frustumCulled = false; // é¿å…è§†é”¥å‰”é™¤è®¡ç®—
            m.visible = false;
            this.sc.add(m);
            
            this.pool.push({
                mesh: m,
                velocities: new Float32Array(particlesPerExplosion * 3), // é¢„åˆ†é…é€Ÿåº¦æ•°ç»„
                life: 0,
                available: true
            });
        }
    }

    launch(pos) {
        // ç«ç®­ - ä½¿ç”¨å…±äº«å‡ ä½•ä½“å’Œæè´¨
        if(!pos) pos = new THREE.Vector3((Math.random()-0.5)*50, -5, (Math.random()-0.5)*50);
        const ty = pos.y + 50 + Math.random()*40;
        const pal = this.cols[Math.floor(Math.random()*this.cols.length)];

        const m = new THREE.Points(this.rocketGeo, this.rocketMat); // ä½¿ç”¨å…±äº«èµ„æº
        m.position.copy(pos);
        this.sc.add(m);

        this.activeRockets.push({
            m, pos: pos.clone(),
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.sqrt(2*0.02*(ty-pos.y)), (Math.random()-0.5)*0.5),
            pal
        });
    }

    update() {
        // 1. æ›´æ–°ç«ç®­
        for(let i = this.activeRockets.length - 1; i >= 0; i--) {
            const r = this.activeRockets[i];
            r.pos.add(r.vel); r.vel.y -= 0.02; r.m.position.copy(r.pos);
            if(r.vel.y <= 0.5) {
                this.sc.remove(r.m);
                this.explode(r.pos, r.pal);
                this.activeRockets.splice(i, 1);
            }
        }

        // 2. æ›´æ–°çˆ†ç‚¸ (ä½¿ç”¨å¯¹è±¡æ± )
        for(let i = 0; i < this.poolSize; i++) {
            const p = this.pool[i];
            if(p.available) continue;

            p.life -= 0.015;
            if(p.life <= 0) {
                p.mesh.visible = false;
                p.available = true; // å½’è¿˜åˆ°æ± å­
                continue;
            }

            const positions = p.mesh.geometry.attributes.position.array;
            const colors = p.mesh.geometry.attributes.color.array;
            
            for(let k=0; k<80; k++) {
                const idx = k*3;
                positions[idx] += p.velocities[idx];
                positions[idx+1] += p.velocities[idx+1];
                positions[idx+2] += p.velocities[idx+2];
                
                p.velocities[idx] *= 0.92;
                p.velocities[idx+1] *= 0.92;
                p.velocities[idx+2] *= 0.92;
                p.velocities[idx+1] -= 0.02;

                // ç®€å•çš„æ·¡å‡º (ç›´æ¥ä¿®æ”¹é¢œè‰² buffer)
                if(p.life < 1.0) {
                    colors[idx] *= 0.94; colors[idx+1] *= 0.94; colors[idx+2] *= 0.94;
                }
            }
            p.mesh.geometry.attributes.position.needsUpdate = true;
            p.mesh.geometry.attributes.color.needsUpdate = true;
        }
    }

    explode(pos, pal) {
        const styleIdx = window.getFireworkSoundStyle?.() ?? -1;
        audio.explode(styleIdx);

        // ä»æ± ä¸­æŸ¥æ‰¾å¯ç”¨å¯¹è±¡
        const item = this.pool.find(p => p.available);
        if(!item) return; // æ± å­æ»¡äº†å°±å¿½ç•¥ï¼Œä¿è¯æ€§èƒ½

        item.available = false;
        item.life = 1.5;
        item.mesh.visible = true;

        const posAttr = item.mesh.geometry.attributes.position.array;
        const colAttr = item.mesh.geometry.attributes.color.array;

        // é‡ç½®ç²’å­çŠ¶æ€ï¼ˆä½¿ç”¨å¤ç”¨é¢œè‰²å¯¹è±¡ï¼‰
        for(let i=0; i<80; i++) {
            const idx = i*3;
            // ä½ç½®é‡ç½®ä¸ºçˆ†ç‚¸ä¸­å¿ƒ
            posAttr[idx] = pos.x; posAttr[idx+1] = pos.y; posAttr[idx+2] = pos.z;

            // é€Ÿåº¦é‡ç½®
            const speed = 0.5 + Math.random() * 2.8;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            item.velocities[idx] = speed * Math.sin(phi) * Math.cos(theta);
            item.velocities[idx+1] = speed * Math.sin(phi) * Math.sin(theta);
            item.velocities[idx+2] = speed * Math.cos(phi);

            // é¢œè‰²é‡ç½® - ä½¿ç”¨å¤ç”¨é¢œè‰²å¯¹è±¡
            this._tempColor.setHex(pal[Math.floor(Math.random() * pal.length)]);
            this._tempColor.multiplyScalar(1.5);
            colAttr[idx] = this._tempColor.r;
            colAttr[idx+1] = this._tempColor.g;
            colAttr[idx+2] = this._tempColor.b;
        }
        item.mesh.geometry.attributes.position.needsUpdate = true;
        item.mesh.geometry.attributes.color.needsUpdate = true;
    }
}

// âœ¨ ç‹¬ç«‹çš„é­”æ³•å°¾è¿¹ç³»ç»Ÿ (ç»†è…»é‡‘æ²™ç‰ˆ - æœ€ç»ˆå®šç¨¿)
class MagicTrail {
    constructor(scene) {
        this.maxParticles = 600; // Reduced from 1200
        this.particles = [];
        this.scene = scene;

        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); 
        const g = cx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0, 'rgba(255, 255, 255, 0.9)');   // æ ¸å¿ƒç•¥ç™½
        g.addColorStop(0.4, 'rgba(255, 210, 80, 0.4)');  // ä¸­é—´æ·¡é‡‘
        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
        cx.fillStyle = g; cx.fillRect(0,0,32,32);
        const tex = new THREE.CanvasTexture(cv);

        this.geo = new THREE.BufferGeometry();
        this.geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxParticles * 3), 3));
        this.geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));
        this.geo.setAttribute('opacity', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));

                this.mat = new THREE.ShaderMaterial({
                    uniforms: { map: { value: tex } },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        attribute float opacity;
                        varying vec3 vColor;
                        varying float vOpacity;
                        void main() {
                            vColor = color;
                            vOpacity = opacity;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            // ğŸ’¡ æƒ³è¦ç²’å­æ›´å°ï¼Ÿè°ƒå°è¿™ä¸ªæ•°å­— (å½“å‰ 550.0)
                            gl_PointSize = size * (550.0 / -mvPosition.z); 
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D map;
                        varying vec3 vColor;
                        varying float vOpacity;
                        void main() {
                            vec4 texColor = texture2D(map, gl_PointCoord);
                            if (texColor.a < 0.05) discard;
                            // NormalBlending æ··åˆï¼ŒæŸ”å’Œä¸åˆºçœ¼
                            gl_FragColor = vec4(vColor, texColor.a * vOpacity); 
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.NormalBlending 
                });
        
                this.mesh = new THREE.Points(this.geo, this.mat);
                this.mesh.frustumCulled = false; 
                
                const posAttr = this.geo.attributes.position;
                for(let i=0; i<this.maxParticles; i++) posAttr.setXYZ(i, 0, -9999, 0);
                
                this.scene.add(this.mesh);
            }
        
            update(dt) {
                const positions = this.geo.attributes.position;
                const opacities = this.geo.attributes.opacity;
                const sizes = this.geo.attributes.size;
                const colors = this.geo.attributes.color;
        
                for(let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= dt;
        
                    if(p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }
        
                    p.pos.addScaledVector(p.vel, dt);
                    p.vel.y -= 6.0 * dt; // ä¿æŒä¸‹å æ„Ÿ
                    p.vel.multiplyScalar(0.98); 
        
                    const age = p.life / p.maxLife; 
                    p.currOpacity = age * 0.8; // é€æ˜åº¦ä¸Šé™ 0.8
                    p.currSize = p.baseSize * (0.6 + 0.4 * age); 
                }
        
                for(let i=0; i<this.maxParticles; i++) {
                    if(i < this.particles.length) {
                        const p = this.particles[i];
                        positions.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);
                        opacities.setX(i, p.currOpacity);
                        sizes.setX(i, p.currSize);
                        // æš—é‡‘è‰²ï¼Œè´¨æ„Ÿæ›´å¥½
                        colors.setXYZ(i, 0.9, 0.7, 0.2); 
                    } else {
                        positions.setXYZ(i, 0, -9999, 0);
                        opacities.setX(i, 0);
                    }
                }
        
                positions.needsUpdate = true;
                opacities.needsUpdate = true;
                sizes.needsUpdate = true;
                colors.needsUpdate = true;
            }
        
            emit(pos, quat, intensity) {
                if (intensity <= 0.05) return;
        
                const count = Math.floor(2 + intensity * 4); 
                const offset = new THREE.Vector3();
                const backDir = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();
        
                for(let k=0; k<count; k++) {
                    if(this.particles.length >= this.maxParticles) break;
        
                    const side = Math.random() > 0.5 ? 1.8 : -1.8;
                    
                    offset.set(
                        side + (Math.random()-0.5) * 0.2, 
                        0.0, 
                        4.0 + Math.random() * 2.0 
                    ).applyQuaternion(quat);
        
                    const p = {
                        pos: pos.clone().add(offset),
                        // ä¿æŒå‘åçš„æƒ¯æ€§é€Ÿåº¦
                        vel: backDir.clone().multiplyScalar(4.0 + Math.random() * 4.0) 
                            .add(new THREE.Vector3(
                                (Math.random()-0.5) * 0.2, 
                                0, 
                                (Math.random()-0.5) * 0.2
                            )),
                        life: 0.6 + Math.random() * 0.6, 
                        maxLife: 0,
                        // ğŸ’¡ æƒ³è¦è°ƒæ•´ç²’å­åŸºç¡€å¤§å°ï¼Ÿæ”¹è¿™é‡Œ
                        baseSize: 1.0 + Math.random() * 1.5, 
                        currSize: 0,
                        currOpacity: 1
                    };
                    p.maxLife = p.life;
                    this.particles.push(p);
                }
            }}

// ğŸ¦Œ åœ£è¯è€äººé©¯é¹¿é›ªæ©‡ - å¢å¼ºç‰ˆ
class SantaSleigh {
    constructor(sc) {
        this.scene = sc;
        this.group = new THREE.Group();
        this.active = false;
        this.nextTrigger = 12 + Math.random() * 8; 
        this.elapsed = 0;

        this.phase = 'idle';
        this.phaseTime = 0;

        this.approachDur = 4;    
        this.syncDur = 3;        
        this.dropDur = 0.8;      
        this.departDur = 4;      
        this.hoverHeight = 35;   

        this.fallingGifts = [];
        
        // ğŸ› ï¸ GC ä¼˜åŒ–ï¼šé¢„åˆ†é…å¤ç”¨å¯¹è±¡
        this._tempVel = new THREE.Vector3();
        this._tempVec = new THREE.Vector3();
        this._targetPos = new THREE.Vector3();
        this._lookPos = new THREE.Vector3();
        this._sleighWorldPos = new THREE.Vector3();
        
        this._targetQuat = new THREE.Quaternion();
        this._lookMatrix = new THREE.Matrix4();
        this._upVector = new THREE.Vector3(0, 1, 0);
        this._lookDir = new THREE.Vector3();

        this.buildSleigh();
        this.buildReindeer();
        // ğŸŒŸ ä½¿ç”¨æ–°çš„æ¨¡å—åŒ–å°¾è¿¹ç³»ç»Ÿ
        this.trail = new MagicTrail(sc);
        this.buildGiftTemplate();

        // ğŸ”§ ä¿®æ­£æœå‘ä¸ä½ç½®
        this.reindeer.rotation.y = Math.PI; 
        this.sleigh.rotation.y = Math.PI;
        this.reindeer.position.set(0, 0, -6); 
        this.sleigh.position.set(0, 0, 6);

        this.group.visible = false;
        this.group.scale.set(1.0, 1.0, 1.0); 
        sc.add(this.group);
    }

    buildSleigh() {
        const sleighG = new THREE.Group();

        const matRed = new THREE.MeshStandardMaterial({ color: 0xb71c1c, roughness: 0.4 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }); // ç»’æ¯›æ„Ÿ
        const matFace = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.5 });

        // ğŸ›· é›ªæ©‡ä¸»ä½“
        const createRunner = (x) => {
            const rG = new THREE.Group();
            rG.position.set(x, 0, 0);
            
            // ç›´æ®µ
            const straight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 6), matGold);
            straight.position.y = 0.2;
            rG.add(straight);

            // å·æ›²å‰ç«¯
            const curl = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.15, 8, 16, Math.PI), matGold);
            curl.position.set(0, 1.7, 3.0); // å‰ç«¯
            curl.rotation.y = Math.PI/2;
            curl.rotation.z = Math.PI/4; // å‘ä¸Šå·
            rG.add(curl);

            // æ”¯æ’‘æ†
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), matGold);
            leg1.position.set(0, 1.0, 1.5);
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), matGold);
            leg2.position.set(0, 1.0, -1.5);
            rG.add(leg1, leg2);

            return rG;
        };
        sleighG.add(createRunner(1.8));
        sleighG.add(createRunner(-1.8));

        // è½¦å¢
        const carriage = new THREE.Group();
        carriage.position.y = 2.0;
        
        // åº•æ¿
        const floor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 5), matRed);
        carriage.add(floor);
        
        // ä¾§æ¿ (å¸¦å¼§åº¦)
        const sideGeo = new THREE.BoxGeometry(0.2, 2, 5);
        const sideL = new THREE.Mesh(sideGeo, matRed); sideL.position.set(1.9, 1, 0);
        const sideR = new THREE.Mesh(sideGeo, matRed); sideR.position.set(-1.9, 1, 0);
        // é èƒŒ
        const back = new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 0.2), matRed);
        back.position.set(0, 1.25, -2.4);
        
        // é‡‘è‰²è¾¹ç¼˜
        const rimL = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 5.2).rotateX(Math.PI/2), matGold);
        rimL.position.set(1.9, 2.0, 0);
        const rimR = rimL.clone(); rimR.position.set(-1.9, 2.0, 0);
        
        carriage.add(sideL, sideR, back, rimL, rimR);
        sleighG.add(carriage);

        // ğŸ… åœ£è¯è€äºº
        const santa = new THREE.Group();
        santa.position.set(0, 2.5, -0.5);

        // èº«ä½“ (èƒ–)
        const body = new THREE.Mesh(new THREE.SphereGeometry(1.4, 12, 12), matRed);
        body.scale.y = 1.2;
        santa.add(body);

        // çº½æ‰£
        for(let i=0; i<3; i++) {
            const btn = new THREE.Mesh(new THREE.SphereGeometry(0.15), matGold);
            btn.position.set(0, 0.5 + i*0.6, 1.2);
            santa.add(btn);
        }

        // å¤´
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 12, 12), matFace);
        head.position.y = 2.2;
        santa.add(head);

        // å¤§èƒ¡å­ (ä¸è§„åˆ™å½¢çŠ¶)
        const beard = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6, 0), matWhite);
        beard.position.set(0, 1.9, 0.6);
        beard.scale.set(1, 1.2, 0.5);
        santa.add(beard);

        // å¸½å­
        const hatGroup = new THREE.Group();
        hatGroup.position.y = 2.7;
        hatGroup.rotation.x = -0.2; // ç¨å¾®åä»°
        
        const hatBrim = new THREE.Mesh(new THREE.TorusGeometry(0.75, 0.2, 8, 16), matWhite);
        hatBrim.rotation.x = Math.PI/2;
        
        const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.8, 16), matRed);
        hatCone.position.y = 0.9;
        hatCone.rotation.x = -0.2; // å¸½å°–åå‚
        
        const hatBall = new THREE.Mesh(new THREE.SphereGeometry(0.25), matWhite);
        hatBall.position.set(0, 1.7, -0.4); // å‚åœ¨åé¢

        hatGroup.add(hatBrim, hatCone, hatBall);
        santa.add(hatGroup);

        // æ‰‹è‡‚ (ä¸¾ç€ç¼°ç»³)
        const armGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5);
        const armL = new THREE.Mesh(armGeo, matRed);
        armL.position.set(1.2, 1.2, 0.5);
        armL.rotation.set(1.0, 0, -0.5); // å‘å‰ä¸¾
        const armR = new THREE.Mesh(armGeo, matRed);
        armR.position.set(-1.2, 1.2, 0.5);
        armR.rotation.set(1.0, 0, 0.5);
        
        // æ‰‹å¥—
        const gloveL = new THREE.Mesh(new THREE.SphereGeometry(0.35), matWhite);
        gloveL.position.y = 0.8; 
        armL.add(gloveL);
        const gloveR = gloveL.clone();
        armR.add(gloveR);

        santa.add(armL, armR);
        sleighG.add(santa);

        // ğŸ ç¤¼ç‰©è¢‹
        const sack = new THREE.Mesh(new THREE.IcosahedronGeometry(1.8, 0), new THREE.MeshStandardMaterial({color:0x8b4513}));
        sack.position.set(0, 3.0, -2.0);
        sack.scale.set(1.2, 1.0, 0.8);
        sack.rotation.z = 0.2;
        sleighG.add(sack);

        // æ•´ä½“ä½ç½®ï¼šæ”¾åœ¨é©¯é¹¿åé¢ (reindeer åœ¨ 0,0,0 é™„è¿‘)
        // æˆ‘ä»¬çš„é©¯é¹¿æœå‘ +Z (å‰è¿›)ï¼Œæ‰€ä»¥é›ªæ©‡åœ¨ -Z æ–¹å‘
        // ä¹‹å‰çš„ä»£ç é€»è¾‘é‡Œ forward æ˜¯ -Z? ä¸ï¼Œæˆ‘ä»¬ä¹‹å‰çš„ buildReindeer æ”¹ä¸º +Z å‰è¿›äº†ã€‚
        // æ‰€ä»¥è¿™é‡Œé›ªæ©‡åº”è¯¥åœ¨ -Z ä½ç½®ã€‚
        sleighG.position.set(0, 0, -5);
        sleighG.scale.set(0.8, 0.8, 0.8);

        this.sleigh = sleighG;
        this.group.add(sleighG);
    }

    buildReindeer() {
        const reindeerG = new THREE.Group();
        
        // æè´¨
        const matSkin = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.9 }); // é¹¿çš®è¤
        const matDark = new THREE.MeshStandardMaterial({ color: 0x4a3015, roughness: 0.9 }); // æ·±è‰²è¹„å­/è§’
        const matNose = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 }); // é»‘é¼»å­
        const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive:0xff0000, emissiveIntensity:0.8 }); // çº¢é¼»å­

        // ğŸ¦Œ æ„å»ºå•åªé©¯é¹¿
        const createDeer = (isRudolph) => {
            const deer = new THREE.Group();

            // 1. èº¯å¹² (Torso)
            const bodyGeo = new THREE.BoxGeometry(1.1, 1.3, 2.6);
            const body = new THREE.Mesh(bodyGeo, matSkin);
            body.position.y = 2.0;
            deer.add(body);

            // 2. è„–å­ (Neck)
            const neck = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.5, 0.9), matSkin);
            neck.position.set(0, 3.0, 1.4); // åå‰
            neck.rotation.x = -Math.PI / 6; // å‘åä»°
            deer.add(neck);

            // 3. å¤´éƒ¨ (Head)
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 3.8, 1.9);
            
            // è„¸éƒ¨ä¸»ä½“
            const face = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.85, 1.2), matSkin);
            headGroup.add(face);
            
            // å˜´éƒ¨çªå‡º
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.5, 0.6), matSkin);
            snout.position.set(0, -0.15, 0.7);
            headGroup.add(snout);

            // é¼»å­ (Nose)
            const noseMat = isRudolph ? matRed : matNose;
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), noseMat);
            nose.position.set(0, 0.15, 1.0);
            headGroup.add(nose);
            if(isRudolph) {
                const light = new THREE.PointLight(0xff0000, 1.5, 10);
                light.position.set(0, 0.2, 1.2);
                headGroup.add(light);
            }

            // è€³æœµ
            const earGeo = new THREE.BoxGeometry(0.6, 0.3, 0.15);
            const earL = new THREE.Mesh(earGeo, matSkin);
            earL.position.set(0.5, 0.2, -0.3);
            earL.rotation.set(0, 0.4, 0.3);
            const earR = new THREE.Mesh(earGeo, matSkin);
            earR.position.set(-0.5, 0.2, -0.3);
            earR.rotation.set(0, -0.4, -0.3);
            headGroup.add(earL, earR);

            // é¹¿è§’ (Antlers)
            const antGeo = new THREE.CylinderGeometry(0.04, 0.06, 1.2);
            [1, -1].forEach(side => {
                const ant = new THREE.Mesh(antGeo, matDark);
                ant.position.set(side * 0.3, 0.8, -0.2);
                ant.rotation.z = side * 0.3;
                ant.rotation.x = -0.2;
                
                // åˆ†å‰
                const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.04,0.6), matDark);
                branch.position.y = 0.2;
                branch.position.z = 0.2;
                branch.rotation.x = Math.PI/3;
                ant.add(branch);

                headGroup.add(ant);
            });

            deer.add(headGroup);

            // 4. å››è‚¢ (Legs) - ç®€å•çš„å…³èŠ‚è¿åŠ¨æ¨¡æ‹Ÿ
            // è…¿éƒ¨å‡ ä½•ä½“
            const upperLegGeo = new THREE.BoxGeometry(0.35, 1.2, 0.35);
            const lowerLegGeo = new THREE.BoxGeometry(0.25, 1.2, 0.25);

            const createLeg = (x, z, isFront) => {
                const legG = new THREE.Group();
                legG.position.set(x, 1.5, z); // é«‹å…³èŠ‚ä½ç½®

                // å¤§è…¿
                const upper = new THREE.Mesh(upperLegGeo, matSkin);
                upper.position.y = -0.5;
                // å…³èŠ‚å¼¯æ›²ï¼šå‰è…¿å‘åå¼¯ï¼Œåè…¿å‘å‰å¼¯
                upper.rotation.x = isFront ? 0.1 : -0.1; 
                
                // å°è…¿
                const lower = new THREE.Mesh(lowerLegGeo, matSkin);
                lower.position.y = -1.1;
                lower.position.z = isFront ? -0.1 : 0.1;
                lower.rotation.x = isFront ? -0.2 : 0.2;
                
                upper.add(lower);
                legG.add(upper);
                return legG;
            };

            // å‰è…¿
            deer.add(createLeg(0.35, 1.0, true));
            deer.add(createLeg(-0.35, 1.0, true));
            // åè…¿
            deer.add(createLeg(0.35, -1.0, false));
            deer.add(createLeg(-0.35, -1.0, false));

            // å°å°¾å·´
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matSkin);
            tail.position.set(0, 2.2, -1.4);
            tail.rotation.x = 0.5;
            deer.add(tail);

            return deer;
        };

        // ğŸ¦Œ ç¼–é˜Ÿ
        // é¢†å¤´ Rudolph
        const rudolph = createDeer(true);
        rudolph.position.set(0, 0, 10); // æœ€å‰é¢
        reindeerG.add(rudolph);

        // ä¸­é—´ä¸¤å¯¹
        const d1 = createDeer(false); d1.position.set(-1.8, 0, 6);
        const d2 = createDeer(false); d2.position.set(1.8, 0, 6);
        const d3 = createDeer(false); d3.position.set(-1.8, 0, 2);
        const d4 = createDeer(false); d4.position.set(1.8, 0, 2);
        reindeerG.add(d1, d2, d3, d4);

        // ç¼°ç»³è¿æ¥
        const ropeMat = new THREE.LineBasicMaterial({ color: 0x5d3a1a });
        const pts = [
            new THREE.Vector3(0, 2.5, 10), // Rudolph Neck (Leader)
            new THREE.Vector3(0, 2.5, 6),  // Mid
            new THREE.Vector3(0, 2.5, 2),  // Back
            // ğŸ”§ ä¿®å¤ï¼šå»¶é•¿ç¼°ç»³ä»¥åŒ¹é…æ–°çš„é›ªæ©‡ä½ç½®
            // é©¯é¹¿åœ¨ -6ï¼Œé›ªæ©‡åœ¨ 6ï¼Œé—´è· 12ã€‚
            // é©¯é¹¿å±€éƒ¨åæ ‡ -Z æ˜¯åæ–¹ï¼Œæ‰€ä»¥è¦å»¶ä¼¸åˆ° -13 å·¦å³æ‰èƒ½ç¢°åˆ°åœ£è¯è€äººçš„æ‰‹
            new THREE.Vector3(0, 3.5, -13)  
        ];
        reindeerG.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), ropeMat));

        // æ•´ä½“ç¼©æ”¾ï¼šç°åœ¨çš„æ¨¡å‹å•ä½æ¯”è¾ƒå¤§ï¼Œéœ€è¦ç¼©å°ä¸€ç‚¹ä»¥åŒ¹é…ç«è½¦
        reindeerG.scale.set(0.7, 0.7, 0.7);
        
        // **å…³é”®ä¿®æ­£**ï¼šä¹‹å‰çš„æ¨¡å‹æ˜¯æœå‘ -Z çš„ï¼Œç°åœ¨æˆ‘çš„æ¨¡å‹æ„å»ºæ˜¯æœå‘ +Z (Face z=0.7)ï¼Œ
        // æ‰€ä»¥ä¸éœ€è¦æ—‹è½¬ -Math.PI/2ï¼Œæˆ–è€…éœ€è¦è°ƒæ•´ã€‚
        // æ£€æŸ¥ SantaSleigh.update: lookAt ä¹Ÿæ˜¯æœå‘ç›®æ ‡çš„ã€‚
        // é€šå¸¸ç‰©ä½“åº”è¯¥æœå‘ +Z æˆ– -Zã€‚è¿™é‡Œä¸ºäº†ç»Ÿä¸€ï¼Œæˆ‘ä»¬è®©å®ƒæœå‘ +Zï¼ˆå‰è¿›æ–¹å‘ï¼‰ã€‚
        // æ‰€ä»¥ä¸éœ€è¦é¢å¤–çš„ rotation.yã€‚
        
        this.reindeer = reindeerG;
        this.group.add(reindeerG);
    }

    buildTrail() {
        // ğŸŒŸ ç²’å­å°¾è¿¹ç³»ç»Ÿåˆå§‹åŒ–
        this.maxTrailParticles = 1000; // å¢åŠ ç²’å­ä¸Šé™
        this.trailParticles = []; 

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles * 3), 3));
        geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles * 3), 3));
        geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxTrailParticles), 1));

        const cv = document.createElement('canvas'); cv.width=64; cv.height=64;
        const cx = cv.getContext('2d'); 
        const g = cx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0,'rgba(255,255,255,1)');
        g.addColorStop(0.2,'rgba(255,220,100,0.9)');
        g.addColorStop(0.5,'rgba(255,180,50,0.4)');
        g.addColorStop(1,'rgba(0,0,0,0)'); 
        cx.fillStyle=g; cx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cv);

        const mat = new THREE.ShaderMaterial({
            uniforms: { map: { value: tex } },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    // è¶…å¤§å°ºå¯¸ç³»æ•°ï¼Œç¡®ä¿è¿œçœ‹ä¹Ÿæ¸…æ™°
                    gl_PointSize = size * (3000.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                varying vec3 vColor;
                void main() {
                    vec4 texColor = texture2D(map, gl_PointCoord);
                    // å¢å¼ºé€æ˜åº¦ï¼Œé˜²æ­¢çœ‹ä¸è§
                    gl_FragColor = vec4(vColor, 1.0) * texColor * 1.5;
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.trail = new THREE.Points(geo, mat);
        this.trail.frustumCulled = false; // å…³é”®ä¿®å¤ï¼šé˜²æ­¢å°¾è¿¹å› åŒ…å›´ç›’è¿‡æœŸè€Œè¢«å‰”é™¤
        
        const posAttr = geo.attributes.position;
        for(let i=0; i<this.maxTrailParticles; i++) posAttr.setXYZ(i, 0, -5000, 0);
        
        this.scene.add(this.trail);
    }

    // å‘å°„æ–°ç²’å­ (åœ¨é£è¡Œæ—¶æŒç»­è°ƒç”¨)
    emitTrail() {
        const count = 8; // åŠ å¤§å‘å°„é‡
        const offset = new THREE.Vector3();
        
        for(let k=0; k<count; k++) {
            if(this.trailParticles.length >= this.maxTrailParticles) break;

            // æ‰‡å½¢å‘å°„æºï¼šé›ªæ©‡å°¾éƒ¨
            // å› ä¸ºä¹‹å‰æˆ‘ä»¬å°† group é‡Œçš„æ¨¡å‹è½¬äº† 180åº¦ï¼Œä½† group æœ¬èº«çš„åæ ‡ç³»æ²¡å˜ã€‚
            // æˆ‘ä»¬çš„æ¨¡å‹ï¼šå¤´éƒ¨åœ¨å±€éƒ¨ -Zï¼Œå°¾éƒ¨åœ¨å±€éƒ¨ +Zã€‚
            // æ‰€ä»¥å°¾è¿¹åº”è¯¥åœ¨ +Z æ–¹å‘ç”Ÿæˆï¼Œå¹¶å‘ +Z æ–¹å‘å–·å°„ã€‚
            offset.set(
                (Math.random()-0.5) * 4.0,  // å®½ä¸€ç‚¹
                (Math.random()-0.5) * 2.0 + 2.0, 
                (Math.random()-0.5) * 2.0 + 8.0 // é å (å±€éƒ¨+Z)
            ).applyQuaternion(this.group.quaternion); 
            
            const p = {
                pos: this.group.position.clone().add(offset),
                // ç²’å­åˆé€Ÿåº¦ï¼šå‘åå–·å°„ (å±€éƒ¨ +Z)
                vel: new THREE.Vector3(0,0,1).applyQuaternion(this.group.quaternion).multiplyScalar(0.8) 
                    .add(new THREE.Vector3(
                        (Math.random()-0.5) * 0.5, 
                        -Math.random() * 0.2, 
                        (Math.random()-0.5) * 0.5
                    )),
                life: 2.0 + Math.random() * 1.5, // å¯¿å‘½æ›´é•¿
                maxLife: 0, 
                size: 6.0 + Math.random() * 6.0 // åŸºç¡€å°ºå¯¸æ›´å¤§
            };
            p.maxLife = p.life;
            this.trailParticles.push(p);
        }
    }

    // æ›´æ–°æ‰€æœ‰ç²’å­
    updateTrailParticles(dt) {
        const positions = this.trail.geometry.attributes.position;
        const colors = this.trail.geometry.attributes.color;
        const sizes = this.trail.geometry.attributes.size;

        // 1. é€»è¾‘æ›´æ–°
        for(let i = this.trailParticles.length - 1; i >= 0; i--) {
            const p = this.trailParticles[i];
            p.life -= dt;

            if(p.life <= 0) {
                this.trailParticles.splice(i, 1);
                continue;
            }

            p.pos.add(p.vel);
            p.vel.multiplyScalar(0.97); // é˜»åŠ›
        }

        // 2. æ¸²æŸ“æ›´æ–°
        for(let i=0; i<this.maxTrailParticles; i++) {
            if(i < this.trailParticles.length) {
                const p = this.trailParticles[i];
                positions.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);
                
                // é¢œè‰²ä¸å¤§å°éšç”Ÿå‘½å‘¨æœŸè¡°å‡
                const alpha = Math.pow(p.life / p.maxLife, 1.2); 
                
                // é‡‘è‰²ç³»ï¼šR=1.0, G=0.8~0.5, B=0.0
                colors.setXYZ(i, 1.0 * alpha, (0.4 + 0.4 * alpha) * alpha, 0.0); 

                sizes.setX(i, p.size * (0.3 + 0.7 * alpha));
            } else {
                // éšè—æœªä½¿ç”¨çš„ç‚¹
                positions.setXYZ(i, 0, -5000, 0); 
                sizes.setX(i, 0);
            }
        }

        positions.needsUpdate = true;
        colors.needsUpdate = true;
        sizes.needsUpdate = true;
    }



    buildGiftTemplate() {
        // ä½¿ç”¨å…±äº«å·¥å‚åˆ›å»ºå¤§å·ç¤¼ç›’æ¨¡æ¿ï¼ˆå¸¦è´è¶ç»“ä¸­å¿ƒç»“ï¼Œç™½è‰²è´è¶ç»“ï¼‰
        this.giftTemplate = GiftFactory.createTemplate({ size: 2.5, hasKnot: true, bowMat: 'white' });
    }

    createGift() {
        return GiftFactory.cloneWithUniqueMaterials(this.giftTemplate);
    }

    trigger() {
        if (this.active) return;
        if (!train) return; // éœ€è¦ç«è½¦å­˜åœ¨

        this.active = true;
        this.phase = 'approach';
        this.phaseTime = 0;
        this.group.visible = true;
        this.trailPositions = [];
        this.giftDropped = false;

        // è®°å½•è§¦å‘æ—¶çš„ç«è½¦ä½ç½®ä½œä¸ºç›®æ ‡
        this.targetTrainProg = train.prog;

        // è®¡ç®—èµ·å§‹ä½ç½®ï¼ˆå¤©è¾¹è¿œå¤„ï¼‰
        const trainPos = trackCurve.getPointAt(this.targetTrainProg);
        const angle = Math.random() * Math.PI * 2;
        this.startPos = new THREE.Vector3(
            trainPos.x + Math.cos(angle) * 600,
            250 + Math.random() * 100,
            trainPos.z + Math.sin(angle) * 600
        );

        // è®¡ç®—ç¦»å¼€ä½ç½®ï¼ˆå¦ä¸€ä¸ªæ–¹å‘çš„å¤©è¾¹ï¼‰
        const exitAngle = angle + Math.PI + (Math.random() - 0.5) * 0.5;
        this.exitPos = new THREE.Vector3(
            trainPos.x + Math.cos(exitAngle) * 600,
            200 + Math.random() * 100,
            trainPos.z + Math.sin(exitAngle) * 600
        );

        this.group.position.copy(this.startPos);

        // æ’­æ”¾è¿œå¤„é“ƒé“›å£°
        if (audio && audio.bell) {
            audio.bell();
        }
    }

    update(dt) {
        this.elapsed += dt;

        // 1. å§‹ç»ˆæ›´æ–°å°¾è¿¹ç³»ç»Ÿ (å¤„ç†æ®‹ç•™ç²’å­)
        if (this.trail) this.trail.update(dt);
        
        this.updateFallingGifts(dt);

        if (!this.active && this.elapsed >= this.nextTrigger) {
            this.trigger();
            this.nextTrigger = this.elapsed + 30 + Math.random() * 40; 
        }

        if (!this.active) {
            // å¦‚æœä¸æ´»åŠ¨ï¼Œé‡ç½®ä¸Šä¸€å¸§ä½ç½®ï¼Œé˜²æ­¢ä¸‹æ¬¡å‡ºç°æ—¶é€Ÿåº¦è®¡ç®—é”™è¯¯
            if (this._lastPos) this._lastPos.copy(this.group.position);
            return;
        }

        // åˆå§‹åŒ–ä¸Šä¸€å¸§ä½ç½®
        if (!this._lastPos) this._lastPos = this.group.position.clone();

        // 2. è®¡ç®—ç‰©ç†é€Ÿåº¦ (ç”¨äºæ§åˆ¶å°¾è¿¹å¼ºåº¦)
        const dist = this.group.position.distanceTo(this._lastPos);
        const currentSpeed = dist / dt; // å•ä½/ç§’
        
        // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
        this._lastPos.copy(this.group.position);

        // 3. åŸºäºé€Ÿåº¦çš„å–·å°„å¼ºåº¦
        // é€Ÿåº¦çº¦å¿«ï¼Œå–·å¾—è¶ŠçŒ›ï¼›æ‚¬åœæ—¶é€Ÿåº¦æ¥è¿‘0ï¼Œè‡ªåŠ¨åœæ­¢å–·å°„
        // 30.0 æ˜¯ç»éªŒå€¼ï¼Œå¤§æ¦‚å¯¹åº”å…¨é€Ÿé£è¡Œæ—¶çš„é€Ÿåº¦
        const emissionIntensity = Math.min(currentSpeed / 30.0, 1.0);

        // å‘å°„å°¾è¿¹
        if (this.trail) {
            this.trail.emit(this.group.position, this.group.quaternion, emissionIntensity);
        }

        this.phaseTime += dt;

        // --- åŸæœ‰é£è¡Œé€»è¾‘ ---
        const trainPos = train ? trackCurve.getPointAt(train.prog) : this._tempVec.set(0,0,0);
        const trainTan = train ? trackCurve.getTangentAt(train.prog) : new THREE.Vector3(0, 0, 1); 
        
        this._lookPos.copy(trainTan).multiplyScalar(STATE.trainDir); 
        const trainDir = this._lookPos; 

        const hoverPos = this._tempVec.copy(trainPos);
        hoverPos.y += this.hoverHeight;

        let updateLook = false;

        switch (this.phase) {
            case 'approach': {
                const t = Math.min(this.phaseTime / this.approachDur, 1);
                const easeT = 1 - Math.pow(1 - t, 3); 

                this._targetPos.copy(this.startPos).lerp(hoverPos, easeT);
                this._targetPos.y += Math.sin(t * Math.PI) * 20; 

                this._lookPos.copy(hoverPos);
                updateLook = true;

                if (t >= 1) {
                    this.phase = 'sync';
                    this.phaseTime = 0;
                    if (audio && audio.bell) audio.bell();
                }
                break;
            }

            case 'sync': {
                const t = this.phaseTime / this.syncDur;

                this._targetPos.copy(hoverPos);
                this._targetPos.y += Math.sin(this.elapsed * 2) * 1.5;

                const tDir = trainTan.clone().multiplyScalar(STATE.trainDir);
                this._lookPos.copy(this._targetPos).addScaledVector(tDir, 20);
                updateLook = true;

                if (t >= 0.5 && !this.giftDropped) {
                    if (!this._sleighWorldPos) this._sleighWorldPos = new THREE.Vector3();
                    this._sleighWorldPos.set(0, 2, 5); 
                    this._sleighWorldPos.applyMatrix4(this.group.matrixWorld);

                    this.dropGift(this._sleighWorldPos);
                    this.giftDropped = true;
                }

                if (t >= 1) {
                    this.phase = 'depart';
                    this.phaseTime = 0;
                    if(!this.departStart) this.departStart = new THREE.Vector3();
                    this.departStart.copy(this._targetPos);
                }
                break;
            }

            case 'depart': {
                const t = Math.min(this.phaseTime / this.departDur, 1);
                const easeT = t * t; 

                this._targetPos.copy(this.departStart).lerp(this.exitPos, easeT);
                this._targetPos.y += Math.sin(t * Math.PI) * 30; 

                this._lookPos.copy(this.exitPos);
                updateLook = true;

                if (t >= 1) {
                    this.active = false;
                    this.group.visible = false;
                    this.phase = 'idle';
                }
                break;
            }
        }

        if (this.active) {
            this.group.position.lerp(this._targetPos, 0.1);

            if (updateLook) {
                this._lookDir.copy(this._lookPos).sub(this.group.position).normalize();
                if (this._lookDir.length() > 0.01) {
                    this._lookMatrix.lookAt(this.group.position, this._lookPos, this._upVector);
                    this._targetQuat.setFromRotationMatrix(this._lookMatrix);
                    this.group.quaternion.slerp(this._targetQuat, 0.05);
                }
            }

            this.group.position.y += Math.sin(this.elapsed * 3) * 0.5;

            if (this.reindeer) {
                this.reindeer.children.forEach((deer, i) => {
                    if (deer.type === 'Group') {
                        deer.rotation.x = Math.sin(this.elapsed * 8 + i) * 0.15;
                    }
                });
            }
        }
    }

    dropGift(fromPos) {
        if (!train || train.cars.length === 0) return;

        // 1. å†³å®šæ‰”å‡ ä¸ª (ç‹‚æ¬¢æ¨¡å¼æ‰”æ›´å¤š: 6-10ä¸ª)
        const dropCount = STATE.christmasParty ? 6 + Math.floor(Math.random() * 5) : 1;
        
        // å¤åˆ¶æ•°ç»„ä»¥ç¡®ä¿ä»ä¸åŒè½¦å¢é€‰æ‹© (æ´—ç‰Œç®—æ³•ç®€åŒ–ç‰ˆ)
        const candidates = [...train.cars];
        const startPosFixed = fromPos.clone(); // é”å®šèµ·å§‹ä½ç½®ï¼Œé˜²æ­¢å› å»¶æ—¶å¯¼è‡´ä½ç½®æ¼‚ç§»

        for (let i = 0; i < dropCount; i++) {
            if (candidates.length === 0) break;
            
            const idx = Math.floor(Math.random() * candidates.length);
            const targetCar = candidates.splice(idx, 1)[0];

            // é”™å³°å‘å°„ï¼Œå½¢æˆè¿ç ç‚®æ•ˆæœ
            setTimeout(() => {
                this.spawnSingleGift(startPosFixed, targetCar);
            }, i * 100); // æ›´å¿«çš„è¿å°„
        }
    }

    spawnSingleGift(startPos, targetCar) {
        const gift = this.createGift();
        gift.position.copy(startPos);
        gift.scale.set(0.8, 0.8, 0.8);
        this.scene.add(gift);

        // --- ğŸ’¡ ä¼˜åŒ–2ï¼šåˆå§‹åŒ–å‘å…‰æè´¨ ---
        // éå†ç¤¼ç‰©çš„æ‰€æœ‰éƒ¨åˆ†ï¼Œå¼€å¯è‡ªå‘å…‰
        gift.traverse(c => {
            if (c.isMesh && c.material) {
                // ç¡®ä¿å¼€å¯å‘å…‰ç‰¹æ€§
                c.material.emissive = new THREE.Color(c.material.color);
                c.material.emissiveIntensity = 0.5; // åˆå§‹äº®åº¦
            }
        });

        this.scene.add(gift);

        if (audio && audio.bell) audio.bell();

        // ä¸ºç¤¼ç‰©åˆ›å»ºé£è¡Œå°¾è¿¹
        const trailColor = gift.children[0].material.color.getHex(); // è·å–ç¤¼ç›’ä¸»ä½“é¢œè‰²
        const trail = new GiftParticleTrail(this.scene, trailColor);

        this.fallingGifts.push({
            mesh: gift,
            startPos: startPos, 
            targetCar: targetCar,      
            time: 0,                   
            duration: 2.5,             
            arcHeight: 12,             
            landed: false,
            
            // --- ğŸ’¡ ä¼˜åŒ–3ï¼šQå¼¹åŠ¨ç”»å˜é‡ ---
            scaleTime: 0,        // ç”¨äºè½åœ°åçš„å½¢å˜åŠ¨ç”»è®¡æ—¶
            isSquashing: false,  // æ˜¯å¦æ­£åœ¨è¿›è¡Œè½åœ°å˜å½¢
            baseScale: 0.8,      // åŸºç¡€ç¼©æ”¾æ¯”ä¾‹
            
            rotVel: new THREE.Vector3( 
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).multiplyScalar(3.0), // ç¨å¾®åŠ å¿«æ—‹è½¬é€Ÿåº¦ï¼Œæ›´æœ‰åŠ¨æ„Ÿ    
            
            trail: trail, 
            fadeStartTime: 0, 
            fadeDuration: 0.1 // æå¿«æ·¡å‡º
        });
    }

    updateFallingGifts(dt) {
        const _targetWorldPos = new THREE.Vector3();
        const _midPoint = new THREE.Vector3();

        for (let i = this.fallingGifts.length - 1; i >= 0; i--) {
            const g = this.fallingGifts[i];

            // ===========================
            // ğŸ›‘ çŠ¶æ€ A: å·²è½åœ° (Landed)
            // ===========================
            if (g.landed) {
                // 1. å¤„ç† Q å¼¹åŠ¨ç”» (Squash & Stretch) - ä»…åœ¨åˆšè½åœ°æ—¶æœ‰æ•ˆ
                if (g.isSquashing) {
                    g.scaleTime += dt * 15.0; 
                    const decay = Math.exp(-g.scaleTime * 0.5);
                    const wave = Math.sin(g.scaleTime) * 0.4 * decay; 
                    
                    const sy = g.baseScale * (1.0 - wave);       
                    const sxz = g.baseScale * (1.0 + wave * 0.5); 
                    g.mesh.scale.set(sxz, sy, sxz);

                    if (g.scaleTime > Math.PI * 2) {
                        g.isSquashing = false;
                        g.mesh.scale.set(g.baseScale, g.baseScale, g.baseScale); 
                    }
                }

                // 2. ç”Ÿå‘½å‘¨æœŸç®¡ç† (å¸æ”¶æ•ˆæœ)
                g.life -= dt;
                
                // --- ğŸ“¥ å¸æ”¶å€’è®¡æ—¶ (æœ€å 1.5 ç§’) ---
                if (g.life < 1.5) {
                    const progress = Math.max(0, g.life / 1.5); // 1.0 -> 0.0
                    
                    // A. ç¼“æ…¢ä¸‹æ²‰ (Sink)
                    // å‡è®¾åˆå§‹ Y æ˜¯ 5.5 (è½¦é¡¶)ï¼Œæˆ‘ä»¬è¦è®©å®ƒæ²‰åˆ° 3.5 (è½¦èº«å†…)
                    // è¿™é‡Œçš„ Y æ˜¯ç›¸å¯¹äº g.targetCar çš„å±€éƒ¨åæ ‡
                    // æˆ‘ä»¬ä¸éœ€è¦ä¿å­˜åˆå§‹ Yï¼Œåªéœ€è¦æ¯å¸§ç¨å¾®å‡ä¸€ç‚¹ï¼Œæˆ–è€…æ’å€¼
                    g.mesh.position.y -= dt * 1.5; 

                    // B. ç¼©å° (Shrink)
                    const scale = g.baseScale * progress;
                    g.mesh.scale.set(scale, scale, scale);
                    
                    // C. äº®åº¦çˆ†å‘ (è½¬åŒ–èƒ½é‡)
                    const flare = 0.5 + 2.0 * (1.0 - progress);
                    g.mesh.traverse(c => {
                        if (c.isMesh && c.material.emissive) {
                            c.material.emissiveIntensity = flare;
                        }
                    });
                } 
                // --- æ­£å¸¸åœç•™æœŸ ---
                else if (!g.isSquashing) {
                    const pulse = 0.4 + 0.2 * Math.sin(this.elapsed * 3.0 + g.mesh.id);
                    g.mesh.traverse(c => {
                        if (c.isMesh) c.material.emissiveIntensity = pulse;
                    });
                }

                // 3. å½»åº•å¸æ”¶å®Œæˆ
                if(g.life <= 0) {
                    // --- ğŸšƒ è½¦å¢åé¦ˆ (Absorb Reaction) ---
                    // è§¦å‘è½¦å¢çª—æˆ·é—ªçƒï¼Œè¡¨ç¤ºæ”¶åˆ°ç¤¼ç‰©
                    if (train && train.flashWindows) {
                        train.flashWindows(g.targetCar);
                        // æ’­æ”¾ä¸€ä¸ªå°éŸ³æ•ˆ (æ”¶é›†å£°)
                        if (audio) audio.bell(); 
                    }

                    // ç§»é™¤ç‰©ä½“
                    if(g.mesh.parent) g.mesh.parent.remove(g.mesh);
                    
                    // æ·±åº¦æ¸…ç†å†…å­˜
                    g.mesh.traverse(c => {
                        if (c.isMesh) {
                            if (c.geometry) c.geometry.dispose();
                            if (c.material) {
                                if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
                                else c.material.dispose();
                            }
                        }
                    });
                    this.fallingGifts.splice(i, 1);
                }

                // 4. å°¾è¿¹æ¸…ç†
                if (g.trail) {
                    g.trail.dispose();
                    g.trail = null;
                }
                continue; 
            }

            // ===========================
            // ğŸš€ çŠ¶æ€ B: é£è¡Œä¸­ (Flying)
            // ===========================

            g.time += dt;
            let t = Math.min(g.time / g.duration, 1.0);
            
            // --- ğŸ”§ æ–°ç‰ˆæŠ›ç‰©çº¿é€»è¾‘ (Quadratic Bezier) ---
            // ç›®æ ‡ä½ç½®ï¼šè½¦å¢å½“å‰ä½ç½®
            g.targetCar.getWorldPosition(_targetWorldPos);
            // ç›®æ ‡é«˜åº¦è°ƒæ•´ï¼šè½¦é¡¶æœ€é«˜ç‚¹ (Local Y ~7.25) + ç¤¼ç‰©åŠé«˜
            // è¿™æ ·é£è¡Œè½¨è¿¹ä¹Ÿæ˜¯ç„å‡†è½¦é¡¶çš„
            const carUp = new THREE.Vector3(0, 1, 0).applyQuaternion(g.targetCar.quaternion);
            _targetWorldPos.addScaledVector(carUp, 8.0);

            // æ§åˆ¶ç‚¹è®¡ç®—ï¼šèµ·ç‚¹å’Œç»ˆç‚¹çš„ä¸­ç‚¹ï¼Œå†å‘ä¸ŠæŠ¬é«˜
            _midPoint.copy(g.startPos).add(_targetWorldPos).multiplyScalar(0.5);
            _midPoint.y += 40; // æŠ¬é«˜æ§åˆ¶ç‚¹ï¼Œå½¢æˆæ‹±é—¨

            // è´å¡å°”å…¬å¼: (1-t)^2 * P0 + 2(1-t)t * P1 + t^2 * P2
            const p0 = g.startPos;
            const p1 = _midPoint;
            const p2 = _targetWorldPos;

            const t1 = 1 - t;
            g.mesh.position.x = t1*t1 * p0.x + 2*t1*t * p1.x + t*t * p2.x;
            g.mesh.position.y = t1*t1 * p0.y + 2*t1*t * p1.y + t*t * p2.y;
            g.mesh.position.z = t1*t1 * p0.z + 2*t1*t * p1.z + t*t * p2.z;

            // æ›´æ–°æ—‹è½¬
            g.mesh.rotation.x += g.rotVel.x * dt;
            g.mesh.rotation.y += g.rotVel.y * dt;
            g.mesh.rotation.z += g.rotVel.z * dt;

            // å‘¼å¸å…‰æ•ˆ
            const pulse = 0.65 + 0.35 * Math.sin(g.time * 5.0); 
            g.mesh.traverse(c => {
                if (c.isMesh) c.material.emissiveIntensity = pulse;
            });

            // æ›´æ–°å°¾è¿¹
            if (g.trail) g.trail.update(g.mesh.position);

            // ===========================
            // ğŸ’¥ çŠ¶æ€ C: åˆšæ¥è§¦ç¬é—´ (Impact)
            // ===========================
            if (t >= 1.0) {
                // æ ‡è®°ä¸ºå·²è½åœ°
                g.landed = true;
                
                // è®¾ç½®è·Ÿéšï¼šæŠŠç¤¼ç‰©åŠ åˆ°è½¦å¢å¯¹è±¡é‡Œ
                g.mesh.parent.remove(g.mesh);
                g.targetCar.add(g.mesh);
                
                // --- ğŸ”§ ä¿®æ­£è½åœ°ä½ç½® (Snap to Curved Roof) ---
                // è½¦é¡¶å‚æ•°: è½´å¿ƒY=5.2, åŠå¾„R=2.05
                const roofAxisY = 5.2;
                const roofRadius = 2.05;
                
                // éšæœº X (å®½åº¦æ–¹å‘)
                // é™åˆ¶åœ¨ [-1.6, 1.6] èŒƒå›´å†…ï¼Œé¿å…æ‰å‡ºè¾¹ç¼˜
                const rX = (Math.random() - 0.5) * 3.2;
                
                // è®¡ç®—å¯¹åº”çš„åœ†æŸ±é¢é«˜åº¦ Y
                // y = axisY + sqrt(R^2 - x^2)
                // é˜²æ­¢æµ®ç‚¹è¯¯å·®å¯¼è‡´ NaN
                const h = Math.sqrt(Math.max(0, roofRadius*roofRadius - rX*rX));
                const surfaceY = roofAxisY + h;
                
                // éšæœº Z (é•¿åº¦æ–¹å‘)
                const rZ = (Math.random() - 0.5) * 6.0;
                
                // è®¾ç½®ä½ç½® (åŠ ä¸€ç‚¹åç§»é˜²æ­¢ç©¿æ¨¡ï¼Œå‡è®¾ç¤¼ç‰©åŠé«˜çº¦ 0.8)
                g.mesh.position.set(rX, surfaceY + 0.6, rZ);
                
                // è®¡ç®—æ³•çº¿è§’åº¦ï¼Œè®©ç¤¼ç‰©ç¨å¾®è´´åˆæ›²é¢å€¾æ–œ
                // æ³•çº¿å‘é‡åœ¨ XY å¹³é¢æ˜¯ (rX, h)ï¼Œè§’åº¦æ˜¯ atan2(rX, h)
                const normalAngle = Math.atan2(rX, h);
                
                // è½åœ°å§¿æ€ï¼šå›´ç»•æ³•çº¿ç¨å¾®éšæœºæ—‹è½¬
                g.mesh.rotation.set(0, 0, -normalAngle); // åŸºç¡€å€¾æ–œ
                g.mesh.rotateY(Math.random() * Math.PI * 2); // éšæœºæœå‘
                g.mesh.rotateX((Math.random() - 0.5) * 0.5); // éšæœºå¾®è°ƒ

                // è®¾ç½®æ¶ˆå¤±å€’è®¡æ—¶
                g.life = 4.0; 
                g.fadeStartTime = this.elapsed;
                g.isSquashing = true;
                g.scaleTime = 0;

                // --- ğŸ’¥ å¢å¼ºè½åœ°ç‰¹æ•ˆ ---
                if (window.fwMgr) {
                    const worldPos = new THREE.Vector3();
                    g.mesh.getWorldPosition(worldPos);
                    // é¢œè‰²ï¼šé‡‘è‰² + çº¢è‰² + é›ªç™½
                    const landingPalette = [0xffd700, 0xff0000, 0xffffff];
                    window.fwMgr.explode(worldPos, landingPalette);
                    
                    // éŸ³æ•ˆ
                    if(audio) audio.explode(4); 
                }
            }

        } // End for loop
    }

    updateTrail(currentPos) {
        // æ·»åŠ æ–°ä½ç½®åˆ°å°¾è¿¹ï¼ˆå¸¦å›ºå®šçš„éšæœºåç§»ï¼Œåªåœ¨æ·»åŠ æ—¶è®¡ç®—ä¸€æ¬¡ï¼‰
        const trailPoint = currentPos.clone();
        trailPoint.x += (Math.random() - 0.5) * 6;
        trailPoint.y += (Math.random() - 0.5) * 3;
        trailPoint.z += (Math.random() - 0.5) * 6;
        this.trailPositions.unshift(trailPoint);

        // é™åˆ¶å°¾è¿¹é•¿åº¦
        if (this.trailPositions.length > 100) {
            this.trailPositions.pop();
        }

        // æ›´æ–°ç²’å­ä½ç½®ï¼ˆä¸å†æ¯å¸§éšæœºï¼Œä½¿ç”¨å·²å­˜å‚¨çš„ä½ç½®ï¼‰
        const positions = this.trail.geometry.attributes.position.array;
        for (let i = 0; i < 100; i++) {
            if (i < this.trailPositions.length) {
                const p = this.trailPositions[i];
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
            } else {
                // æœªä½¿ç”¨çš„ç²’å­ç§»åˆ°å¾ˆè¿œ
                positions[i * 3] = 0;
                positions[i * 3 + 1] = -1000;
                positions[i * 3 + 2] = 0;
            }
        }
        this.trail.geometry.attributes.position.needsUpdate = true;

        // å°¾è¿¹é€æ˜åº¦éšæ—¶é—´è¡°å‡
        this.trail.material.opacity = this.active ? 0.8 : 0;
    }
}

class Snow {
    constructor(sc) {
        const count = 3000; // Reduced from 6000 for mobile performance
        const pos = [];
        const velocities = []; // å­˜å‚¨ä¸‹è½é€Ÿåº¦å’Œåç§»
        
        for(let i=0; i<count; i++) {
            pos.push(
                (Math.random() * 2 - 1) * 400,
                Math.random() * 600,
                (Math.random() * 2 - 1) * 400
            );
            // x: ä¸‹è½é€Ÿåº¦, y: æ‘‡æ‘†é¢‘ç‡, z: æ‘‡æ‘†å¹…åº¦
            velocities.push(
                25 + Math.random() * 20, 
                0.5 + Math.random(), 
                5 + Math.random() * 10 
            );
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        // ç®€å•çš„é›ªèŠ±çº¹ç†
        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); cx.fillStyle='#fff'; cx.beginPath(); cx.arc(16,16,16,0,Math.PI*2); cx.fill();
        const tex = new THREE.CanvasTexture(cv);

        // è‡ªå®šä¹‰ Shader æè´¨
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTex: { value: tex },
                uHeight: { value: 600.0 } // è¾¹ç•Œé«˜åº¦
            },
            vertexShader: `
                uniform float uTime;
                uniform float uHeight;
                attribute vec3 velocity;
                varying float vAlpha;
                void main() {
                    vec3 pos = position;
                    // Yè½´ä¸‹è½è®¡ç®—ï¼š(åˆå§‹Y - é€Ÿåº¦*æ—¶é—´) å¯¹ é«˜åº¦å–æ¨¡
                    float fallOffset = velocity.x * uTime;
                    pos.y = mod(position.y - fallOffset, uHeight);
                    
                    // Xè½´æ‘‡æ‘†
                    pos.x += sin(uTime * velocity.y + position.y * 0.05) * velocity.z;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // è·ç¦»è¡°å‡ (å¯é€‰)
                    gl_PointSize = (300.0 / -mvPosition.z) * 0.8;
                    vAlpha = 0.8;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTex;
                varying float vAlpha;
                void main() {
                    vec4 color = texture2D(uTex, gl_PointCoord);
                    if (color.a < 0.5) discard;
                    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha * color.a);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.m = new THREE.Points(geo, mat);
        sc.add(this.m);
    }
    
    update(dt) {
        // CPU åªéœ€è¦æ›´æ–°ä¸€ä¸ªæ—¶é—´å˜é‡
        this.m.material.uniforms.uTime.value += dt;
    }
}

function setupControls() {
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 15; controls.maxDistance = 400;
    controls.addEventListener('start', () => STATE.interacting = true);
    controls.addEventListener('end', () => STATE.interacting = false);
}

// ===== ğŸ† çƒŸèŠ±æ‰¹é‡å‘å°„ (Global) =====
const launchBatch = () => {
    if(!STATE.started || document.visibilityState === 'hidden') return;
    const count = 2 + Math.floor(Math.random() * 4);
    for(let i=0; i<count; i++) {
        const delay = i * 300 + Math.random() * 200;
        setTimeout(() => fwMgr.launch(), delay);
    }
};

// ===== ğŸ„ åœ£è¯æ¨¡å¼çŠ¶æ€ç®¡ç† (Global) =====
let isXmasMode = false;
let backupCFG = {}; 

const activateChristmasMode = () => {
    if (isXmasMode) return;
    isXmasMode = true;
    STATE.christmasParty = true;
    console.log("ğŸ… åœ£è¯ç‹‚æ¬¢æ¨¡å¼å·²å¯åŠ¨ï¼");
    
    // å¤‡ä»½é…ç½®
    backupCFG = { autoFw: CFG.autoFw, fwRate: CFG.fwRate };

    // A. ç–¯ç‹‚çƒŸèŠ±
    CFG.autoFw = true; CFG.fwRate = 1.5;
    const tog = document.getElementById('tog-autofw'); if(tog) tog.checked = true;
    const rateVal = document.getElementById('val-fwrate'); if(rateVal) rateVal.innerText = '1.5s';
    if(autoTimer) clearInterval(autoTimer);
    autoTimer = setInterval(launchBatch, 1500);
    
    // B. åŠ é€Ÿ BGM
    if (audio) audio.setBgmSpeed(1.3); // æé€Ÿ 30%
};

const deactivateChristmasMode = () => {
    console.log("ğŸ… æ­£åœ¨æ‰§è¡Œå…¨æµç¨‹çŠ¶æ€å¤ä½...");
    
    // 1. æ¸…ç† 3D åœºæ™¯å¯¹è±¡
    MegaGiftManager.clear(); // ä½¿ç”¨æ–°çš„æ¸…ç†æ–¹æ³•
    IceTextManager.clear();  // æ¸…ç†å†°æ™¶æ–‡å­—
    
        // B. å½»åº•æ¸…é™¤æ‰€æœ‰æ•£è½çš„å°ç¤¼ç‰© (æ— è®ºåœ¨ç©ºä¸­è¿˜æ˜¯å·²è½åœ°)
        // æ–¹æ³•ï¼šç›´æ¥æ¸…ç©ºç®¡ç†ç»„çš„ childrenï¼Œå¹¶é‡Šæ”¾å†…å­˜
        if (STATE.spawnedGiftsGroup) {
            while(STATE.spawnedGiftsGroup.children.length > 0){ 
                const child = STATE.spawnedGiftsGroup.children[0];
                STATE.spawnedGiftsGroup.remove(child);
                
                // æ·±åº¦æ¸…ç†
                child.traverse(c => {
                    if (c.isMesh) {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) {
                            if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
                            else c.material.dispose();
                        }
                    }
                });
            }
        }
        // æ¸…ç©ºç‰©ç†æ¨¡æ‹Ÿæ•°ç»„
        window.rainGifts = [];

        // C. æ¸…ç†åœ£è¯è€äººæŠ•é€’çš„ç¤¼ç‰©
        if (santaSleigh && santaSleigh.fallingGifts) {
            santaSleigh.fallingGifts.forEach(g => {
                                if (g.mesh) {
                                    if (g.mesh.parent) g.mesh.parent.remove(g.mesh);
                                    else scene.remove(g.mesh);
                                    // ç§»é™¤å°¾è¿¹
                                    if(g.trail) g.trail.dispose();
                                    
                                    // ç®€å•é”€æ¯
                                    g.mesh.traverse(c => {
                                        if(c.geometry) c.geometry.dispose();
                                        if(c.material) {
                                            if(Array.isArray(c.material)) c.material.forEach(m=>m.dispose());
                                            else c.material.dispose();
                                        }
                                    });
                                }
            });
            santaSleigh.fallingGifts = [];
        }

        // D. æ¸…ç†ç«è½¦æ‰”å‡ºçš„ç¤¼ç‰©
        if (train && train.droppedGifts) {
            train.droppedGifts.forEach(g => {
                if (g.mesh) {
                    scene.remove(g.mesh);
                    g.mesh.traverse(c => {
                        if(c.geometry) c.geometry.dispose();
                        if(c.material) {
                            if(Array.isArray(c.material)) c.material.forEach(m=>m.dispose());
                            else c.material.dispose();
                        }
                    });
                }
            });
            train.droppedGifts = [];
        }

        // ============================================
        // 2. é‡ç½®æ¸¸æˆçŠ¶æ€ (Reset Game State)
    STATE.giftPhase = 'NONE';
    STATE.christmasParty = false;
    STATE.viewMode = 'FOLLOW';
    
    if (santaSleigh) {
        santaSleigh.nextTrigger = santaSleigh.elapsed + 20; 
    }

    // 3. è¿˜åŸé…ç½®ä¸ç¯å¢ƒ
    if (isXmasMode) {
        isXmasMode = false;
        
        CFG.autoFw = backupCFG.autoFw;
        CFG.fwRate = backupCFG.fwRate;

        const tog = document.getElementById('tog-autofw'); if(tog) tog.checked = CFG.autoFw;
        const rateVal = document.getElementById('val-fwrate'); if(rateVal) rateVal.innerText = CFG.fwRate + 's';
        
        if(autoTimer) clearInterval(autoTimer);
        if (CFG.autoFw) {
            autoTimer = setInterval(launchBatch, CFG.fwRate * 1000);
        }
        
            // è¿˜åŸç«è½¦çƒŸé›¾é¢œè‰²
            if (train && train.smokeMesh && train.smokeMesh.material) {
                train.smokeMesh.material.color.setHex(0xdddddd);
                train.smokeMesh.material.emissive.setHex(0x000000);
            }
            
            // è¿˜åŸ BGM é€Ÿåº¦
            if (audio) audio.setBgmSpeed(1.0);
        }

        // ============================================
        // 4. å¼ºåˆ¶ä¿®å¤ UI çŠ¶æ€ (Reset UI)
    const countdownTrigger = document.getElementById('countdown-trigger');
    if(countdownTrigger) countdownTrigger.style.display = 'flex';
    
    isChristmasUIActive = false; // é‡ç½® UI é”
    
    const countdownPanel = document.getElementById('countdown-panel');
    if (countdownPanel) {
        countdownPanel.classList.remove('christmas-card');
    }
};

// ä»…ä»…æ”¶èµ·è´ºå¡ï¼Œä¸é€€å‡ºç‹‚æ¬¢æ¨¡å¼
const dismissChristmasCard = () => {
    // 1. éšè—è´ºå¡
    const cp = document.getElementById('countdown-panel');
    if(cp) cp.classList.remove('show');
    
    // 2. æ¢å¤å³ä¸Šè§’æŒ‰é’®
    const trig = document.getElementById('countdown-trigger');
    if(trig) trig.style.display = 'flex';

    // 3. é•œå¤´å›åˆ°ç«è½¦
    CameraDirector.startCruise();
};

function setupUI() {
    const btn = document.getElementById('start-btn');

    // æ‰¹é‡å‘å°„çƒŸèŠ±ï¼ˆæå‰å®šä¹‰ï¼Œä¾›ä¸‹æ–¹å›è°ƒä½¿ç”¨ï¼‰
    btn.onclick = () => {
        try {
            STATE.started = true;
            STATE.running = true;
            STATE.viewMode = 'INTRO'; // ğŸš« å…³é”®ä¿®å¤ï¼šæš‚æ—¶å±è”½ä¸»å¾ªç¯çš„ç›¸æœºæ§åˆ¶ï¼Œé˜²æ­¢æŠ–åŠ¨
            
            // Audio Init can fail if user didn't interact (but this is a click handler, so it's fine)
            audio.init(); 
            audio.whistle(); 
            audio.playBGM(); 
            
            // è‡ªåŠ¨ç‡ƒæ”¾çš„å¯åŠ¨é€»è¾‘ï¼ˆå»¶è¿Ÿç­‰å¾…é™è½åŠ¨ç”»å®Œæˆï¼‰
            if (CFG.autoFw) {
                setTimeout(() => {
                    if (!STATE.started) return; // é˜²æ­¢ç”¨æˆ·å¿«é€Ÿå…³é—­
                    launchBatch(); 
                    autoTimer = setInterval(launchBatch, CFG.fwRate * 1000);
                }, 2500); // å»¶è¿Ÿ2.5ç§’ï¼Œç­‰é™è½åŠ¨ç”»å®Œæˆ
            }

            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('start-screen').style.display = 'none', 800);
            document.getElementById('hud').style.opacity = 1;
            document.getElementById('settings-btn').style.opacity = 1;
            document.getElementById('firework-btn').style.opacity = 1;
            document.getElementById('countdown-wrap').style.opacity = 1;

            // é¦–æ¬¡å±•ç¤ºåœ£è¯å€’è®¡æ—¶
            if (window.showCountdownFirstTime) window.showCountdownFirstTime();

            // ğŸš å¯åŠ¨è¿é•œï¼šæ— äººæœºä»ä¾§é¢é«˜ç©ºé™è½
            // åˆå§‹åŒ–å½“å‰æ— äººæœºä¸ºç¬¬ä¸€ä¸ªï¼ˆæˆ–æ ¹æ®ç«è½¦ä½ç½®é€‰æ‹©æœ€è¿‘çš„ï¼‰
            CameraDirector.state.currentDrone = Math.floor(train.prog * CameraDirector.config.droneCount) % CameraDirector.config.droneCount;

            // è®¡ç®—ç›®æ ‡è·Ÿæ‹ä½ç½®
            const endPos = new THREE.Vector3();
            const endTarget = new THREE.Vector3();
            CameraDirector.getDronePosition(CameraDirector.state.currentDrone, train.prog, endPos, endTarget);

            // èµ·å§‹ä½ç½®ï¼šç›®æ ‡ä½ç½®çš„æ­£ä¸Šæ–¹ + ä¾§å‘åç§»ï¼ˆæ¨¡æ‹Ÿæ— äººæœºä»ä¾§é¢é«˜ç©ºé£æ¥ï¼‰
            const startPos = endPos.clone();
            startPos.y += 120; // ä»é«˜ç©ºå¼€å§‹
            startPos.x += 60;  // ä¾§å‘åç§»
            startPos.z += 40;

            // èµ·å§‹çœ‹å‘ç‚¹ï¼šåœºæ™¯ä¸­å¿ƒï¼ˆä¿¯ç°å…¨æ™¯ï¼‰
            const startTarget = new THREE.Vector3(0, 0, 0);

            // è®¾ç½®åˆå§‹ç›¸æœºä½ç½®
            camera.position.copy(startPos);
            camera.lookAt(startTarget);
            controls.target.copy(startTarget);

            let t = 0;
            const iv = setInterval(() => {
                t += 0.012; // ç¨æ…¢ä¸€ç‚¹ï¼Œæ›´æœ‰ç”µå½±æ„Ÿ

                if (t >= 1) {
                    clearInterval(iv);
                    STATE.viewMode = 'FOLLOW'; // âœ… åŠ¨ç”»ç»“æŸï¼Œæ— ç¼åˆ‡æ¢å›æ™ºèƒ½è·Ÿæ‹æ¨¡å¼
                    // ç¡®ä¿æœ€ç»ˆä½ç½®ç²¾ç¡®
                    camera.position.copy(endPos);
                    controls.target.copy(endTarget);
                } else {
                    // ä½¿ç”¨ ease-out æ›²çº¿ï¼Œå¼€å§‹å¿«ç»“æŸæ…¢ï¼ˆåƒæ— äººæœºå‡é€Ÿé™è½ï¼‰
                    const k = 1 - Math.pow(1 - t, 3);

                    // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆç«è½¦åœ¨ç§»åŠ¨ï¼‰
                    CameraDirector.getDronePosition(CameraDirector.state.currentDrone, train.prog, endPos, endTarget);

                    // æ’å€¼ç›¸æœºä½ç½®
                    camera.position.lerpVectors(startPos, endPos, k);

                    // æ’å€¼çœ‹å‘ç‚¹ï¼ˆä»å…¨æ™¯è¿‡æ¸¡åˆ°è·Ÿè¸ªç«è½¦ï¼‰
                    const lookTarget = new THREE.Vector3();
                    lookTarget.lerpVectors(startTarget, endTarget, k);
                    camera.lookAt(lookTarget);
                    controls.target.copy(lookTarget);
                }
            }, 16);
        } catch(e) {
            console.error("Start Error:", e);
            alert("å¯åŠ¨æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é‡è¯•: " + e.message);
        }
    };

    // ===== ğŸ› ï¸ æ–°ç‰ˆè®¾ç½®é¢æ¿é€»è¾‘ (Custom Tabbed UI) =====
    const setBtn = document.getElementById('settings-btn');
    const modal = document.getElementById('settings-modal');
    const overlay = document.getElementById('modal-overlay');

    // åˆå§‹åŒ–é¢æ¿ HTML ç»“æ„
    modal.innerHTML = `
        <div class="settings-header">
            <h2>ğŸ„ æ§åˆ¶ä¸­å¿ƒ</h2>
            <button class="close-btn" id="close-settings">Ã—</button>
        </div>
        <div class="settings-tabs">
            <button class="tab-btn active" data-tab="tab-audio">ğŸ”Š éŸ³é¢‘</button>
            <button class="tab-btn" data-tab="tab-graphics">ğŸ¨ ç”»é¢</button>
            <button class="tab-btn" data-tab="tab-controls">ğŸ® æ“æ§</button>
        </div>
        <div class="settings-body">
            <!-- éŸ³é¢‘è®¾ç½® -->
            <div id="tab-audio" class="tab-content active">
                <div class="control-group">
                    <div class="control-label"><span>æ€»éŸ³é‡</span><span id="val-master" class="control-val">70%</span></div>
                    <input type="range" id="inp-master" min="0" max="1" step="0.05" value="0.7">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>èƒŒæ™¯éŸ³ä¹</span><span id="val-bgm" class="control-val">60%</span></div>
                    <input type="range" id="inp-bgm" min="0" max="1" step="0.05" value="0.6">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>ç«è½¦éŸ³æ•ˆ</span><span id="val-train" class="control-val">80%</span></div>
                    <input type="range" id="inp-train" min="0" max="1" step="0.05" value="0.8">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>çƒŸèŠ±éŸ³æ•ˆ</span><span id="val-fw" class="control-val">100%</span></div>
                    <input type="range" id="inp-fw" min="0" max="1" step="0.05" value="1.0">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>çˆ†ç‚¸é£æ ¼</span></div>
                    <select id="sel-fw-style">
                        <option value="-1">ğŸ² éšæœº (Random)</option>
                        ${SOUND_STYLES.map((s,i) => `<option value="${i}">${i}. ${s.name}</option>`).join('')}
                    </select>
                </div>
            </div>

            <!-- ç”»é¢è®¾ç½® -->
            <div id="tab-graphics" class="tab-content">
                <div class="control-group">
                    <div class="control-label"><span>è¾‰å…‰å¼ºåº¦ (Bloom)</span><span id="val-bloom" class="control-val">0.7</span></div>
                    <input type="range" id="inp-bloom" min="0" max="3" step="0.1" value="0.7">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>æœˆå…‰äº®åº¦</span><span id="val-moon" class="control-val">2.5</span></div>
                    <input type="range" id="inp-moon" min="0" max="5" step="0.1" value="2.5">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>å¤§é›¾æµ“åº¦</span><span id="val-fog" class="control-val">0.0004</span></div>
                    <input type="range" id="inp-fog" min="0" max="0.005" step="0.0001" value="0.0004">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>è½¦ç¯äº®åº¦</span><span id="val-headlight" class="control-val">100</span></div>
                    <input type="range" id="inp-headlight" min="0" max="200" step="10" value="100">
                </div>
            </div>

            <!-- æ“æ§è®¾ç½® -->
            <div id="tab-controls" class="tab-content">
                <div class="control-group">
                    <div class="control-label"><span>ç‡ƒæ”¾é—´éš”</span><span id="val-fwrate" class="control-val">4s</span></div>
                    <input type="range" id="inp-fwrate" min="2" max="15" step="1" value="4">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>ç«è½¦æé€Ÿ</span><span id="val-speed" class="control-val">0.10</span></div>
                    <input type="range" id="inp-speed" min="0.02" max="0.4" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>æ— äººæœºé«˜åº¦</span><span id="val-height" class="control-val">40</span></div>
                    <input type="range" id="inp-height" min="10" max="80" step="1" value="40">
                </div>
                <div class="control-group">
                    <div class="control-label"><span>è·Ÿæ‹è·ç¦»</span><span id="val-dist" class="control-val">100</span></div>
                    <input type="range" id="inp-dist" min="30" max="150" step="5" value="100">
                </div>
            </div>
        </div>
    `;

    // ç»‘å®šé€»è¾‘ (Helper)
    const bindRange = (id, targetObj, key, displayId, callback) => {
        const el = document.getElementById(id);
        const disp = document.getElementById(displayId);
        if (!el) return; // safety
        el.value = targetObj[key]; // init
        if(disp) disp.innerText = targetObj[key];
        
        el.oninput = (e) => {
            const v = parseFloat(e.target.value);
            targetObj[key] = v;
            if(disp) disp.innerText = v;
            if(callback) callback(v);
        };
    };
    
    // çƒŸèŠ±é£æ ¼é€‰æ‹©
    const selStyle = document.getElementById('sel-fw-style');
    window.getFireworkSoundStyle = () => parseInt(selStyle.value);

    // ç”»é¢ç»‘å®š
    bindRange('inp-bloom', CFG, 'bloomStr', 'val-bloom', v => bloomPass.strength = v);
    bindRange('inp-moon', CFG, 'moonInt', 'val-moon', v => lights.moon.intensity = v);
    bindRange('inp-fog', CFG, 'fogDen', 'val-fog', v => scene.fog.density = v);
    bindRange('inp-headlight', CFG, 'lightPow', 'val-headlight', v => emissives.forEach(o => { if(o.userData.type==='headlight_spot') o.intensity=v }));

    // æ“æ§ç»‘å®š
    bindRange('inp-speed', CFG, 'maxSpeed', 'val-speed');
    
    // éŸ³é¢‘ç»‘å®š
    bindRange('inp-master', audio.vol, 'master', 'val-master', () => audio.updateVols());
    bindRange('inp-bgm', audio.vol, 'bgm', 'val-bgm', () => audio.updateVols());
    bindRange('inp-train', audio.vol, 'train', 'val-train', () => audio.updateVols());
    bindRange('inp-fw', audio.vol, 'firework', 'val-fw', () => audio.updateVols());

    bindRange('inp-height', CameraDirector.config, 'height', 'val-height');
    bindRange('inp-dist', CameraDirector.config, 'distance', 'val-dist');
    
    bindRange('inp-fwrate', CFG, 'fwRate', 'val-fwrate', v => {
        document.getElementById('val-fwrate').innerText = v + 's';
        if(CFG.autoFw) {
            clearInterval(autoTimer);
            autoTimer = setInterval(launchBatch, v * 1000);
        }
    });

    // æ ‡ç­¾åˆ‡æ¢é€»è¾‘
    const tabs = modal.querySelectorAll('.tab-btn');
    const contents = modal.querySelectorAll('.tab-content');
    tabs.forEach(btn => {
        btn.onclick = () => {
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById(btn.dataset.tab).classList.add('active');
        };
    });

    // æ‰“å¼€/å…³é—­é¢æ¿
    const closeBtn = document.getElementById('close-settings');
    const toggleSettings = () => {
        STATE.settings = !STATE.settings;
        const disp = STATE.settings ? 'flex' : 'none'; // Flex needed for modal layout
        modal.style.display = disp;
        overlay.style.display = disp;
    };
    setBtn.onclick = toggleSettings;
    overlay.onclick = toggleSettings;
    closeBtn.onclick = toggleSettings;

    // ===== ğŸ† çƒŸèŠ±æŒ‰é’® =====
    const fwBtn = document.getElementById('firework-btn');
    fwBtn.onclick = () => {
        if (!STATE.started) return;
        // ç‚¹å‡»ç‰¹æ•ˆ
        fwBtn.classList.add('burst');
        setTimeout(() => fwBtn.classList.remove('burst'), 400);
        // å‘å°„çƒŸèŠ±
        launchBatch();
    };

    // ===== ğŸš‚ å¯åœæŒ‰é’® =====
    const trainToggle = document.getElementById('train-toggle');
    const hudStatus = document.getElementById('hud-status');
    const dot = document.getElementById('d-status');

    const updateTrainUI = () => {
        trainToggle.textContent = STATE.running ? 'â¸ï¸' : 'â–¶ï¸';
        dot.classList.toggle('stop', !STATE.running);
    };

    trainToggle.onclick = () => {
        if (!STATE.started) return;
        STATE.running = !STATE.running;
        if (STATE.running) {
            audio.whistle();
        }
        updateTrainUI();
    };

    // ===== ğŸš æ¨¡å¼åˆ‡æ¢ï¼ˆç‚¹å‡»HUDçŠ¶æ€æ–‡å­—ï¼‰ =====
    hudStatus.onclick = () => {
        if (!STATE.started) return;

        if (STATE.viewMode === 'FOLLOW') {
            // åˆ‡æ¢åˆ°è‡ªç”±æ¢ç´¢
            STATE.viewMode = 'FREE';
            hudStatus.textContent = 'è‡ªç”±æ¢ç´¢æ¨¡å¼';
            dot.style.background = '#4fc3f7';
            dot.style.boxShadow = '0 0 8px #4fc3f7';
        } else {
            // åˆ‡æ¢å›æ™ºèƒ½é©¾é©¶ï¼šå¹³æ»‘è¿‡æ¸¡åˆ°æ­£ç¡®çš„æ— äººæœºä½ç½®
            hudStatus.textContent = 'æ™ºèƒ½é©¾é©¶æ¨¡å¼';
            dot.style.background = STATE.running ? '#00ff00' : '#ff3300';
            dot.style.boxShadow = STATE.running ? '0 0 8px #00ff00' : '0 0 8px #ff3300';

            CameraDirector.startCruise();
        }
    };

    // ===== ğŸ–±ï¸ åœºæ™¯ç‚¹å‡»äº¤äº’ =====
    const cvs = document.getElementById('canvas-container');
    cvs.addEventListener('pointerdown', () => STATE.clickTime = Date.now());
    cvs.addEventListener('pointerup', (e) => {
        if (Date.now() - STATE.clickTime < 200 && STATE.started && !STATE.settings) {
            mouse.x = (e.clientX / innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, camera);

            const hitTrain = ray.intersectObjects(train.grp.children, true);
            if (hitTrain.length > 0) {
                const hitObj = hitTrain[0].object;

                // åˆ¤æ–­æ˜¯å¦ç‚¹å‡»çš„æ˜¯ç«è½¦å¤´
                let isLoco = false;
                hitObj.traverseAncestors(p => { if (p === train.loco) isLoco = true; });

                if (isLoco) {
                    // ğŸµ ç‚¹å‡»ç«è½¦å¤´ â†’ BGM å¼€/å…³
                    if (audio.isBgmPlaying) {
                        audio.stopBGM();
                    } else {
                        audio.playBGM();
                    }
                } else {
                    // ğŸ”” ç‚¹å‡»è½¦å¢ â†’ çª—æˆ·é—ªçƒ + æ‰”ç¤¼ç›’ + é“ƒé“›å“
                    // æ‰¾åˆ°è¢«ç‚¹å‡»çš„è½¦å¢
                    let clickedCar = null;
                    hitObj.traverseAncestors(p => {
                        if (train.cars.includes(p)) clickedCar = p;
                    });

                    if (clickedCar) {
                        // å°è¯•æ‰”ç¤¼ç›’ï¼ˆæœ‰å†·å´é™åˆ¶ï¼‰
                        if (train.throwGift(clickedCar)) {
                            train.flashWindows(clickedCar);
                            audio.bell();
                        }
                    } else {
                        audio.bell();
                    }
                }
                return;
            }

            // ğŸ æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¤§ç¤¼ç›’
            if (STATE.giftPhase === 'WAITING' && MegaGiftManager.mesh) {
                const hitGift = ray.intersectObject(MegaGiftManager.mesh, true);
                if (hitGift.length > 0) {
                    MegaGiftManager.open();
                    return;
                }
            }

            // ç‚¹å‡»ç©ºåœ°ï¼šæ— ååº”ï¼ˆå·²ç§»é™¤æ‰‹åŠ¨çƒŸèŠ±ï¼‰
        }
    });

    // ===== ğŸ„ åœ£è¯å€’è®¡æ—¶ =====
    const countdownTrigger = document.getElementById('countdown-trigger');
    const countdownPanel = document.getElementById('countdown-panel');
    const countdownDays = document.getElementById('countdown-days');
    const countdownDetail = document.getElementById('countdown-detail');
    let countdownExpanded = false;
    let countdownFirstShow = false;
    let lastCountdownSec = -1; // è®°å½•ä¸Šä¸€ç§’ï¼Œç”¨äºè§¦å‘æ¯ç§’åŠ¨ç”»

    // 0. å…¨å±€é…ç½®
    const TEST_MODE = true; // ğŸ”´ æµ‹è¯•æ¨¡å¼å¼€å…³ (1=å¼€å¯, 0=å…³é—­)
    const TEST_OFFSET = 30000; // æµ‹è¯•æ¨¡å¼åç§»é‡ (30ç§’)
    
    let targetTime = null; // ç›®æ ‡æ—¶åˆ» (Timestamp)
    let currentStyle = 'style-flap'; // é»˜è®¤é£æ ¼

    // é£æ ¼åˆ—è¡¨
    const STYLES = ['style-flap', 'style-royal', 'style-cyber'];

    // 1. åˆå§‹åŒ–å€’è®¡æ—¶ç›®æ ‡
    const initCountdownTarget = () => {
        const now = Date.now();
        const date = new Date();
        
        // A. èŠ‚æ—¥å½“å¤©æ£€æµ‹ (12æœˆ25æ—¥)
        // æ³¨æ„ï¼šå¦‚æœæ˜¯æµ‹è¯•æ¨¡å¼ï¼Œæˆ‘ä»¬ä¸è‡ªåŠ¨åˆ¤å®šä¸ºå½“å¤©ï¼Œè€Œæ˜¯å¼ºåˆ¶èµ°æµ‹è¯•å€’è®¡æ—¶
        if (!TEST_MODE && date.getMonth() === 11 && date.getDate() === 25) {
            return 'TODAY';
        }

        // B. æµ‹è¯•æ¨¡å¼ (1åˆ†4ç§’å)
        if (TEST_MODE) {
            targetTime = now + TEST_OFFSET;
            console.log(`ğŸ”´ æµ‹è¯•æ¨¡å¼å¯åŠ¨: ç›®æ ‡æ—¶é—´ set to +${TEST_OFFSET/1000}s`);
            return 'COUNTDOWN';
        }

        // C. æ­£å¸¸å€’è®¡æ—¶ (ç›´åˆ°ä¸‹ä¸€ä¸ª 12æœˆ25æ—¥ 00:00:00)
        let year = date.getFullYear();
        let xmas = new Date(year, 11, 25, 0, 0, 0);
        if (date > xmas) xmas = new Date(year + 1, 11, 25, 0, 0, 0);
        
        targetTime = xmas.getTime();
        return 'COUNTDOWN';
    };

    // 2. éšæœºé€‰æ‹© UI é£æ ¼
    const randomizeCountdownStyle = () => {
        // ç§»é™¤æ—§é£æ ¼
        STYLES.forEach(s => countdownPanel.classList.remove(s));
        // éšæœºæ–°é£æ ¼
        currentStyle = STYLES[Math.floor(Math.random() * STYLES.length)];
        countdownPanel.classList.add(currentStyle);
        // console.log("ğŸ¨ Countdown Style:", currentStyle);
    };

    // 3. æ ¸å¿ƒè®¡ç®—å‡½æ•° (ä¾èµ– Date.now() ç¡®ä¿åå°å‡†ç¡®)
    const getCountdownData = () => {
        if (!targetTime) return null; // æœªåˆå§‹åŒ–

        const now = Date.now();
        const diff = targetTime - now;

        if (diff <= 0) {
            return { finished: true, totalSeconds: 0 };
        }

        const totalSeconds = Math.ceil(diff / 1000);
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        return { finished: false, days, hours, minutes, seconds, totalSeconds };
    };
    
    // 4. æ›´æ–° UI
    const updateCountdown = () => {
        // å¦‚æœæ­£åœ¨ç‹‚æ¬¢ä¸­ï¼Œä¸éœ€è¦æ›´æ–° UI (Led/Iceæ–‡å­—æ¥ç®¡)
        if (STATE.christmasParty) return;

        const data = getCountdownData();
        
        // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæ˜¯ TODAY æ¨¡å¼ï¼ˆä¸”æœªè§¦å‘è¿‡ï¼‰
        if (targetTime === 'TODAY') {
             // è¿™é‡Œåº”è¯¥åœ¨ init æ—¶å¤„ç†ï¼Œä¸åº”è¿›å…¥ update å¾ªç¯
             return; 
        }

        if (data && data.finished) {
            // --- ğŸ„ å€’è®¡æ—¶ç»“æŸ ---
            
            // éšè—å¤§æ•°å­—
            const finalEl = document.getElementById('final-countdown');
            if (finalEl) finalEl.style.display = 'none';
            lastCountdownSec = -1;

            // è§¦å‘å¤§ç¤¼ç›’ (ä»…è§¦å‘ä¸€æ¬¡)
            if (STATE.giftPhase === 'NONE') {
                toggleCountdown(false);
                countdownTrigger.style.display = 'none'; 
                MegaGiftManager.spawn();
                audio.whistle();
            }
        } else if (data) {
            // --- ğŸ“… å€’è®¡æ—¶è¿›è¡Œä¸­ ---
            
            // å¦‚æœé¢æ¿å¤„äº"è´ºå¡æ¨¡å¼"(æ—§é€»è¾‘æ®‹ç•™)ï¼Œæ¢å¤å®ƒ
            if (isChristmasUIActive) {
                isChristmasUIActive = false;
                countdownTrigger.style.display = 'flex';
                countdownPanel.classList.remove('christmas-card');
            }

            // æ›´æ–°æ–‡æœ¬
            const detailEl = document.getElementById('countdown-detail');
            if (detailEl) {
                const pad = n => n.toString().padStart(2, '0');
                // çº¢è‰²è­¦æŠ¥æ•ˆæœ (æœ€å10ç§’)
                if (data.days === 0 && data.hours === 0 && data.minutes === 0 && data.seconds <= 10) {
                    detailEl.style.color = '#ff3300';
                    detailEl.style.textShadow = '0 0 10px #ff0000';
                } else {
                    detailEl.style.color = ''; // æ¢å¤é»˜è®¤(ç”±CSSç±»æ§åˆ¶)
                    detailEl.style.textShadow = '';
                }
                detailEl.innerHTML = `${data.days}<span>å¤©</span> ${pad(data.hours)}:${pad(data.minutes)}:${pad(data.seconds)}`;
            }
            
            if(countdownDays) countdownDays.textContent = data.days;

            // å€’è®¡æ—¶æœ€å 5 ç§’å…¨å±ç‰¹æ•ˆ
            const finalEl = document.getElementById('final-countdown');
            if (data.totalSeconds > 0 && data.totalSeconds <= 5) {
                // è‡ªåŠ¨æ”¶èµ·å³ä¸Šè§’é¢æ¿ï¼Œé¿å…å¹²æ‰°
                if (countdownExpanded) toggleCountdown(false);
                
                finalEl.style.display = 'block';
                finalEl.innerText = data.totalSeconds;
                
                if (lastCountdownSec !== data.totalSeconds) {
                    lastCountdownSec = data.totalSeconds;
                    finalEl.classList.remove('pop');
                    void finalEl.offsetWidth; 
                    finalEl.classList.add('pop');
                    if(audio && audio.bell) audio.bell();
                }
            } else {
                finalEl.style.display = 'none';
                lastCountdownSec = -1;
            }
        }
    };

    // åˆ‡æ¢å±•å¼€/æ”¶èµ·
    const toggleCountdown = (forceState) => {
        countdownExpanded = forceState !== undefined ? forceState : !countdownExpanded;
        countdownTrigger.classList.toggle('expanded', countdownExpanded);
        countdownPanel.classList.toggle('show', countdownExpanded);
        
        // å±•å¼€æ—¶åˆ·æ–°ä¸€ä¸‹é£æ ¼(å¯é€‰ï¼Œè¿™é‡Œåªåœ¨åˆå§‹åŒ–æ—¶éšæœº)
        // if(countdownExpanded) randomizeCountdownStyle();
    };

    // ç»‘å®šäº‹ä»¶
    countdownTrigger.onclick = (e) => {
        e.stopPropagation();
        toggleCountdown();
    };

    document.addEventListener('click', (e) => {
        if (countdownExpanded && !countdownPanel.contains(e.target) && !countdownTrigger.contains(e.target)) {
            toggleCountdown(false);
        }
    });

    countdownPanel.onclick = () => toggleCountdown(false);

    // é¦–æ¬¡å±•ç¤ºé€»è¾‘ (Auto Show)
    window.showCountdownFirstTime = () => {
        if (countdownFirstShow) return;
        countdownFirstShow = true;
        
        // åˆå§‹åŒ–çŠ¶æ€
        const status = initCountdownTarget();
        randomizeCountdownStyle(); // ğŸ² éšæœºé£æ ¼

        // ğŸ„ æƒ…å†µ A: å·²ç»æ˜¯åœ£è¯èŠ‚ (ç›´è¾¾ç‹‚æ¬¢)
        if (status === 'TODAY') {
            console.log("ğŸ… Merry Christmas! Auto-starting Party Mode.");
            
            // 1. ç«‹å³å€’æ•° 5 ç§’ (è™šæ‹Ÿæµç¨‹)
            // ä¸ºäº†è®©ç”¨æˆ·çœ‹åˆ°ä¸€ç‚¹è¿‡ç¨‹ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸ªæçŸ­çš„å€’è®¡æ—¶
            targetTime = Date.now() + 5999; 
            
            // 2. å¼ºåˆ¶å±•å¼€é¢æ¿
            toggleCountdown(true);
            
            // 3. è¿™é‡Œçš„ updateCountdown ä¼šè‡ªåŠ¨æ¥ç®¡ï¼Œå¹¶åœ¨5ç§’åè§¦å‘ MegaGiftManager
            return;
        }

        // ğŸ“… æƒ…å†µ B: æ­£å¸¸å€’è®¡æ—¶ (æˆ–æµ‹è¯•æ¨¡å¼)
        // å»¶è¿Ÿä¸€ç‚¹æ˜¾ç¤ºï¼Œè®©ç”¨æˆ·å…ˆçœ‹ä¸€çœ¼ç«è½¦
        setTimeout(() => {
            toggleCountdown(true);
            // 3ç§’åè‡ªåŠ¨æ”¶èµ· -> å·²ç§»é™¤ï¼Œç°åœ¨ä¿æŒå±•å¼€ç›´åˆ°æœ€å5ç§’
        }, 1500);
    };

    // å¯åŠ¨å®šæ—¶å™¨
    setInterval(updateCountdown, 1000);
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡ä»¥é˜²ç©ºç™½
    // updateCountdown(); // æ­¤æ—¶ targetTime å¯èƒ½è¿˜æ²¡ set (åœ¨ showCountdownFirstTime é‡Œ set)
}

window.onresize = () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
};

try {
    init();
} catch (e) {
    console.error("Critical Init Error:", e);
    alert("æ— æ³•å¯åŠ¨åº”ç”¨ (Init Error): " + e.message);
}
</script>
    </body>
</html>
