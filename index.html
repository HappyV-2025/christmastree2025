<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8"><meta name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Christmas Express: Definitive Edition</title>
        <style>
    body{margin:0;overflow:hidden;background:#000;font-family:'Segoe UI',sans-serif;user-select:none}
    #canvas-container{width:100vw;height:100vh;display:block}
    /* UI Overlay */
    #start-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle at center,#1b2028 0%,#000 100%);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100;transition:opacity 0.8s}
    .card{background:rgba(255,255,255,0.06);padding:40px;border-radius:24px;border:1px solid rgba(255,255,255,0.1);text-align:center;backdrop-filter:blur(20px);box-shadow:0 40px 80px rgba(0,0,0,0.6);width:400px}
    h1{color:#ffb300;margin:0 0 20px;letter-spacing:4px;text-shadow:0 0 30px rgba(255,165,0,0.5);text-transform:uppercase}
    .tips{color:#ccc;font-size:14px;line-height:2.2;text-align:left;margin-bottom:30px}
    .k{color:#4fc3f7;font-weight:bold;margin-right:8px;border-bottom:1px dashed #4fc3f7}
    button{background:linear-gradient(135deg,#d32f2f,#b71c1c);color:#fff;border:none;padding:16px 60px;font-size:20px;border-radius:50px;cursor:pointer;box-shadow:0 10px 30px rgba(211,47,47,0.4);transition:0.2s;font-weight:bold;letter-spacing:1px}
    button:hover{transform:scale(1.05);box-shadow:0 15px 40px rgba(211,47,47,0.6)}
    #hud{position:absolute;top:20px;left:20px;z-index:10;opacity:0;transition:1s}
    .tag{background:rgba(0,0,0,0.7);color:#fff;padding:8px 18px;border-radius:30px;font-size:14px;border:1px solid #ffffff22;backdrop-filter:blur(5px);display:flex;align-items:center;gap:10px}
    .dot{width:8px;height:8px;background:#00ff00;border-radius:50%;box-shadow:0 0 8px #00ff00;transition:0.3s}
    .dot.stop{background:#ff3300;box-shadow:0 0 8px #ff3300}
    #settings-btn{position:absolute;top:20px;right:20px;z-index:20;width:44px;height:44px;background:rgba(255,255,255,0.1);border-radius:50%;border:1px solid #ffffff33;color:#fff;font-size:20px;display:flex;justify-content:center;align-items:center;cursor:pointer;opacity:0;backdrop-filter:blur(5px)}
    #settings-modal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:30;display:none;width:320px}
    #modal-overlay{position:absolute;top:0;left:0;width:100%;height:100%;z-index:25;display:none;background:rgba(0,0,0,0.5)}
    #loading{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);color:#666;font-size:12px;letter-spacing:2px}
</style>
    </head>
    <body>
        <div id="start-screen"><div class="card">
                <h1>ğŸ„ åœ£è¯å¿«ä¹</h1>
                <div class="tips">
                    <div><span class="k">ğŸš‚ ç‚¹å‡»ç«è½¦</span> å¯åŠ¨ / åœæ­¢ (æƒ¯æ€§æ»‘è¡Œ)</div>
                    <div><span class="k">ğŸ† ç‚¹å‡»ç©ºåœ°</span> ç‡ƒæ”¾ç‰©ç†çƒŸèŠ±</div>
                    <div><span class="k">ğŸ–±ï¸ æ»šè½®ç¼©æ”¾</span> è°ƒæ•´è·Ÿéšè·ç¦» (è‡ªåŠ¨è®°å¿†)</div>
                    <div><span class="k">ğŸ‘† æ‹–åŠ¨æ—‹è½¬</span> 360Â° è‡ªç”±è§‚å¯Ÿ</div>
                </div>
                <button id="start-btn">é¸£ç¬›å‘è½¦</button>
            </div></div>
        <div id="hud"><div class="tag"><div id="d-status"
                    class="dot"></div><span
                    id="t-status">æ™ºèƒ½é©¾é©¶æ¨¡å¼</span></div></div>
        <div id="settings-btn">âš™ï¸</div>
        <div id="modal-overlay"></div><div id="settings-modal"></div>
        <div id="loading">æ­£åœ¨è£…è½½ç¤¼ç‰©ä¸é­”æ³•...</div>
        <div id="canvas-container"></div>

        <script
            type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
        <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


// ==========================================
// ğŸ§¨ 12ç§çƒŸèŠ±éŸ³æ•ˆé¢„è®¾ (å¤åˆ¶åˆ°ä»£ç æœ€å‰é¢æˆ– AudioEngine é™„è¿‘)
// ==========================================
const SOUND_STYLES = [
    // 0. æ ‡å‡†å¹³è¡¡ (Standard)
    { name: "æ ‡å‡†", noise: {f:800, q:1, vol:3, dur:1.5}, kick: {f:60, vol:2.5, dur:0.3} },
    
    // 1. å·¨å‹é‡ç‚® (Heavy/Deep) - é€‚åˆå¤§çƒŸèŠ±ï¼Œä½éŸ³é‡ï¼Œå›å£°é•¿
    { name: "å·¨å‹é‡ç‚®", noise: {f:300, q:0.5, vol:4, dur:2.5}, kick: {f:50, vol:4.0, dur:0.5} },

    // 3. é—·å“ (Muffled/Distant) - åƒæ˜¯åœ¨è¿œå¤„çš„çˆ†ç‚¸
    { name: "è¿œå¤„é—·å“", noise: {f:200, q:0, vol:3, dur:1.0}, kick: {f:40, vol:2.0, dur:0.4} },
    
    // 4. é‡‘å±å›éŸ³ (Metallic) - å¸¦æœ‰å…±é¸£æ„Ÿ
    { name: "é‡‘å±å›éŸ³", noise: {f:1200, q:10, vol:2, dur:1.8}, kick: {f:80, vol:1.5, dur:0.2} },
    
    // 5. ç©ºæ°”çˆ†ç ´ (Airy) - ä¸»è¦æ˜¯æ°”æµå£°ï¼Œæ¯”è¾ƒæŸ”å’Œ
    { name: "ç©ºæ°”çˆ†ç ´", noise: {f:600, q:0.1, vol:2, dur:0.8}, kick: {f:30, vol:3.0, dur:0.4} },
    
    // 6. ç¤¼èŠ±å¼¹ (Shell) - å…ˆæœ‰ä¸€æ®µå°–å•¸ï¼ˆæ¨¡æ‹Ÿï¼‰ï¼Œè¿™é‡Œä¸»è¦è¡¨ç°ç‚¸å¼€çš„æ•£è½æ„Ÿ
    { name: "ç¤¼èŠ±æ•£è½", noise: {f:1000, q:0.5, vol:1.5, dur:3.0}, kick: {f:55, vol:2.0, dur:0.2} },
    
    // 7. æè‡´éœ‡æ’¼ (Impact) - ç”šè‡³ä¼šæœ‰ç‚¹ç ´éŸ³çš„æ„Ÿè§‰
    { name: "æè‡´éœ‡æ’¼", noise: {f:500, q:2, vol:6, dur:2.0}, kick: {f:45, vol:5.0, dur:0.6} },
];

// ============================
// 3. æ›¿æ¢ AudioEngine ç±» (æ‹ŸçœŸè’¸æ±½é¸£ç¬› + å“äº®è¡Œé©¶å£°)
// ============================
class AudioEngine {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.nextChug = 0;
        this.bgmTimer = null;
        this.isBgmPlaying = false;
        this.lastNoiseVal = 0;

        // ğŸšï¸ é»˜è®¤éŸ³é‡é…ç½®
        this.vol = {
            master: 0.7,    // æ€»éŸ³é‡ç¨å¤§
            bgm: 0.6,       // BGM é€‚ä¸­ï¼Œä¸è¦ç›–è¿‡éŸ³æ•ˆ
            train: 0.8,     // ç«è½¦å£°æ¸…æ™°
            firework: 1.0   // çƒŸèŠ±éœ‡æ’¼
        };
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            // æ··éŸ³é“¾è·¯
            this.nodes.master = this.ctx.createGain();
            this.nodes.bgm = this.ctx.createGain();
            this.nodes.train = this.ctx.createGain();
            this.nodes.fw = this.ctx.createGain();

            this.nodes.bgm.connect(this.nodes.master);
            this.nodes.train.connect(this.nodes.master);
            this.nodes.fw.connect(this.nodes.master);
            this.nodes.master.connect(this.ctx.destination);

            this.updateVols();

            // ç”Ÿæˆé€šç”¨å™ªéŸ³ Buffer (ç”¨äºæ¨¡æ‹Ÿæ°”æµã€çˆ†ç‚¸)
            const bSize = this.ctx.sampleRate * 2;
            this.noiseBuf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const out = this.noiseBuf.getChannelData(0);
            for (let i = 0; i < bSize; i++) {
                // æ··åˆç™½å™ªéŸ³å’Œç²‰çº¢å™ªéŸ³ï¼Œè´¨æ„Ÿæ›´å¥½
                const white = Math.random() * 2 - 1;
                out[i] = (this.lastNoiseVal + (0.02 * white)) / 1.02; // ç®€å•çš„ä½é€šæ»¤æ³¢æ¨¡æ‹Ÿç²‰çº¢å™ªéŸ³
                this.lastNoiseVal = out[i];
                out[i] *= 3.5; // è¡¥å¿éŸ³é‡
            }
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    
    updateVols() {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        this.nodes.master.gain.setTargetAtTime(this.vol.master, t, 0.1);
        this.nodes.bgm.gain.setTargetAtTime(this.vol.bgm, t, 0.1);
        this.nodes.train.gain.setTargetAtTime(this.vol.train, t, 0.1);
        this.nodes.fw.gain.setTargetAtTime(this.vol.firework, t, 0.1);
    }

    // ğŸµ BGM: ç»å¯¹æ ‡å‡†ç‰ˆã€ŠJingle Bellsã€‹ (ä¸»æ­Œ+å‰¯æ­Œå®Œæ•´å¾ªç¯)
    playBGM() {
        if(!this.ctx || this.isBgmPlaying) return;
        this.isBgmPlaying = true;
        
        // æ ‡å‡†éŸ³é«˜ (Cå¤§è°ƒ)
        const N = { 
            G3:196, A3:220, B3:247, 
            C4:262, D4:294, E4:330, F4:349, G4:392, A4:440, B4:494, 
            C5:523, D5:587, E5:659 
        };
        
        // åŸºç¡€æ‹é€Ÿ (BPM çº¦ 100)
        const Q = 360;  // å››åˆ†éŸ³ç¬¦ (1æ‹)
        const H = 720; // äºŒåˆ†éŸ³ç¬¦ (2æ‹)
        const W = 1080; // å…¨éŸ³ç¬¦ (4æ‹)
        
        const melody = [
            // === ä¸»æ­Œ Verse (Dashing through the snow) ===
            // 1. Dashing through the snow
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 2. In a one horse open sleigh
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 3. O'er the fields we go
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.B3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 4. Laughing all the way
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:H}, {n:0,d:Q}, {n:0,d:Q},
            
            // 5. Bells on bobtail ring
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.G3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 6. Making spirits bright
            {n:N.G3,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:Q}, {n:N.A3,d:H}, {n:0,d:Q}, {n:0,d:Q},
            // 7. What fun it is to ride and sing
            {n:N.A3,d:Q}, {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.G4,d:Q},
            // 8. A sleighing song tonight
            {n:N.A4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:H}, {n:N.G4,d:H}, // æœ€åG4æ˜¯è¿‡æ¸¡

            // === å‰¯æ­Œ Chorus (Jingle Bells) ===
            // 9. Jingle bells, jingle bells
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 10. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 11. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 12. In a one horse open sleigh
            {n:N.E4,d:Q}, {n:N.D4,d:Q}, {n:N.D4,d:Q}, {n:N.E4,d:Q}, {n:N.D4,d:H}, {n:N.G4,d:H},

            // 13. Jingle bells, jingle bells (Repeat)
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:H}, 
            // 14. Jingle all the way
            {n:N.E4,d:Q}, {n:N.G4,d:Q}, {n:N.C4,d:Q*1.5}, {n:N.D4,d:Q/2}, {n:N.E4,d:W},
            // 15. Oh what fun it is to ride
            {n:N.F4,d:Q}, {n:N.F4,d:Q}, {n:N.F4,d:Q*1.5}, {n:N.F4,d:Q/2},
            {n:N.F4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, {n:N.E4,d:Q}, 
            // 16. In a one horse open sleigh! (Ending)
            {n:N.G4,d:Q}, {n:N.G4,d:Q}, {n:N.F4,d:Q}, {n:N.D4,d:Q}, {n:N.C4,d:W}, {n:0,d:W}
        ];

        let idx = 0;
        const playNext = () => {
            if(!this.isBgmPlaying) return;
            const note = melody[idx];
            if(note.n > 0) {
                const t = this.ctx.currentTime, dur = note.d/1000;
                
                // ğŸ¹ éŸ³è‰²æ ¸å¿ƒï¼šé«˜é¢‘æ³›éŸ³å åŠ 
                const playLayer = (freq, type, vol, decay) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = type;
                    osc.frequency.value = freq;
                    const gain = this.ctx.createGain();
                    gain.connect(this.nodes.bgm);
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(vol, t + 0.01); // æå¿«èµ·éŸ³
                    gain.gain.exponentialRampToValueAtTime(0.001, t + decay);
                    osc.start(t); osc.stop(t + decay + 0.1);
                };

                // 1. åŸºéŸ³ (Sine) - æ¸©æš–çš„ä¸»ä½“
                playLayer(note.n, 'sine', 0.6, dur * 1.5);
                // 2. äºŒæ¬¡è°æ³¢ (Sine) - å¢åŠ åšåº¦
                playLayer(note.n * 2, 'sine', 0.3, dur * 1.2);
                // 3. æ•²å‡»å£° (Triangle) - ç¬é—´çš„é«˜é¢‘ï¼Œæ¨¡æ‹Ÿæ•²å‡»é‡‘å±ç‰‡
                playLayer(note.n * 4, 'triangle', 0.06, 0.1); 
                // 4. ç©ºçµæ„Ÿ (Detuned Sine)
                playLayer(note.n + 5, 'sine', 0.6, dur);
            }
            this.bgmTimer = setTimeout(playNext, note.d);
            idx = (idx + 1) % melody.length;
        };
        playNext();
    }
    
    stopBGM() { this.isBgmPlaying = false; clearTimeout(this.bgmTimer); }

    // ğŸ“¢ æ–¹æ¡ˆCï¼šå–·æ°”å“¨éŸ³
    // ğŸš‚ ä¿®å¤ç‰ˆï¼šåšé‡è’¸æ±½é¸£ç¬› (Steam Blast)
    whistle() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        // è®¾å®šé¸£ç¬›æ—¶é•¿ä¸º 2.5 ç§’ (ä¹‹å‰çš„ 12ç§’å¤ªé•¿äº†ï¼Œä¸çœŸå®)
        const duration = 2.5; 

        const masterGain = this.ctx.createGain();
        masterGain.connect(this.nodes.train);

        // 1. æ ¸å¿ƒéŸ³è°ƒï¼šä½¿ç”¨â€œé”¯é½¿æ³¢â€åŒéŸ³ (æ¨¡æ‹Ÿé“œç®¡å…±é¸£)
        // é¢‘ç‡é€‰æ‹©ï¼šF4 (349Hz) å’Œ G#4 (415Hz) æ„æˆå°ä¸‰åº¦ï¼Œç»å…¸æ±½ç¬›å£°
        [349, 415].forEach(freq => {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth'; // é”¯é½¿æ³¢æ¯”æ­£å¼¦æ³¢æ›´ç²—çŠ·
            
            // åŠ¨æ€é¢‘ç‡ï¼šæ¨¡æ‹Ÿæ°”å‹å†²å‡»ï¼Œèµ·éŸ³æ—¶éŸ³è°ƒå¾®å‡
            osc.frequency.setValueAtTime(freq, t);
            osc.frequency.linearRampToValueAtTime(freq + 5, t + 0.2); 
            osc.frequency.linearRampToValueAtTime(freq, t + duration);

            // ä½é€šæ»¤æ³¢ï¼šå»æ‰é”¯é½¿æ³¢è¿‡äºåˆºè€³çš„é«˜é¢‘ï¼Œè®©å£°éŸ³å˜â€œé—·â€å˜åš
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            osc.connect(filter);
            filter.connect(masterGain);
            
            osc.start(t);
            osc.stop(t + duration + 0.5); // ç•™å‡ºå°¾éŸ³æ—¶é—´
        });

        // 2. å–·æ°”å™ªéŸ³ï¼šæ¨¡æ‹Ÿè’¸æ±½å–·å‡ºçš„â€œå˜¶å˜¶â€å£°
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuf;
        
        // å™ªéŸ³æ»¤æ³¢ï¼šåªä¿ç•™ä¸­é¢‘ï¼Œæ¨¡æ‹Ÿåšé‡çš„è’¸æ±½æŸ±ï¼Œè€Œä¸æ˜¯å°–é”çš„æ¼æ°”
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.value = 600; 
        noiseFilter.Q.value = 1.0; // å®½å¸¦
        
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.value = 0.6; // å™ªéŸ³å æ¯”é€‚ä¸­

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(masterGain);
        
        noise.start(t);
        noise.stop(t + duration + 0.5);

        // 3. å…³é”®ä¿®å¤ï¼šADSR åŒ…ç»œ (ä¿æŒéŸ³é‡ï¼)
        masterGain.gain.setValueAtTime(0, t);
        
        // Attack: å¿«é€Ÿè¾¾åˆ°æœ€å¤§éŸ³é‡ (0.2ç§’)
        masterGain.gain.linearRampToValueAtTime(0.8, t + 0.2);
        
        // Sustain: ä¿æŒéŸ³é‡å¹³ç¨³ (ç›´åˆ° duration ç»“æŸ)
        masterGain.gain.setValueAtTime(0.8, t + duration);
        
        // Release: å¿«é€Ÿæ·¡å‡º (0.4ç§’) - æ¨¡æ‹Ÿé˜€é—¨å…³é—­
        masterGain.gain.exponentialRampToValueAtTime(0.001, t + duration + 0.4);
    }

    // ğŸš‚ æ–¹æ¡ˆCï¼šå–·æ°”å£°
    chug(speed) {
        if (!this.ctx || speed < 0.01) return;
        const t = this.ctx.currentTime;
        const interval = Math.max(0.1, 1.0 / (speed * 40)); 
        
        if (t >= this.nextChug) {
            this.nextChug = t + interval;
            const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuf;
            
            // ä½é€šæ»¤æ³¢ï¼Œæ¨¡æ‹Ÿé‡ç‰©æ’å‡»
            const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; 
            f.frequency.value = 150 + speed * 1500; 

            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.5 + speed, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); // é•¿ä¸€ç‚¹çš„å°¾éŸ³

            src.connect(f); f.connect(g); g.connect(this.nodes.train);
            src.start(t); src.stop(t + 0.2);
        }
    }
    // styleIndex: ä¼ å…¥ 0-11 é€‰æ‹©ç‰¹å®šé£æ ¼ï¼Œä¸ä¼ åˆ™éšæœº
    explode(styleIndex = -1) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // 1. é€‰æ‹©é£æ ¼
        if (styleIndex === -1) {
            // éšæœºé€‰æ‹©
            styleIndex = Math.floor(Math.random() * SOUND_STYLES.length);
        }
        // é˜²æ­¢è¶Šç•Œ
        const style = SOUND_STYLES[styleIndex % SOUND_STYLES.length];
        
        // éšæœºå£°åƒ (Pan): -0.8(å·¦) ~ 0.8(å³)
        const pan = (Math.random() - 0.5) * 1.6;
        
        // -------------------------------------------
        // å±‚çº§ A: çˆ†è£‚å™ªéŸ³ (Texture Layer)
        // -------------------------------------------
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuf;
        // ç¨å¾®éšæœºä¸€ç‚¹éŸ³è°ƒï¼Œé¿å…æ¯æ¬¡å®Œå…¨ä¸€æ ·
        src.playbackRate.value = 0.8 + Math.random() * 0.4; 

        // æ»¤æ³¢å™¨ (å†³å®šæ˜¯é—·å“è¿˜æ˜¯è„†å“)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = style.noise.q; // å…±æŒ¯å³°
        
        // é¢‘ç‡åŒ…ç»œ
        if (style.noise.slide) {
            // ç§‘å¹»æ•ˆæœï¼šé¢‘ç‡å¿«é€Ÿæ»‘åŠ¨
            filter.frequency.setValueAtTime(style.noise.f * 2, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + style.noise.dur);
        } else {
            // è‡ªç„¶æ•ˆæœï¼šé¢‘ç‡éšæ—¶é—´ç•¥å¾®è¡°å‡
            filter.frequency.setValueAtTime(style.noise.f, t);
            filter.frequency.exponentialRampToValueAtTime(style.noise.f * 0.5, t + style.noise.dur);
        }

        // å£°åƒå®šä½
        const panner = this.ctx.createStereoPanner();
        panner.pan.value = pan;

        // éŸ³é‡åŒ…ç»œ
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, t);
        env.gain.linearRampToValueAtTime(style.noise.vol, t + 0.02); // æå¿«èµ·éŸ³
        env.gain.exponentialRampToValueAtTime(0.01, t + style.noise.dur); // è¡°å‡

        // è¿æ¥ A
        src.connect(filter);
        filter.connect(panner);
        panner.connect(env);
        env.connect(this.nodes.fw);
        
        src.start(t);
        src.stop(t + style.noise.dur + 0.1);

        // -------------------------------------------
        // å±‚çº§ B: ä½é¢‘å†²å‡» (Kick Layer) - ç‰©ç†æ‰“å‡»æ„Ÿ
        // -------------------------------------------
        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // æ­£å¼¦æ³¢æœ€é€‚åˆåšä½éŸ³
        
        // é¢‘ç‡ä¸‹æ½œ (Kickçš„æ ¸å¿ƒ)
        osc.frequency.setValueAtTime(style.kick.f, t);
        osc.frequency.exponentialRampToValueAtTime(1, t + style.kick.dur);
        
        const oscGain = this.ctx.createGain();
        oscGain.gain.setValueAtTime(0, t);
        oscGain.gain.linearRampToValueAtTime(style.kick.vol, t + 0.02);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + style.kick.dur);
        
        // è¿æ¥ B
        osc.connect(oscGain);
        oscGain.connect(this.nodes.fw); // ä¹Ÿè¦è¿åˆ° fw èŠ‚ç‚¹å—æ€»éŸ³é‡æ§åˆ¶
        
        osc.start(t);
        osc.stop(t + style.kick.dur + 0.1);
    }
}

const audio = new AudioEngine();

// ============================
// âš™ï¸ å…¨å±€é…ç½® & çŠ¶æ€
// ============================
const CFG = {
    // ğŸš‚ ç‰©ç†
    maxSpeed: 0.10, accel: 0.005, decel: 0.003, wheelMult: 2.0, carriageGap: 0.009,
    
    // ğŸ¥ ç›¸æœº (å¤–ä¾§å‘å¿ƒè§†è§’)
    camHeight: 22,    // ç¨å¾®æŠ¬é«˜ï¼Œé˜²æ­¢ç«è½¦æŒ¡ä½å¤ªå¤šæ ‘çš„æ ¹éƒ¨
    camDist: 85,      // æ‹‰å¤§è·ç¦»ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨å¤–åœˆçœ‹ï¼Œéœ€è¦è§†é‡åŒ…ä½ä¸­å¤®
    camSmooth: 0.02,   // å¢å¤§é˜»å°¼ç³»æ•°ï¼Œè®©è·Ÿéšæ›´ç´§å‡‘ï¼Œå‡å°‘â€œæ‹–æ‹½æ„Ÿâ€å¸¦æ¥çš„æŠ–åŠ¨
    
    // ğŸ’¡ è§†è§‰ä¿®æ­£
    moonInt: 2.5, 
    fogDen: 0.0004, 
    bloomStr: 0.7,  
    bloomThr: 0.02, 
    lightPow: 100, bulbBri: 30,
    autoFw: true, fwRate: 4
};

const STATE = {
    started: false,
    viewMode: 'FOLLOW', // FOLLOW | FREE
    settings: false,
    interacting: false, // ç”¨æˆ·æ­£åœ¨æ‹–åŠ¨
    running: true, // ç›®æ ‡çŠ¶æ€ï¼šæ˜¯å¦åº”è¯¥è·‘
    curSpeed: 0,   // å½“å‰å®é™…ç‰©ç†é€Ÿåº¦
    clickTime: 0
};

let scene, camera, renderer, composer, controls, gui;
let train, fwMgr, snowMgr, trackCurve;
let lights={}, bloomPass;
let ground, trackPoints=[];
let autoTimer=null;
const clock = new THREE.Clock();
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const vec3 = new THREE.Vector3();
const emissives = []; // ç”¨äºç»Ÿä¸€è°ƒå…‰

// ============================
// ğŸš€ åˆå§‹åŒ–ä¸å¾ªç¯
// ============================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // çº¯é»‘èƒŒæ™¯
    scene.fog = new THREE.FogExp2(0x000000, CFG.fogDen);

    camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 4000);
    camera.position.set(0, 150, 150);

    // [å…¼å®¹æ€§] 1. å¼ºåˆ¶å…³é—­æŠ—é”¯é½¿ï¼Œé™ä½æ˜¾å­˜æ¶ˆè€—
    renderer = new THREE.WebGLRenderer({
        antialias: false, 
        powerPreference: "high-performance",
        depth: true,
        stencil: false // å…³é—­æ¨¡æ¿ç¼“å†²ï¼Œçœæ˜¾å­˜
    });
    renderer.setSize(innerWidth, innerHeight);
    
    // [æ€§èƒ½] 2. é”æ­»åƒç´ æ¯”ã€‚é«˜åˆ†å±æ‰‹æœºæ¸²æŸ“å‹åŠ›å¤ªå¤§ï¼Œé™åˆ¶åœ¨ 1.5 è¶³å¤Ÿæ¸…æ™°ä¸”æµç•…
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    buildLights();
    buildTrack();
    buildEnv();

    // [å…¼å®¹æ€§] 3. ä½¿ç”¨ UnsignedByteType æ›¿ä»£ HalfFloatType
    // å¾ˆå¤šè€å®‰å“æœºä¸æ”¯æŒæµ®ç‚¹çº¹ç†ï¼Œè¿™æ˜¯å¯¼è‡´é»‘å±çš„å…ƒå‡¶
    const rt = new THREE.WebGLRenderTarget(
        innerWidth, // ä¸è¦ä¹˜ renderer.getPixelRatio()ï¼ŒBloom ä¸éœ€è¦è§†ç½‘è†œçº§åˆ†è¾¨ç‡
        innerHeight,
        { type: THREE.HalfFloatType, stencilBuffer: false } // å¦‚æœè®¾å¤‡æ”¯æŒï¼ŒHalfFloat æ›´å¥½
    );

    const rp = new RenderPass(scene, camera);
    bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = CFG.bloomThr; 
    bloomPass.strength = CFG.bloomStr; 
    bloomPass.radius = 0.5;

    composer = new EffectComposer(renderer, rt);
    composer.addPass(rp);
    composer.addPass(bloomPass);

    train = new Train(scene, trackCurve);
    fwMgr = new Fireworks(scene);
    snowMgr = new Snow(scene);

    setupControls();
    setupUI();
    
    document.getElementById('loading').style.display='none';
    animate();
}


// åœ¨ animate å‡½æ•°å¤–ï¼Œç¡®ä¿å®šä¹‰äº†è¿™äº›è¾…åŠ©å˜é‡ï¼Œç”¨äºå¤ç”¨
const _v1 = new THREE.Vector3();
const _v2 = new THREE.Vector3();
const _target = new THREE.Vector3();
const _up = new THREE.Vector3(0, 1, 0);
const _tempCol = new THREE.Color(); // å…¨å±€å¤ç”¨å®ä¾‹
// ============================
// animate å‡½æ•° (æ”¯æŒ Instanced LED é—ªçƒ)
// ============================
function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const time = clock.getElapsedTime();

    // å¦‚æœä¸¤å¸§é—´éš”è¶…è¿‡ 0.1ç§’ï¼ˆæ¯”å¦‚åˆ‡åå°äº†ï¼‰ï¼Œå°±å¼ºåˆ¶æŒ‰ 0.1ç§’è®¡ç®—
    // è¿™æ ·é›ªèŠ±å°±ä¸ä¼šç¬é—´æ‰åˆ°åº•ï¼Œç«è½¦ä¹Ÿä¸ä¼šç¬ç§»
    const deltaTime = dt > 0.1 ? 0.1 : dt; 

    // 1. ç‰©ç†æƒ¯æ€§ (ä¿®å¤é€Ÿåº¦é™ä¸ä¸‹æ¥çš„é—®é¢˜)
    if(STATE.running) {
        // åŠ é€Ÿé€»è¾‘
        if(STATE.curSpeed < CFG.maxSpeed) {
            STATE.curSpeed += CFG.accel;
            if(STATE.curSpeed > CFG.maxSpeed) STATE.curSpeed = CFG.maxSpeed; // é’³åˆ¶
        } 
        // å‡é€Ÿé€»è¾‘ (å½“ä½ åœ¨è®¾ç½®é‡ŒæŠŠæé€Ÿè°ƒä½æ—¶ï¼Œç«è½¦ä¼šæ…¢æ…¢å‡é€Ÿé€‚åº”æ–°è®¾ç½®)
        else if(STATE.curSpeed > CFG.maxSpeed) {
            STATE.curSpeed -= CFG.decel;
        }
    } else {
        // åœè½¦é€»è¾‘
        if(STATE.curSpeed > 0) STATE.curSpeed -= CFG.decel;
        if(STATE.curSpeed < 0) STATE.curSpeed = 0;
    }

    if(train) train.update(deltaTime, STATE.curSpeed);
    if(fwMgr) fwMgr.update();
    if(snowMgr) snowMgr.update(deltaTime);

    // ç¯å…‰åŠ¨ç”»
    emissives.forEach(obj => {
        if(obj.userData.type === 'led_instanced') {
            const data = obj.userData.data;
            for(let i=0; i<obj.count; i++) {
                const item = data[i];
                const val = Math.sin(time * item.speed + item.offset);
                const intensity = 0.5 + 1.25 * (val + 1); 
                _tempCol.copy(item.baseCol).multiplyScalar(intensity);
                obj.setColorAt(i, _tempCol);
            }
            if(obj.instanceColor) obj.instanceColor.needsUpdate = true;
        }
        if(obj.userData.type === 'bulb' && obj.userData.baseCol) {
            const blink = 0.6 + 0.4 * Math.sin(time * 3.0 + obj.userData.phase);
            const intensity = 1.0 + blink * (CFG.bulbBri / 8); 
            obj.material.color.copy(obj.userData.baseCol).multiplyScalar(intensity);
        }
        if(obj.userData.type === 'star') obj.material.color.setHSL(0.14, 1.0, 0.6 + 0.3 * Math.sin(time));
        if(obj.userData.type === 'headlight_spot') obj.intensity = CFG.lightPow;
    });

    // ğŸ¥ ç›¸æœºé€»è¾‘ (é«˜æ€§èƒ½é›¶GCç‰ˆ)
    if(STATE.started && train && train.loco) {
        // 1. è·å–ç«è½¦ä½ç½®
        const t = train.prog;
        const trackPos = trackCurve.getPointAt(t); // è¿™é‡ŒThreejså†…éƒ¨ä¼šäº§ç”Ÿä¸€ä¸ªæ–°Vectorï¼Œæ— æ³•é¿å…ï¼Œä½†å¼€é”€å¯æ§
        
        // 2. è®¡ç®—å¾„å‘å‘é‡ (ä½¿ç”¨å…¨å±€å˜é‡ _v1ï¼Œé¿å… new)
        _v1.copy(trackPos).y = 0;
        _v1.normalize();
        
        // 3. è®¡ç®—ç›¸æœºç›®æ ‡ä½ç½® (å¤ç”¨ _v2)
        // é€»è¾‘ï¼šç«è½¦ä½ç½® + å‘å¤–åç§» * è·ç¦» + é«˜åº¦
        _v2.copy(trackPos)
           .addScaledVector(_v1, CFG.camDist)
           .addScaledVector(_up, CFG.camHeight);

        if (STATE.viewMode === 'FOLLOW') {
            // è®¡ç®—çœ‹å“ªé‡Œ (çœ‹è½¦é¡¶ä¸Šæ–¹ä¸€ç‚¹ç‚¹)
            _target.copy(trackPos).y += 5;
            controls.target.copy(_target);

            if (!STATE.interacting) {
                // å¹³æ»‘è·Ÿéš
                camera.position.lerp(_v2, CFG.camSmooth);
            }
        }
    }

    controls.update();
    composer.render();
}

// ============================
// ğŸŒ ä¸–ç•Œæ„å»º
// ============================
function buildLights() {
    const moon = new THREE.DirectionalLight(0xaaccff, CFG.moonInt);
    moon.position.set(-80, 150, -80);
    moon.castShadow=true; 
    moon.shadow.mapSize.set(1024,1024);
    moon.shadow.camera.left=-400; moon.shadow.camera.right=400;
    moon.shadow.camera.top=400; moon.shadow.camera.bottom=-400;
    scene.add(moon); lights.moon = moon;

    // æœˆäº®å®ä½“
    const mMesh = new THREE.Mesh(new THREE.SphereGeometry(15,32,32), new THREE.MeshBasicMaterial({color:0xffffee, fog:false}));
    mMesh.position.copy(moon.position).normalize().multiplyScalar(900);
    scene.add(mMesh);

    // æ˜Ÿç©º
    const sg = new THREE.BufferGeometry();
    const sp = [];
    for(let i=0;i<3000;i++) {
        const r=800+Math.random()*200;
        const th=Math.random()*Math.PI*2;
        const ph=Math.acos(2*Math.random()-1);
        if(Math.cos(ph)<0) continue; // åªåœ¨å¤©ä¸Š
        sp.push(r*Math.sin(ph)*Math.cos(th), Math.abs(r*Math.cos(ph)), r*Math.sin(ph)*Math.sin(th));
    }
    sg.setAttribute('position', new THREE.Float32BufferAttribute(sp,3));
    scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff, size:1.5, transparent:true, opacity:0.8, fog:false})));

    scene.add(new THREE.AmbientLight(0x303050, 0.4));
    
    // åœ°é¢
    ground = new THREE.Mesh(new THREE.CircleGeometry(1000,64), new THREE.MeshStandardMaterial({color:0x8899aa, roughness:1, metalness:0.1}));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow=true;
    scene.add(ground);
}

function buildTrack() {
    const points = [];
    const segments = 12; 
    
    const BaseR = 120; 
    const Amp = 50; 

    // å…³é”®ä¿®æ”¹ï¼šç”Ÿæˆéšæœºç§å­ï¼Œè®©ä¸‰ä¸ªå¶ç‰‡çš„å¤§å°æ¯æ¬¡éƒ½ä¸å¤ªä¸€æ ·
    // r1, r2, r3 åˆ†åˆ«å½±å“ä¸‰ä¸ªå¶ç‰‡çš„ "çªå‡ºç¨‹åº¦"
    const r1 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r2 = 1.0 + (Math.random() - 0.5) * 0.4; 
    const r3 = 1.0 + (Math.random() - 0.5) * 0.4;

    for (let i = 0; i < segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        
        // å…³é”®ä¿®æ”¹ï¼šæ ¹æ®è§’åº¦é€‰æ‹©ä¸åŒçš„éšæœºç³»æ•°
        let randomScale = 1.0;
        // ç®€å•åˆ¤æ–­è§’åº¦è½åœ¨å“ªä¸ªå¶ç‰‡åŒºé—´ (0~2PI åˆ†ä¸‰æ®µ)
        if (theta < 2) randomScale = r1;
        else if (theta < 4) randomScale = r2;
        else randomScale = r3;

        // å…¬å¼ï¼šåŸºç¡€åŠå¾„ + (æŒ¯å¹… * éšæœºç³»æ•° * ä¸‰å¶è‰å½¢çŠ¶) + å¾®å°æŠ–åŠ¨
        const r = BaseR + (Amp * randomScale * Math.sin(3 * theta));
        
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        points.push(new THREE.Vector3(x, 0, z));
    }

    trackCurve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.4); 
    trackPoints = trackCurve.getPoints(1000);

    const divs = 600;
    const bed = new THREE.Mesh(new THREE.TubeGeometry(trackCurve, divs, 4.2, 8, true), new THREE.MeshStandardMaterial({color:0x080808, roughness:1}));
    bed.position.y = 0.1; bed.scale.y = 0.1; scene.add(bed);
    
    const pg = new THREE.BoxGeometry(6, 0.4, 1.2); 
    const pm = new THREE.MeshStandardMaterial({color:0x3e2723});
    const pi = new THREE.InstancedMesh(pg, pm, divs);
    const dum = new THREE.Object3D();
    for(let i=0; i<divs; i++){
        const t = i/divs; const p = trackCurve.getPointAt(t); const tan = trackCurve.getTangentAt(t);
        dum.position.set(p.x, 0.3, p.z); dum.lookAt(p.x + tan.x, 0.3, p.z + tan.z); dum.updateMatrix();
        pi.setMatrixAt(i, dum.matrix);
    }
    pi.receiveShadow = true; scene.add(pi);

    // --- ä¿®å¤ï¼šåŒè½¨ç”Ÿæˆé€»è¾‘ ---
    // é—®é¢˜æ ¹æºï¼šExtrudeGeometry ä¼šè‡ªåŠ¨æ—‹è½¬åæ ‡ç³»ï¼Œå¯¼è‡´é“è½¨å˜æˆäº†ä¸Šä¸‹æ’åˆ—è€Œä¸æ˜¯å·¦å³æ’åˆ—
    // è§£å†³æ–¹æ¡ˆï¼šæ‰‹åŠ¨è®¡ç®—ä¸¤æ¡å¹³è¡Œäºåœ°é¢çš„è·¯å¾„
    
    const railPointsL = [];
    const railPointsR = [];
    const railSamp = 400; // é‡‡æ ·ç‚¹æ•°ï¼Œè¶Šå¤šè¶Šå¹³æ»‘
    const dist = 2.2; // è½¨è·

    // é¢„åˆ†é…å¤ç”¨å¯¹è±¡ï¼Œå‡å°‘ GC å‹åŠ›
    const upVec = new THREE.Vector3(0, 1, 0);
    const rightVec = new THREE.Vector3();
    const tempL = new THREE.Vector3();
    const tempR = new THREE.Vector3();

    for(let i=0; i<=railSamp; i++) {
        const t = i / railSamp;
        const pt = trackCurve.getPointAt(t);
        const tan = trackCurve.getTangentAt(t); // è·å–åˆ‡çº¿(å‰è¿›æ–¹å‘)
        // å¤ç”¨ rightVec è®¡ç®—å³ä¾§å‘é‡
        rightVec.crossVectors(tan, upVec).normalize();

        // ç”Ÿæˆå·¦å³åæ ‡ç‚¹
        tempL.copy(pt).addScaledVector(rightVec, -dist);
        tempR.copy(pt).addScaledVector(rightVec, dist);
        railPointsL.push(tempL.clone());
        railPointsR.push(tempR.clone());
    }

    // 4. åˆ›å»ºä¸¤æ¡å¹³è¡Œçš„æ›²çº¿å¯¹è±¡
    const curveL = new THREE.CatmullRomCurve3(railPointsL, true, 'catmullrom', 0.4);
    const curveR = new THREE.CatmullRomCurve3(railPointsR, true, 'catmullrom', 0.4);
    
    const railMat = new THREE.MeshStandardMaterial({
        color: 0x555555, 
        metalness: 0.8, 
        roughness: 0.4
    });

    // 5. ä½¿ç”¨æœ€ç¨³å¦¥çš„ TubeGeometry ç”Ÿæˆå®ä½“
    // 0.12 æ˜¯é“è½¨ç²—ç»†ï¼Œ8 æ˜¯æˆªé¢åœ†æ»‘åº¦
    const railMeshL = new THREE.Mesh(new THREE.TubeGeometry(curveL, railSamp, 0.12, 8, true), railMat);
    const railMeshR = new THREE.Mesh(new THREE.TubeGeometry(curveR, railSamp, 0.12, 8, true), railMat);
    
    // 6. è°ƒæ•´é«˜åº¦
    // æ•æœ¨é¡¶é¢çº¦ 0.5ï¼Œé“è½¨è®¾ä¸º 0.56ï¼Œåˆšå¥½å‹åœ¨æ•æœ¨ä¸Š
    railMeshL.position.y = 0.56;
    railMeshR.position.y = 0.56;

    scene.add(railMeshL);
    scene.add(railMeshR);
}

function buildEnv() {
    // 1. ä¸‹æ–¹æ”¾ç½®å¤§å·è‹±é›„æ ‘ (é…åˆå¤§åœ†å¼§)
    createHeroTree(0, -90, 2.8); 
    
    // 2. å·¦ä¸Šå’Œå³ä¸Šæ”¾ç½®å°å·è‹±é›„æ ‘
    createHeroTree(85, 55, 1.4); 
    createHeroTree(-85, 55, 1.4);

    // ğŸŒ² å‡çº§ç‰ˆæ£®æ—
    const matTree = new THREE.MeshStandardMaterial({color:0x0f3315, roughness:0.9});
    const matSnow = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.6}); 
    
    const count = 700; 
    
    const meshBot = new THREE.InstancedMesh(new THREE.ConeGeometry(3.5, 5, 7), matTree, count);
    const meshMid = new THREE.InstancedMesh(new THREE.ConeGeometry(2.5, 4, 7), matTree, count);
    const meshTop = new THREE.InstancedMesh(new THREE.ConeGeometry(1.5, 3, 7), matSnow, count); 
    
    meshBot.castShadow=true; meshBot.receiveShadow=true;
    meshMid.castShadow=true; meshMid.receiveShadow=true;
    
    const dummy = new THREE.Object3D();
    let idx = 0;
    
    for(let i=0; i<3000; i++) {
        if(idx >= count) break;
        const r = 60 + Math.random()*380;
        const a = Math.random()*6.28;
        const x = Math.cos(a)*r, z = Math.sin(a)*r;
        let safe=true;
        const distSq = 25*25; 
        for(let k=0; k<trackPoints.length; k+=10) { 
            const dx = trackPoints[k].x - x, dz = trackPoints[k].z - z;
            if((dx*dx + dz*dz) < distSq) { safe=false; break; }
        }

        if(safe) {
            const s = 0.6 + Math.random() * 1.6; 
            const rotY = Math.random() * Math.PI;
            dummy.position.set(x, 2.5*s, z); dummy.scale.set(s,s,s); dummy.rotation.y = rotY; dummy.updateMatrix();
            meshBot.setMatrixAt(idx, dummy.matrix);
            dummy.position.set(x, 5.5*s, z); dummy.scale.set(s,s,s); dummy.updateMatrix();
            meshMid.setMatrixAt(idx, dummy.matrix);
            dummy.position.set(x, 8.0*s, z); dummy.scale.set(s,s,s); dummy.updateMatrix();
            meshTop.setMatrixAt(idx, dummy.matrix);
            idx++;
        }
    }
    
    scene.add(meshBot); scene.add(meshMid); scene.add(meshTop);

    //è£…é¥°å“
    for(let i=0; i<30; i++){
        const x=(Math.random()-0.5)*350, z=(Math.random()-0.5)*350;
        let safe=true; 
        for(let k=0;k<trackPoints.length;k+=10) {
            const dx=trackPoints[k].x-x, dz=trackPoints[k].z-z;
            if((dx*dx+dz*dz)<400) { safe=false; break; }
        }
        if(safe) {
            const r=Math.random();
            if(r<0.3) createGift(x,z);
            else if(r<0.6) createSnowman(x,z);
            else createLamp(x,z);
        }
    }
}

// ============================
// createHeroTree (éšæœºå¸ƒçº¿ + ç¯å¢ƒå…‰ç…§ + å®Œç¾æ˜Ÿæ˜Ÿ)
// ============================
function createHeroTree(x, z, scale) {
    const g = new THREE.Group(); 
    g.position.set(x, 0, z); 
    g.scale.set(scale, scale, scale);

    // 1. æ ‘å¹²
    const matTrunk = new THREE.MeshStandardMaterial({ color: 0x4a2e16, roughness: 1.0 });
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(3, 5, 15, 8), matTrunk);
    trunk.position.y = 6; 
    g.add(trunk);

    // 2. æ ‘å¶
    const matFoliage = new THREE.MeshStandardMaterial({ color: 0x0f5515, roughness: 0.8, flatShading: true });

    // è£…é¥°æè´¨
    const matRed = new THREE.MeshStandardMaterial({ color: 0xe60000, roughness: 0.3 });
    const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.6 });
    const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
    const bulbCols = [0xff0000, 0x00ff00, 0x0088ff, 0xffd700, 0xff00ff];

// ğŸ¬ ä¿®å¤ç‰ˆï¼šæ‹æ–ç³–
    const createCandyCane = () => {
        const cane = new THREE.Group();
        
        // æè´¨å¤ç”¨ä¸Šä¸‹æ–‡ä¸­çš„ matWhite å’Œ matRed
        
        // 1. æ‹æ–ä¸»ä½“ (ç»Ÿä¸€ç”¨ç™½è‰²)
        // æ£èº«
        const stickH = 1.2;
        const radius = 0.12;
        const stick = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, stickH, 8), matWhite);
        stick.position.y = stickH / 2;
        
        // å¼¯é’© (åŠåœ†ç¯)
        const hookRadius = 0.35;
        const hook = new THREE.Mesh(
            new THREE.TorusGeometry(hookRadius, radius, 8, 16, Math.PI), 
            matWhite
        );
        // è°ƒæ•´å¼¯é’©ä½ç½®ï¼Œä½¿å…¶å®Œç¾è¿æ¥æ£èº«é¡¶éƒ¨
        hook.position.set(hookRadius, stickH, 0); 
        hook.rotation.set(0, 0, 0); // é»˜è®¤Torusæ˜¯åœ¨XYå¹³é¢ï¼ŒMath.PIç”»å‡ºä¸ŠåŠåœ†
        // æˆ‘ä»¬éœ€è¦æŠŠåŠåœ†è½¬ä¸€ä¸‹ï¼Œè®©å®ƒåƒä¸ªé’©å­
        // é»˜è®¤æ˜¯ä»3ç‚¹é’Ÿç”»åˆ°9ç‚¹é’Ÿï¼Œæˆ‘ä»¬éœ€è¦è°ƒæ•´å®ƒçš„æœå‘
        
        // 2. æ¨¡æ‹Ÿçº¢è‰²æ¡çº¹ (ç”¨å€¾æ–œçš„åœ†ç¯æ¨¡æ‹Ÿèºæ—‹)
        const stripeGeo = new THREE.TorusGeometry(radius + 0.01, 0.02, 4, 8); // ç¨å¾®ç²—ä¸€ç‚¹ç‚¹è¦†ç›–è¡¨é¢
        
        // æ£èº«ä¸Šçš„æ¡çº¹
        for(let i=0; i<5; i++) {
            const stripe = new THREE.Mesh(stripeGeo, matRed);
            stripe.position.y = 0.2 + i * 0.22;
            stripe.rotation.x = Math.PI / 2; // å…ˆæ”¾å¹³
            stripe.rotation.y = 0.3; // å†å€¾æ–œä¸€ç‚¹ï¼Œæ¨¡æ‹Ÿèºæ—‹æ„Ÿ
            cane.add(stripe);
        }
        
        // å¼¯é’©ä¸Šçš„æ¡çº¹ (æ‰‹åŠ¨æ”¾ç½®å‡ ä¸ª)
        const hookStripes = new THREE.Group();
        hookStripes.position.copy(hook.position); // è·Ÿéšå¼¯é’©åæ ‡ç³»
        
        for(let i=1; i<4; i++) {
            const angle = (i / 4) * Math.PI; // åœ¨åŠåœ†ä¸Šçš„è§’åº¦
            const stripe = new THREE.Mesh(stripeGeo, matRed);
            // è®¡ç®—åœ†ç¯åœ¨å¼¯é’©è·¯å¾„ä¸Šçš„ä½ç½®
            stripe.position.set(
                Math.cos(angle) * hookRadius,
                Math.sin(angle) * hookRadius, 
                0
            );
            // è®©åœ†ç¯å‚ç›´äºè·¯å¾„åˆ‡çº¿
            stripe.rotation.z = angle + Math.PI/2;
            hookStripes.add(stripe);
        }

        cane.add(stick, hook, hookStripes);
        
        // æ•´ä½“è°ƒæ•´å§¿æ€
        cane.scale.set(1.2, 1.2, 1.2);
        // è®©æ‹æ–æŒ‚åœ¨æ ‘ä¸Šæ—¶ç¨å¾®è‡ªç„¶ä¸€ç‚¹
        cane.rotation.z = Math.PI / 6; 
        
        return cane;
    };
    // ğŸ ä¿®å¤ç‰ˆï¼šå¸¦è´è¶ç»“çš„æ ‘ä¸Šå°ç¤¼ç‰©
    const createMiniGift = () => {
        const boxG = new THREE.Group();
        // éšæœºé¢œè‰²ï¼šçº¢æˆ–é‡‘
        const isRed = Math.random() > 0.5;
        const mainMat = isRed ? matRed : matGold;
        const ribbonMat = matWhite;

        // 1. ç›’å­ä¸»ä½“
        const box = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), mainMat);
        
        // 2. åå­—ä¸å¸¦ (ç¨å¾®åŠ åšä¸€ç‚¹é˜²æ­¢é—ªçƒ)
        const r1 = new THREE.Mesh(new THREE.BoxGeometry(1.05, 1.0, 0.25), ribbonMat);
        const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.0, 1.05), ribbonMat);
        
        // 3. é¡¶éƒ¨è´è¶ç»“ (ç”±ä¸¤ä¸ªæ—‹è½¬çš„ç¯ + ä¸­é—´ä¸€ä¸ªç»“ç»„æˆ)
        const bowG = new THREE.Group();
        bowG.position.y = 0.5; // æ”¾åœ¨ç›’å­é¡¶ä¸Š

        // è´è¶ç»“çš„è€³æœµ (Toruså‹æ‰)
        const bowGeo = new THREE.TorusGeometry(0.2, 0.08, 6, 12); 
        const b1 = new THREE.Mesh(bowGeo, ribbonMat);
        b1.position.set(0.15, 0.15, 0);
        b1.rotation.set(0, 0, -Math.PI / 4); // å€¾æ–œ
        
        const b2 = new THREE.Mesh(bowGeo, ribbonMat);
        b2.position.set(-0.15, 0.15, 0);
        b2.rotation.set(0, 0, Math.PI / 4); // å¦ä¸€è¾¹å€¾æ–œ

        // ä¸­é—´çš„ç»“
        const knot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), ribbonMat);
        
        bowG.add(b1, b2, knot);
        boxG.add(box, r1, r2, bowG);
        
        // æ•´ä½“éšæœºæ—‹è½¬ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
        boxG.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
        
        return boxG;
    };

    const tiers = [
        { r: 24, h: 16, y: 14 }, { r: 20, h: 15, y: 24 },
        { r: 16, h: 14, y: 34 }, { r: 11, h: 12, y: 43 },
        { r: 6,  h: 10, y: 51 }
    ];
    let treeTopY = 0;

    tiers.forEach((tier, index) => {
        const geo = new THREE.ConeGeometry(tier.r, tier.h, 8);
        const mesh = new THREE.Mesh(geo, matFoliage);
        mesh.position.y = tier.y;
        mesh.rotation.y = (index % 2) * (Math.PI / 8); 
        mesh.castShadow = true; mesh.receiveShadow = true;
        g.add(mesh);
        treeTopY = tier.y + tier.h / 2;

        // --- è£…é¥°å“ï¼šå†…æ”¶åœ¨è¡¨é¢ ---
        const decorCount = Math.floor(tier.r * 0.8) + 2; 
        for (let k = 0; k < decorCount; k++) {
            const angle = Math.random() * Math.PI * 2;
            const v = 0.1 + Math.random() * 0.5; 
            const surfR = tier.r * (1 - v);
            const embed = 0.85 + Math.random() * 0.15; // ç¨å¾®å†…åµŒ
            
            const lx = Math.cos(angle) * surfR * embed;
            const lz = Math.sin(angle) * surfR * embed;
            const ly = -tier.h / 2 + v * tier.h;

            const type = Math.random();
            let decor;
            if (type < 0.4) {
                decor = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), Math.random()>.5?matRed:matGold);
                decor.position.set(lx, ly, lz);
            } else if (type < 0.7) {
                decor = createMiniGift();
                decor.position.set(lx, ly + 0.5, lz); 
                decor.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
            } else {
                decor = createCandyCane();
                decor.position.set(lx, ly, lz);
                decor.lookAt(0, ly, 0); 
                decor.rotateX(Math.PI/4);
            }
            mesh.add(decor);
        }
    });

    // --- ğŸŒŸ 3. å®ä½“ç”µçº¿ (éšæœºå¸ƒçº¿é€»è¾‘) ---
    const wirePoints = [];
    wirePoints.push(new THREE.Vector3(0, 2, 2)); // èµ·ç‚¹
    let currentAngle = 0;

    tiers.forEach((tier) => {
        // ç›˜æ—‹ï¼š0.5 ~ 1.5 åœˆ
        const loops = 0.5 + Math.random() * 1.0; 
        const steps = 15; // ç»†åˆ†
        
        for(let s=0; s <= steps; s++) {
            const t = s / steps;
            
            // è§’åº¦æ¨è¿›
            const angleStep = (Math.PI * 2 * loops) / steps;
            currentAngle += angleStep;
            
            // é«˜åº¦ï¼šåœ¨å½“å‰å±‚çˆ¬å‡
            // åªçˆ¬åˆ° 70% é«˜åº¦ï¼Œç•™å‡ºé’»å›å»çš„ç©ºé—´
            const py = (tier.y - tier.h/2) + (tier.h * 0.7) * t;
            
            // åŠå¾„ï¼šä»è¡¨é¢ç¨å¾®æµ®èµ·
            const surfR = tier.r * (1 - t * 0.7); // éšé«˜åº¦å˜ç»†
            const r = surfR * 1.05 + Math.random(); // éšæœºæ¾å¼›
            
            const px = Math.cos(currentAngle) * r;
            const pz = Math.sin(currentAngle) * r;
            wirePoints.push(new THREE.Vector3(px, py, pz));
        }

        // C. é’»å›ï¼šå›åˆ°æ ‘å¹²é™„è¿‘ï¼Œå‡†å¤‡å»ä¸‹ä¸€å±‚
        const endH = tier.y + tier.h/2 - 1;
        wirePoints.push(new THREE.Vector3(2 * Math.cos(currentAngle), endH, 2 * Math.sin(currentAngle)));
    });
    // ç»ˆç‚¹
    wirePoints.push(new THREE.Vector3(0, treeTopY, 0));

    const curve = new THREE.CatmullRomCurve3(wirePoints);
    const tubeGeo = new THREE.TubeGeometry(curve, 300, 0.08, 6, false);
    const wireMesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 }));
    g.add(wireMesh);

    // --- ğŸŒŸ 4. LED ç¯ç  (ç¨€ç–åˆ†å¸ƒ + å±€éƒ¨ç‚¹å…‰æº) ---
    const totalLength = curve.getLength();
    // [ä¼˜åŒ–] é™ä½é‡‡æ ·ç‡ï¼Œè®©ç¯ç æ›´ç¨€ç–
    const bulbCountRaw = Math.floor(totalLength * 1.8); 
    
    const bulbGeo = new THREE.SphereGeometry(0.45, 8, 8);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false });
    const ledMesh = new THREE.InstancedMesh(bulbGeo, bulbMat, bulbCountRaw);
    
    const dummy = new THREE.Object3D();
    const ledData = [];
    let realCount = 0;
    let clusterState = false; 
    let clusterCounter = 0;

    for(let i=0; i<bulbCountRaw; i++) {
        const t = i / bulbCountRaw;
        
        // [ä¼˜åŒ–] èšç±»é€»è¾‘ï¼šæœ‰ç¯çš„æ®µçŸ­ï¼Œæ²¡ç¯çš„æ®µé•¿
        if (clusterCounter <= 0) {
            clusterState = !clusterState;
            // æœ‰ç¯ï¼š4~8ä¸ªï¼Œæ— ç¯ï¼š8~20ä¸ª (æ›´ç¨€ç–)
            clusterCounter = clusterState ? Math.floor(Math.random() * 5 + 4) : Math.floor(Math.random() * 12 + 8);
        }
        clusterCounter--;
        if (!clusterState) continue;

        const pos = curve.getPointAt(t);
        // éšæœºåç§»
        pos.x += (Math.random()-0.5)*0.3;
        pos.y += (Math.random()-0.5)*0.3;
        pos.z += (Math.random()-0.5)*0.3;

        dummy.position.copy(pos);
        dummy.scale.setScalar(1.0);
        dummy.updateMatrix();
        ledMesh.setMatrixAt(realCount, dummy.matrix);
        
        const colHex = bulbCols[Math.floor(Math.random() * bulbCols.length)];
        const color = new THREE.Color(colHex);
        ledMesh.setColorAt(realCount, color);
        
        ledData.push({ id: realCount, baseCol: color, speed: 0.5 + Math.random() * 3.0, offset: Math.random() * 100 });
        realCount++;
    }
    
    ledMesh.count = realCount;
    ledMesh.instanceColor.needsUpdate = true;
    ledMesh.userData = { type: 'led_instanced', data: ledData };
    emissives.push(ledMesh);
    g.add(ledMesh);

    // [æ–°å¢] å†…éƒ¨ç¯å¢ƒå…‰ (æ¨¡æ‹Ÿç¯å¸¦ç…§äº®æ ‘å¶)
    // âœ… æ–¹æ¡ˆï¼šåªç»™æœ€å¤§çš„æ ‘æ”¾å…‰æºæ”¾ 1 ä¸ªä¸­å¿ƒå…‰æº
    // è¿™é‡Œçš„ scale å‚æ•°å¯ä»¥ç”¨æ¥åˆ¤æ–­æ˜¯å¦æ˜¯ä¸»æ ‘ (ä¸»æ ‘ scale ä¸º 2.8)
    if (scale > 2.0) { 
        const innerLight = new THREE.PointLight(0xffaa33, 100, 50); 
        innerLight.position.set(0, 15, 0); // æ”¾åœ¨æ ‘ä¸­å¿ƒå³å¯
        g.add(innerLight);
    }

    // --- ğŸŒŸ 5. æ ‘é¡¶æ˜Ÿæ˜Ÿ (ä¿®å¤ç‰ˆï¼šæ— ç¼ºå£) ---
    const starShape = new THREE.Shape();
    const pts = 5;
    const outerR = 4.2; 
    const innerR = 2.0; 
    // ä»æ­£ä¸Šæ–¹å¼€å§‹ç”» (Angle = -PI/2)
    for (let i = 0; i < pts * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const a = (i / 10) * Math.PI * 2 - Math.PI/2;
        if(i===0) starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r);
        else starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    starShape.closePath();

    // å‡å° bevel é˜²æ­¢è‡ªç›¸äº¤ç¼ºå£
    const starGeo = new THREE.ExtrudeGeometry(starShape, { 
        depth: 1.0, 
        bevelEnabled: true, 
        bevelThickness: 0.1, 
        bevelSize: 0.1, 
        bevelSegments: 1 
    });
    starGeo.center();
    
    const star = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffeb3b, fog: false }));
    star.position.set(0, treeTopY + 3.5, 0);
    star.userData = { type: 'star' }; 
    emissives.push(star); 
    g.add(star);
    
    scene.add(g);
}

// ğŸ ä¿®å¤ç‰ˆï¼šåœ°é¢çš„å¤§ç¤¼ç‰© (å¸¦è´è¶ç»“)
function createGift(x, z) {
    const g = new THREE.Group();
    g.position.set(x, 0.75, z); // æå‡é«˜åº¦ï¼Œå› ä¸ºBoxä¸­å¿ƒåœ¨åŸç‚¹

    // éšæœºé¢œè‰²æè´¨
    const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
    const matBox = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
    const matRibbon = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });

    // 1. ç›’å­
    const box = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), matBox);
    box.castShadow = true;

    // 2. ä¸å¸¦
    const r1 = new THREE.Mesh(new THREE.BoxGeometry(1.55, 1.5, 0.35), matRibbon);
    const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 1.55), matRibbon);

    // 3. è´è¶ç»“
    const bowG = new THREE.Group();
    bowG.position.y = 0.75;
    
    // å·¦å³ä¸¤ä¸ªç¯
    const bowGeo = new THREE.TorusGeometry(0.35, 0.12, 8, 16);
    const b1 = new THREE.Mesh(bowGeo, matRibbon);
    b1.position.set(0.25, 0.25, 0);
    b1.rotation.set(0, 0, -Math.PI / 3);
    
    const b2 = new THREE.Mesh(bowGeo, matRibbon);
    b2.position.set(-0.25, 0.25, 0);
    b2.rotation.set(0, 0, Math.PI / 3);

    const knot = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.25), matRibbon);
    
    bowG.add(b1, b2, knot);
    g.add(box, r1, r2, bowG);

    // éšæœºæœå‘
    g.rotation.y = Math.random() * Math.PI;
    scene.add(g);
}

function createSnowman(x,z) {
    const g=new THREE.Group(); g.position.set(x,0,z);
    const m=new THREE.MeshStandardMaterial({color:0xffffff});
    const b1=new THREE.Mesh(new THREE.SphereGeometry(1.2), m); b1.position.y=1;
    const b2=new THREE.Mesh(new THREE.SphereGeometry(0.8), m); b2.position.y=2.5;
    g.add(b1,b2); scene.add(g);
}
function createLamp(x,z) {
    const g=new THREE.Group(); g.position.set(x,0,z);
    const p=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,7), new THREE.MeshStandardMaterial({color:0x111})); p.position.y=3.5;
    
    // [ä¿®å¤] ä½¿ç”¨ BasicMaterial + fog:falseï¼Œå¹¶å®šä¹‰ baseCol
    const col = 0xffaa00;
    const b=new THREE.Mesh(
        new THREE.SphereGeometry(0.5), 
        new THREE.MeshBasicMaterial({color:col, fog:false}) // å…³é”®ï¼šfog:false
    );
    b.position.y=7; 
    
    // [å…³é”®] å¿…é¡»å®šä¹‰ baseColï¼Œå¦åˆ™ animate ä¼šå´©æºƒ
    b.userData={type:'bulb', phase: Math.random()*Math.PI, baseCol: new THREE.Color(col)}; 
    
    emissives.push(b); g.add(p,b); scene.add(g);
}

// ============================
// ğŸš‚ ç«è½¦ç³»ç»Ÿ
// ============================
class Train {
    constructor(sc, curve) {
        this.grp=new THREE.Group(); sc.add(this.grp);
        this.curve=curve; this.prog=0; this.wheels=[]; this.smokes=[];
        
        // [æ€§èƒ½ä¼˜åŒ–] é¢„å…ˆåˆ›å»ºçƒŸé›¾çš„å‡ ä½•ä½“å’Œæè´¨ï¼Œä¸è¦åœ¨å¾ªç¯é‡Œåˆ›å»º
        this.smokeMax = 50; // æœ€å¤§çƒŸé›¾æ•°é‡
        this.smokeIdx = 0;
        this.smokeData = []; // å­˜å‚¨ç”Ÿå‘½å‘¨æœŸæ•°æ®
        // ä½¿ç”¨ InstancedMesh
        const sGeo = new THREE.IcosahedronGeometry(1, 0);
        const sMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd, transparent: true, opacity: 0.6, // åŸºç¡€é€æ˜åº¦
            depthWrite: false, roughness: 1, flatShading: true
        });
        this.smokeMesh = new THREE.InstancedMesh(sGeo, sMat, this.smokeMax);
        this.smokeMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.grp.add(this.smokeMesh);

        // é¢„å…ˆåˆ›å»ºè¾…åŠ©å¯¹è±¡ï¼Œé¿å…åå¤åˆ›å»º
        this.dummy = new THREE.Object3D();
        this._trainDir = new THREE.Vector3(); // å¤ç”¨çš„æ–¹å‘å‘é‡ 

        for(let i=0; i<this.smokeMax; i++) {
            // åˆå§‹ç§»åˆ°æ— é™è¿œ
            this.dummy.position.set(0, -1000, 0); 
            this.dummy.updateMatrix();
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            this.smokeData.push({ active: false, life: 0, vel: new THREE.Vector3(), scale: 1 });
        }

        // Glare
        const cv=document.createElement('canvas'); cv.width=64;cv.height=64;
        const cx=cv.getContext('2d'); const gr=cx.createRadialGradient(32,32,0,32,32,32);
        gr.addColorStop(0,'#fff'); gr.addColorStop(1,'transparent'); cx.fillStyle=gr; cx.fillRect(0,0,64,64);
        this.glare=new THREE.CanvasTexture(cv);

        this.loco=this.mkLoco(); this.grp.add(this.loco);
        this.cars=[]; for(let i=1;i<=12;i++) { const c=this.mkCar(i); this.grp.add(c); this.cars.push(c); }
        this.gap();
    }
    gap() { this.cars.forEach((c,i)=>c.userData.off=(i+1)*(0.0075+CFG.carriageGap*0.2)); }
    
    mkLoco() {
        const g=new THREE.Group();
        const red=new THREE.MeshStandardMaterial({color:0xb71c1c, roughness:0.3});
        const blk=new THREE.MeshStandardMaterial({color:0x111});
        const boil=new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,5,16), red); boil.rotation.x=Math.PI/2; boil.position.set(0,3.6,1);
        const cab=new THREE.Mesh(new THREE.BoxGeometry(3.8,5.2,3.2), red); cab.position.set(0,4.1,-2.5);
        this.chim=new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.6,2.5), blk); this.chim.position.set(0,4.8,2.5);
        const cow=new THREE.Mesh(new THREE.ConeGeometry(2,1.5,4), blk); cow.rotation.set(-Math.PI/2,Math.PI/4,0); cow.scale.set(1,0.5,1); cow.position.set(0,1,4.5);
        
        const aw=(z,r)=>{
            const w=new THREE.Mesh(new THREE.CylinderGeometry(r,r,0.5,16).rotateZ(Math.PI/2), blk);
            w.position.set(1.9,r,z); const w2=w.clone(); w2.position.set(-1.9,r,z);
            g.add(w,w2); this.wheels.push(w,w2);
        };
        aw(0,1.3); aw(2.2,1.3); aw(-1.5,1.3); aw(4.0,0.8);
        
        const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:this.glare, color:0xffdd88, blending:THREE.AdditiveBlending}));
        sp.position.set(0,5.2,4); sp.scale.set(10,10,1);
        const sl=new THREE.SpotLight(0xffccaa, CFG.lightPow, 150, 0.8, 0.5);
        sl.position.set(0,5.2,3.8); sl.target.position.set(0,-5,30); sl.castShadow=true;
        sl.userData={type:'headlight_spot'};
        emissives.push(sl); // åŠ å…¥ emissives ä»¥æ”¯æŒåŠ¨æ€äº®åº¦è°ƒèŠ‚
        g.add(boil,cab,this.chim,cow,sp,sl,sl.target);
        return g;
    }

    mkCar(i) {
        const g = new THREE.Group();
        // ç»å…¸çš„åœ£è¯ç‰¹å¿«é…è‰²ï¼šæ·±çº¢ã€å¢¨ç»¿ã€æµ·å†›è“
        const cols = [0x8b0000, 0x004d26, 0x003366, 0xb8860b];
        const col = cols[(i - 1) % 4];
        
        const matBody = new THREE.MeshStandardMaterial({ color: col, roughness: 0.4, metalness: 0.2 });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });

        // 1. è½¦èº«ä¸»ä½“
        const body = new THREE.Mesh(new THREE.BoxGeometry(3.4, 3.8, 7.8), matBody);
        body.position.y = 3.3;
        
        // 2. é‡‘è‰²è£…é¥°è…°çº¿ (æ–°åŠ ç»†èŠ‚)
        const goldBand = new THREE.Mesh(new THREE.BoxGeometry(3.45, 0.2, 7.85), matGold);
        goldBand.position.y = 3.0; // ä½äºè½¦çª—ä¸‹æ–¹
        g.add(goldBand);
        
        // 3. è½¦é¡¶ (æ”¹ä¸ºç¨å¾®æ‰å¹³ä¸€ç‚¹çš„åœ†å¼§ï¼Œæ›´åƒç«è½¦ç«™)
        // ä½¿ç”¨ scale å‹æ‰åœ†æŸ±
        const roof = new THREE.Mesh(
            new THREE.CylinderGeometry(2.05, 2.05, 13, 13, 1, false, 0, Math.PI), 
            new THREE.MeshStandardMaterial({color:0x222, roughness:0.9}) // é»‘è‰²ç£¨ç ‚é¡¶
        );
        roof.rotation.set(0, Math.PI/2, Math.PI/2); 
        roof.scale.set(1, 0.65, 1); // ç¨å¾®å‹æ‰ä¸€ç‚¹ç‚¹ï¼Œæ›´åƒè½¦é¡¶
        roof.position.set(0, 5.1, 0); // ç¨å¾®æä¸€ç‚¹é«˜åº¦

        // [å·²åˆ é™¤] è½¦é¡¶ç¤¼ç‰©ç›’ç”Ÿæˆä»£ç 

        // 4. è½¦çª— (Basicæè´¨é˜²é®ç½©)
        const winGeo = new THREE.PlaneGeometry(1.3, 1.6);
        const winMat = new THREE.MeshBasicMaterial({ color: 0xffccaa, fog: false }); 
        
        for (let side = -1; side <= 1; side += 2) {
            for (let k = 0; k < 3; k++) {
                const w = new THREE.Mesh(winGeo, winMat);
                // çª—æˆ·å¸¦ä¸€ç‚¹é‡‘è‰²è¾¹æ¡†? è¿™é‡Œçš„ scale ç¨å¾®å¤§ä¸€ç‚¹åšè¾¹æ¡†
                const border = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 1.7), matGold);
                
                w.position.set(1.76 * side, 3.8, -2.5 + k * 2.5);
                w.rotation.y = side * Math.PI / 2;
                
                border.position.copy(w.position);
                border.position.x -= 0.01 * side; // å¾€é‡Œä¸€ç‚¹
                border.rotation.copy(w.rotation);
                
                g.add(border);
                g.add(w);
            }
        }

        // 5. è¿æ¥å¤„ & è½®å­ (ä¿æŒä¸å˜)
        const gw = new THREE.Mesh(new THREE.BoxGeometry(2.4, 2.8, 1.2), new THREE.MeshStandardMaterial({ color: 0x111 }));
        gw.position.set(0, 3, 4.2);

        const ab = z => {
            const gr = new THREE.Group(); gr.position.set(0, 0, z);
            const w = new THREE.Mesh(new THREE.CylinderGeometry(0.65, 0.65, 0.4, 12).rotateZ(Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x111 }));
            w.position.set(1.6, 0.65, 0);
            const w2 = w.clone(); w2.position.set(-1.6, 0.65, 0);
            gr.add(w, w2); g.add(gr); this.wheels.push(w, w2);
        };
        ab(2.8); ab(-2.8);

        g.add(body, roof, gw);
        return g;
    }

    update(dt, speed) {
        audio.chug(speed);
        
        const dist = speed * dt * 0.2;
        this.prog = (this.prog + dist) % 1;
        
        this.place(this.loco, this.prog);
        this.cars.forEach(c => {
            let t = this.prog - c.userData.off; if(t<0) t+=1;
            this.place(c, t);
        });
        
        this.wheels.forEach(w => w.rotation.x -= dist * 150 * CFG.wheelMult);

        // ğŸš‚ çƒŸé›¾ç”Ÿæˆé€»è¾‘ä¼˜åŒ–
        // 1. é€Ÿåº¦è¶Šå¿«ï¼Œå–·çƒŸé¢‘ç‡è¶Šé«˜
        // 2. å³ä½¿é™æ­¢ï¼Œä¹Ÿä¼šå¶å°”å†’ä¸€ç‚¹ç‚¹çƒŸ
        const smokeProb = speed > 0.01 ? (0.2 + speed * 2.5) : 0.02;
        
        if(Math.random() < smokeProb) {
            vec3.setFromMatrixPosition(this.chim.matrixWorld); 
            // ä¿®æ­£çƒŸé›¾å‡ºç”Ÿç‚¹é«˜åº¦ï¼Œç¨å¾®ä½ä¸€ç‚¹ï¼Œä»çƒŸå›±å£å†…éƒ¨å‡ºæ¥
            vec3.y += 0.4; 
            this.spawnSmoke(vec3, speed);
        }
        
        this.updateSmoke();
    }

    spawnSmoke(pos, trainSpeed) {
        const idx = this.smokeIdx;
        const s = this.smokeData[idx];

        s.active = true;
        s.life = 1.0;
        s.scale = 0.4 + Math.random() * 0.4;
        s.pos = pos.clone();

        // å¤ç”¨ _trainDir è®¡ç®—ç«è½¦å‰è¿›æ–¹å‘
        this._trainDir.set(0, 0, 1).applyQuaternion(this.loco.quaternion).normalize();
        const fwdSpeed = trainSpeed * 0.8;
        s.vel.set(
            this._trainDir.x * fwdSpeed + (Math.random() - 0.5) * 0.2,
            1.2 + Math.random() * 0.5,
            this._trainDir.z * fwdSpeed + (Math.random() - 0.5) * 0.2
        );

        this.smokeIdx = (this.smokeIdx + 1) % this.smokeMax;
    }

    updateSmoke() {
        let dirty = false;

        for(let i=0; i<this.smokeMax; i++) {
            const s = this.smokeData[i];
            if(!s.active) continue;

            s.pos.add(s.vel);
            s.vel.x *= 0.85; s.vel.z *= 0.85; s.vel.y *= 0.96; s.vel.y += 0.005;
            s.life -= 0.015;

            if(s.life <= 0) {
                s.active = false;
                // å½’ä½åˆ°çœ‹ä¸è§çš„åœ°æ–¹
                this.dummy.position.set(0, -1000, 0);
                this.dummy.updateMatrix();
                this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
                dirty = true;
                continue;
            }

            // æ›´æ–°å˜æ¢
            const progress = 1 - s.life;
            const curScale = s.scale * (1 + progress * 5.0);
            
            this.dummy.position.copy(s.pos);
            this.dummy.scale.setScalar(curScale);
            // æ—‹è½¬å¢åŠ åŠ¨æ€æ„Ÿ
            this.dummy.rotation.set(progress, progress, progress); 
            this.dummy.updateMatrix();
            
            this.smokeMesh.setMatrixAt(i, this.dummy.matrix);
            dirty = true;
            
            // æ³¨æ„ï¼šInstancedMesh é»˜è®¤ä¸æ”¯æŒä¿®æ”¹å•ä¸ªå®ä¾‹çš„ Opacity (é€æ˜åº¦)ã€‚
            // è¿™é‡Œçš„æŠ˜ä¸­æ–¹æ¡ˆæ˜¯ï¼šè®©å®ƒå˜å°æˆ–è€…å®Œå…¨æ¶ˆå¤±ï¼Œæˆ–è€…æ¥å—ç»Ÿä¸€çš„ opacityã€‚
            // å¦‚æœå¿…é¡»æ·¡å‡ºï¼Œéœ€è¦è‡ªå®šä¹‰ Shaderï¼Œä½†å¯¹äºæ€§èƒ½ä¼˜åŒ–ç‰ˆï¼Œæˆ‘ä»¬ä¸»è¦è¿½æ±‚æµç•…ã€‚
        }

        if(dirty) this.smokeMesh.instanceMatrix.needsUpdate = true;
    }
    place(o, t) {
        const p=this.curve.getPointAt(t), tan=this.curve.getTangentAt(t);
        o.position.copy(p); o.lookAt(p.clone().add(tan));
    }
}

// ============================
// ğŸ† ä¼˜åŒ–ç‰ˆ Fireworks (å¯¹è±¡æ± æŠ€æœ¯)
// ============================
class Fireworks {
    constructor(sc) {
        this.sc = sc; 
        this.activeRockets = []; 
        this.activeExplosions = [];
        
        // çº¹ç†ç”Ÿæˆ
        const c = document.createElement('canvas'); c.width=32; c.height=32;
        const x = c.getContext('2d'); 
        const g = x.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent'); 
        x.fillStyle=g; x.fillRect(0,0,32,32);
        this.tex = new THREE.CanvasTexture(c);
        
        this.cols = [[0xff0000,0xffaa00],[0x00ffff,0x0000ff],[0xff00ff,0xffaaaa],[0x00ff00,0xffff00]];
        this.sharedMat = new THREE.PointsMaterial({
            size: 8.0, map: this.tex, transparent: true, depthWrite: false, 
            blending: THREE.AdditiveBlending, vertexColors: true
        });

        // --- å¯¹è±¡æ± åˆå§‹åŒ– ---
        this.poolSize = 15; // æœ€å¤§åŒæ—¶å­˜åœ¨çš„çˆ†ç‚¸æ•°
        this.pool = [];
        const particlesPerExplosion = 80;

        for(let i=0; i<this.poolSize; i++) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particlesPerExplosion * 3);
            const col = new Float32Array(particlesPerExplosion * 3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            
            const m = new THREE.Points(geo, this.sharedMat);
            m.frustumCulled = false; // é¿å…è§†é”¥å‰”é™¤è®¡ç®—
            m.visible = false;
            this.sc.add(m);
            
            this.pool.push({
                mesh: m,
                velocities: new Float32Array(particlesPerExplosion * 3), // é¢„åˆ†é…é€Ÿåº¦æ•°ç»„
                life: 0,
                available: true
            });
        }
    }

    launch(pos) {
        // ç«ç®­éƒ¨åˆ†ä»£ç ä¿æŒç®€å•ï¼Œæ­¤å¤„ç•¥å¾®ç®€åŒ–ä»¥èšç„¦æ ¸å¿ƒ
        if(!pos) pos = new THREE.Vector3((Math.random()-0.5)*50, -5, (Math.random()-0.5)*50);
        const ty = pos.y + 50 + Math.random()*40;
        const pal = this.cols[Math.floor(Math.random()*this.cols.length)];
        
        // ç®€å•çš„ç«ç®­å‡ ä½•ä½“ (å°‘é‡åˆ›å»ºå½±å“ä¸å¤§ï¼Œä¹Ÿå¯ä»¥æ± åŒ–ï¼Œä½†è¿™é‡Œå…ˆå¿½ç•¥)
        const m = new THREE.Points(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]), 
            new THREE.PointsMaterial({color:0xffddaa, size:5, map:this.tex, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true})
        );
        m.position.copy(pos);
        this.sc.add(m);
        
        this.activeRockets.push({
            m, pos: pos.clone(), 
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.sqrt(2*0.02*(ty-pos.y)), (Math.random()-0.5)*0.5), 
            pal
        });
    }

    update() {
        // 1. æ›´æ–°ç«ç®­
        for(let i = this.activeRockets.length - 1; i >= 0; i--) {
            const r = this.activeRockets[i];
            r.pos.add(r.vel); r.vel.y -= 0.02; r.m.position.copy(r.pos);
            if(r.vel.y <= 0.5) {
                this.sc.remove(r.m); r.m.geometry.dispose(); r.m.material.dispose();
                this.explode(r.pos, r.pal);
                this.activeRockets.splice(i, 1);
            }
        }

        // 2. æ›´æ–°çˆ†ç‚¸ (ä½¿ç”¨å¯¹è±¡æ± )
        for(let i = 0; i < this.poolSize; i++) {
            const p = this.pool[i];
            if(p.available) continue;

            p.life -= 0.015;
            if(p.life <= 0) {
                p.mesh.visible = false;
                p.available = true; // å½’è¿˜åˆ°æ± å­
                continue;
            }

            const positions = p.mesh.geometry.attributes.position.array;
            const colors = p.mesh.geometry.attributes.color.array;
            
            for(let k=0; k<80; k++) {
                const idx = k*3;
                positions[idx] += p.velocities[idx];
                positions[idx+1] += p.velocities[idx+1];
                positions[idx+2] += p.velocities[idx+2];
                
                p.velocities[idx] *= 0.92;
                p.velocities[idx+1] *= 0.92;
                p.velocities[idx+2] *= 0.92;
                p.velocities[idx+1] -= 0.02;

                // ç®€å•çš„æ·¡å‡º (ç›´æ¥ä¿®æ”¹é¢œè‰² buffer)
                if(p.life < 1.0) {
                    colors[idx] *= 0.94; colors[idx+1] *= 0.94; colors[idx+2] *= 0.94;
                }
            }
            p.mesh.geometry.attributes.position.needsUpdate = true;
            p.mesh.geometry.attributes.color.needsUpdate = true;
        }
    }

    explode(pos, pal) {
        const styleIdx = window.getFireworkSoundStyle?.() ?? -1;
        audio.explode(styleIdx);

        // ä»æ± ä¸­æŸ¥æ‰¾å¯ç”¨å¯¹è±¡
        const item = this.pool.find(p => p.available);
        if(!item) return; // æ± å­æ»¡äº†å°±å¿½ç•¥ï¼Œä¿è¯æ€§èƒ½

        item.available = false;
        item.life = 1.5;
        item.mesh.visible = true;

        const posAttr = item.mesh.geometry.attributes.position.array;
        const colAttr = item.mesh.geometry.attributes.color.array;
        const color = new THREE.Color();

        // é‡ç½®ç²’å­çŠ¶æ€
        for(let i=0; i<80; i++) {
            const idx = i*3;
            // ä½ç½®é‡ç½®ä¸ºçˆ†ç‚¸ä¸­å¿ƒ
            posAttr[idx] = pos.x; posAttr[idx+1] = pos.y; posAttr[idx+2] = pos.z;
            
            // é€Ÿåº¦é‡ç½®
            const speed = 0.5 + Math.random() * 2.8;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            item.velocities[idx] = speed * Math.sin(phi) * Math.cos(theta);
            item.velocities[idx+1] = speed * Math.sin(phi) * Math.sin(theta);
            item.velocities[idx+2] = speed * Math.cos(phi);

            // é¢œè‰²é‡ç½®
            color.setHex(pal[Math.floor(Math.random() * pal.length)]);
            color.multiplyScalar(1.5);
            colAttr[idx] = color.r; colAttr[idx+1] = color.g; colAttr[idx+2] = color.b;
        }
        item.mesh.geometry.attributes.position.needsUpdate = true;
        item.mesh.geometry.attributes.color.needsUpdate = true;
    }
}

// ============================
// â„ï¸ ä¼˜åŒ–ç‰ˆ Snow (GPU Shader é©±åŠ¨)
// ============================
class Snow {
    constructor(sc) {
        const count = 6000; // å¯ä»¥è½»æ¾æ”¯æŒæ›´å¤šç²’å­
        const pos = [];
        const velocities = []; // å­˜å‚¨ä¸‹è½é€Ÿåº¦å’Œåç§»
        
        for(let i=0; i<count; i++) {
            pos.push(
                (Math.random() * 2 - 1) * 400,
                Math.random() * 600,
                (Math.random() * 2 - 1) * 400
            );
            // x: ä¸‹è½é€Ÿåº¦, y: æ‘‡æ‘†é¢‘ç‡, z: æ‘‡æ‘†å¹…åº¦
            velocities.push(
                25 + Math.random() * 20, 
                0.5 + Math.random(), 
                5 + Math.random() * 10 
            );
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        // ç®€å•çš„é›ªèŠ±çº¹ç†
        const cv = document.createElement('canvas'); cv.width=32; cv.height=32;
        const cx = cv.getContext('2d'); cx.fillStyle='#fff'; cx.beginPath(); cx.arc(16,16,16,0,Math.PI*2); cx.fill();
        const tex = new THREE.CanvasTexture(cv);

        // è‡ªå®šä¹‰ Shader æè´¨
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTex: { value: tex },
                uHeight: { value: 600.0 } // è¾¹ç•Œé«˜åº¦
            },
            vertexShader: `
                uniform float uTime;
                uniform float uHeight;
                attribute vec3 velocity;
                varying float vAlpha;
                void main() {
                    vec3 pos = position;
                    // Yè½´ä¸‹è½è®¡ç®—ï¼š(åˆå§‹Y - é€Ÿåº¦*æ—¶é—´) å¯¹ é«˜åº¦å–æ¨¡
                    float fallOffset = velocity.x * uTime;
                    pos.y = mod(position.y - fallOffset, uHeight);
                    
                    // Xè½´æ‘‡æ‘†
                    pos.x += sin(uTime * velocity.y + position.y * 0.05) * velocity.z;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // è·ç¦»è¡°å‡ (å¯é€‰)
                    gl_PointSize = (300.0 / -mvPosition.z) * 0.8;
                    vAlpha = 0.8;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTex;
                varying float vAlpha;
                void main() {
                    vec4 color = texture2D(uTex, gl_PointCoord);
                    if (color.a < 0.5) discard;
                    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha * color.a);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.m = new THREE.Points(geo, mat);
        sc.add(this.m);
    }
    
    update(dt) {
        // CPU åªéœ€è¦æ›´æ–°ä¸€ä¸ªæ—¶é—´å˜é‡
        this.m.material.uniforms.uTime.value += dt;
    }
}

// ============================
// âš™ï¸ äº¤äº’æ§åˆ¶
// ============================
function setupControls() {
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.minDistance = 15; controls.maxDistance = 400;
    controls.addEventListener('start', () => STATE.interacting = true);
    controls.addEventListener('end', () => STATE.interacting = false);
}

// ============================
// setupUI å‡½æ•°
// ============================
function setupUI() {
    const btn = document.getElementById('start-btn');

    // æ‰¹é‡å‘å°„çƒŸèŠ±ï¼ˆæå‰å®šä¹‰ï¼Œä¾›ä¸‹æ–¹å›è°ƒä½¿ç”¨ï¼‰
    const launchBatch = () => {
        if(!STATE.started || document.visibilityState === 'hidden') return;
        const count = 2 + Math.floor(Math.random() * 4);
        for(let i=0; i<count; i++) {
            const delay = i * 300 + Math.random() * 200;
            setTimeout(() => fwMgr.launch(), delay);
        }
    };

    btn.onclick = () => {
        STATE.started = true;
        STATE.running = true;
        audio.init(); 
        audio.whistle(); 
        audio.playBGM(); 
        
        // è‡ªåŠ¨ç‡ƒæ”¾çš„å¯åŠ¨é€»è¾‘
        if (CFG.autoFw) {
            // å…ˆæ”¾ä¸€æ³¢åŠ©å…´
            launchBatch(); 
            // å¯åŠ¨å¾ªç¯
            autoTimer = setInterval(launchBatch, CFG.fwRate * 1000);
        }

        document.getElementById('start-screen').style.opacity = 0;
        setTimeout(() => document.getElementById('start-screen').style.display = 'none', 800);
        document.getElementById('hud').style.opacity = 1;
        document.getElementById('settings-btn').style.opacity = 1;

        // å¯åŠ¨è¿é•œ
        const start = camera.position.clone();
        const back = new THREE.Vector3(0, 0, -1).applyQuaternion(train.loco.quaternion).normalize();
        const end = train.loco.position.clone().add(back.multiplyScalar(40)).add(new THREE.Vector3(0, CFG.camHeight, 0));
        let t = 0;
        const iv = setInterval(() => {
            t += 0.015;
            if (t >= 1) { clearInterval(iv); STATE.viewMode = 'FOLLOW'; }
            else {
                const k = 1 - Math.pow(1 - t, 3);
                camera.position.lerpVectors(start, end, k);
                camera.lookAt(train.loco.position);
            }
        }, 16);
    };

    const set = document.getElementById('settings-btn'), mod = document.getElementById('settings-modal'), over = document.getElementById('modal-overlay');
    const tog = () => { STATE.settings = !STATE.settings; const d = STATE.settings ? 'block' : 'none'; mod.style.display = d; over.style.display = d; };
    set.onclick = tog; over.onclick = tog;

    gui = new GUI({ container: mod, width: '100%' });
    gui.title('ğŸ„ æ§åˆ¶ä¸­å¿ƒ');

    const fSound = gui.addFolder('ğŸ”Š éŸ³é¢‘è®¾ç½®');
    fSound.add(audio.vol, 'master', 0, 1).name('æ€»éŸ³é‡').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'bgm', 0, 1).name('èƒŒæ™¯éŸ³ä¹').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'train', 0, 1).name('ç«è½¦éŸ³æ•ˆ').onChange(() => audio.updateVols());
    fSound.add(audio.vol, 'firework', 0, 1).name('çƒŸèŠ±éŸ³æ•ˆ').onChange(() => audio.updateVols());

    const fCam = gui.addFolder('ğŸ¥ é•œå¤´ä¸ç‰©ç†');
    fCam.add(CFG, 'camHeight', 5, 40).name('è§†è§’é«˜åº¦');
    fCam.add(CFG, 'camSmooth', 0.01, 1).name('è·ŸéšæŸ”å’Œåº¦');
    fCam.add(CFG, 'maxSpeed', 0.02, 0.4).name('ç«è½¦æé€Ÿ');

    const fEnv = gui.addFolder('ğŸ’¡ ç¯å…‰ä¸ç¯å¢ƒ');
    fEnv.add(CFG, 'moonInt', 0, 5).name('æœˆå…‰äº®åº¦').onChange(v => lights.moon.intensity = v);
    fEnv.add(CFG, 'fogDen', 0, 0.005).name('å¤§é›¾æµ“åº¦').onChange(v => scene.fog.density = v);
    fEnv.add(CFG, 'bloomStr', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
    fEnv.add(CFG, 'bloomThr', 0, 1).name('è¾‰å…‰é˜ˆå€¼').onChange(v => bloomPass.threshold = v);
    fEnv.add(CFG, 'lightPow', 0, 200).name('è½¦ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'headlight_spot') o.intensity = v }));
    fEnv.add(CFG, 'bulbBri', 0, 50).name('å½©ç¯äº®åº¦').onChange(v => emissives.forEach(o => { if (o.userData.type === 'bulb') o.material.emissiveIntensity = v }));

    const fFw = gui.addFolder('ğŸ† çƒŸèŠ±æ§åˆ¶');
    // è°ƒè¯•å¯¹è±¡ï¼šé»˜è®¤-1 è¡¨ç¤ºéšæœº
    const debugObj = { soundStyle: -1 };

    // è‡ªåŠ¨ç”ŸæˆéŸ³æ•ˆé£æ ¼é€‰é¡¹ï¼ˆå«â€œéšæœºâ€ï¼‰
    const styleOptions = { 'éšæœº (Random)': -1 };
    SOUND_STYLES.forEach((style, i) => {
        const label = `${i}. ${style.name} (${style.name})`;
        styleOptions[label] = i;
    });

    // æ·»åŠ  GUI æ§ä»¶
    fFw.add(debugObj, 'soundStyle', styleOptions)
       .name('ğŸ’¥ çˆ†ç‚¸éŸ³æ•ˆé£æ ¼'); // ä½¿ç”¨ .name() æ¥æ˜¾ç¤ºä¸­æ–‡æ ‡ç­¾

    window.getFireworkSoundStyle = () => debugObj.soundStyle;

    fFw.add(CFG, 'autoFw').name('è‡ªåŠ¨ç‡ƒæ”¾').onChange(v => {
        if (autoTimer) clearInterval(autoTimer);
        if (v) { 
            launchBatch(); 
            autoTimer = setInterval(launchBatch, CFG.fwRate * 1000); 
        }
    });
    fFw.add(CFG, 'fwRate', 3, 12).name('æ³¢æ¬¡é—´éš”(ç§’)').onChange(v => {
        if (CFG.autoFw) {
            clearInterval(autoTimer);
            autoTimer = setInterval(launchBatch, v * 1000);
        }
    });

    const cvs = document.getElementById('canvas-container');
    cvs.addEventListener('pointerdown', () => STATE.clickTime = Date.now());
    cvs.addEventListener('pointerup', (e) => {
        if (Date.now() - STATE.clickTime < 200 && STATE.started && !STATE.settings) {
            mouse.x = (e.clientX / innerWidth) * 2 - 1; mouse.y = -(e.clientY / innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, camera);

            const hitTrain = ray.intersectObjects(train.grp.children, true);
            if (hitTrain.length > 0) {
                STATE.running = !STATE.running;
                const d = document.getElementById('d-status'), t = document.getElementById('t-status');
                if (STATE.running) {
                    audio.whistle(); 
                    d.classList.remove('stop'); t.innerText = "æ™ºèƒ½é©¾é©¶æ¨¡å¼ (åŠ é€Ÿä¸­)"; STATE.viewMode = 'FOLLOW';
                } else {
                    d.classList.add('stop'); t.innerText = "æƒ¯æ€§æ»‘è¡Œä¸­ (å‡é€Ÿ)";
                }
                return;
            }
            fwMgr.launch(); 
        }
    });
}

window.onresize = () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
};

init();
</script>
    </body>
</html>
