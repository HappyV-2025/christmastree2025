<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas - Bright & Beautiful</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a14; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none;
            text-shadow: 0 0 4px #000; z-index: 10;
        }
        h1 { margin: 0; font-size: 24px; color: #ffd700; }
        p { margin: 5px 0; color: #ddd; font-size: 14px; }
        .highlight { color: #00ffcc; font-weight: bold; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.6); padding: 20px; border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>MERRY CHRISTMAS (高亮画质版)</h1>
        <p>1. 点击地面: <span class="highlight">放烟花</span> (3D粒子)</p>
        <p>2. 点击火车: <span class="highlight">启停火车</span> (自动寻路)</p>
        <p>3. 点击礼物: <span class="highlight">互动弹跳</span></p>
    </div>
    
    <div id="loading">正在点亮圣诞树...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 全局配置 ---
        const CONFIG = {
            trainRadius: 32,
            groundColor: 0x1a2639, // 提亮了地面基础色
            moonColor: 0x88bbff,   // 月光颜色
            fireworkSize: 1.8,     // 烟花大小
        };

        let scene, camera, renderer, composer, controls;
        let raycaster, mouse;
        let train, fireworkMgr, snowSystem;
        let gifts = [];
        const clock = new THREE.Clock();

        function init() {
            // 1. 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050a14); // 深蓝夜空
            scene.fog = new THREE.FogExp2(0x050a14, 0.005); 

            // 2. 相机
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 45, 90);

            // 3. 渲染器 (关闭 ToneMapping 以保持最大亮度)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. 灯光系统 (高亮方案)
            setupLights();

            // 5. 后处理 Bloom (发光特效)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; 
            bloomPass.strength = 1.5;  
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 6. 创建物体
            createGround();
            createTree();
            createFancyGifts(); // 找回礼物！
            
            // 初始化系统
            train = new TrainSystem(scene);
            fireworkMgr = new FireworkManager(scene);
            snowSystem = new SnowSystem(scene); // 找回雪花！

            // 7. 交互
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupLights() {
            // 1. 环境光 (保底亮度，拉高到 0.7)
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            // 2. 月光 (平行光，制造阴影和氛围)
            const moon = new THREE.DirectionalLight(CONFIG.moonColor, 1.5);
            moon.position.set(-50, 80, -50);
            moon.castShadow = true;
            moon.shadow.mapSize.width = 2048;
            moon.shadow.mapSize.height = 2048;
            scene.add(moon);

            // 3. 树下的暖色点光 (照亮礼物)
            const warmLight = new THREE.PointLight(0xffaa00, 4, 60);
            warmLight.position.set(0, 15, 0);
            warmLight.castShadow = false; // 仅补光，不产生复杂阴影节省性能
            scene.add(warmLight);
        }

        // ============================
        // 找回：礼物系统
        // ============================
        function createFancyGifts() {
            const colors = [0xd32f2f, 0x1976d2, 0xfbc02d, 0x7b1fa2];
            const geo = new THREE.BoxGeometry(1, 1, 1);
            
            for(let i=0; i<12; i++) {
                const grp = new THREE.Group();
                const w = 1.5 + Math.random();
                const h = 1.2 + Math.random();
                const d = 1.5 + Math.random();
                
                // 盒子
                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({
                        color: colors[Math.floor(Math.random()*colors.length)],
                        roughness: 0.5
                    })
                );
                box.castShadow = true; box.receiveShadow = true;
                grp.add(box);

                // 丝带
                const ribbonMat = new THREE.MeshStandardMaterial({color: 0xffffff});
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(w*1.05, h, d*0.2), ribbonMat);
                const r2 = new THREE.Mesh(new THREE.BoxGeometry(w*0.2, h, d*1.05), ribbonMat);
                grp.add(r1); grp.add(r2);

                // 随机位置
                const angle = Math.random() * Math.PI * 2;
                const r = 8 + Math.random() * 12; // 在树周围
                grp.position.set(Math.cos(angle)*r, h/2, Math.sin(angle)*r);
                grp.rotation.y = Math.random();
                
                grp.userData = { isGift: true, vy: 0, y0: h/2 };
                scene.add(grp);
                gifts.push(grp);
            }
        }

        // ============================
        // 找回：雪花系统
        // ============================
        class SnowSystem {
            constructor(scene) {
                const count = 2000;
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<count; i++) {
                    pos.push(
                        Math.random()*200 - 100,
                        Math.random()*100,
                        Math.random()*200 - 100
                    );
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                
                const mat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Points(geo, mat);
                scene.add(this.mesh);
            }
            update() {
                const p = this.mesh.geometry.attributes.position.array;
                for(let i=1; i<p.length; i+=3) {
                    p[i] -= 0.15; // 下落
                    if(p[i] < 0) p[i] = 100; // 循环
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ============================
        // 火车系统 (自动对齐)
        // ============================
        class TrainSystem {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.wheels = [];
                this.angle = 0;
                this.speed = 0;
                this.targetSpeed = 0.5;
                
                this.buildModel();
                this.scene.add(this.group);
                this.updatePosition();
            }

            buildModel() {
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.4 });
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const goldMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, metalness: 0.5 });
                
                // 车头
                const loco = new THREE.Group();
                const boiler = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 5, 16), bodyMat);
                boiler.rotation.x = Math.PI / 2; boiler.position.set(0, 2.5, 0);
                loco.add(boiler);

                const cab = new THREE.Mesh(new THREE.BoxGeometry(3.2, 5, 3), bodyMat);
                cab.position.set(0, 3.5, -3.5);
                loco.add(cab);

                const chim = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 1.5), blackMat);
                chim.position.set(0, 4, 1.5);
                loco.add(chim);

                // 车灯
                const lightMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.2, 0.5), goldMat);
                lightMesh.rotation.x = -Math.PI/2;
                lightMesh.position.set(0, 2, 2.6);
                loco.add(lightMesh);
                
                const spot = new THREE.SpotLight(0xffffee, 8, 50, 0.6, 0.5);
                spot.position.set(0, 2, 3);
                spot.target.position.set(0, 0, 20);
                loco.add(spot);
                loco.add(spot.target);

                // 轮子
                const wGeo = new THREE.CylinderGeometry(0.9, 0.9, 0.4, 12);
                wGeo.rotateZ(Math.PI/2);
                const addWheel = (x, z) => {
                    const w = new THREE.Mesh(wGeo, blackMat);
                    w.position.set(x, 0.9, z);
                    loco.add(w);
                    this.wheels.push(w);
                }
                addWheel(1.6, 1.5); addWheel(-1.6, 1.5);
                addWheel(1.6, -1); addWheel(-1.6, -1);
                addWheel(1.6, -3.5); addWheel(-1.6, -3.5);

                this.group.add(loco);

                const hitBox = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 12), new THREE.MeshBasicMaterial({visible:false}));
                hitBox.position.y = 4;
                hitBox.userData = { isTrain: true };
                this.group.add(hitBox);
            }

            toggle() {
                this.targetSpeed = (this.targetSpeed === 0) ? 0.6 : 0;
            }

            updatePosition() {
                const r = CONFIG.trainRadius;
                this.group.position.set(Math.cos(this.angle)*r, 0, Math.sin(this.angle)*r);
                
                // 让车头永远看向前方 (轨道切线)
                const lookAngle = this.angle - 0.1;
                const lx = Math.cos(lookAngle)*r;
                const lz = Math.sin(lookAngle)*r;
                this.group.lookAt(lx, 0, lz);
            }

            update(delta) {
                if(Math.abs(this.speed - this.targetSpeed) > 0.01) {
                    this.speed += (this.targetSpeed - this.speed) * 0.02;
                } else {
                    this.speed = this.targetSpeed;
                }
                if(this.speed > 0) {
                    this.angle -= this.speed * delta * 0.5;
                    this.updatePosition();
                    this.wheels.forEach(w => w.rotation.x += this.speed * 0.5);
                    if(Math.random() > 0.8) spawnSmoke(this.group.position);
                }
            }
        }

        // ============================
        // 烟花管理器
        // ============================
        class FireworkManager {
            constructor(scene) {
                this.scene = scene;
                this.fireworks = [];
                this.texture = this.createTexture();
            }
            createTexture() {
                const c = document.createElement('canvas'); c.width=64; c.height=64;
                const ctx = c.getContext('2d');
                const g = ctx.createRadialGradient(32,32,0,32,32,32);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(c);
            }
            launch(target) {
                if(this.fireworks.length > 20) return;
                const count = 3 + Math.floor(Math.random()*3);
                for(let i=0; i<count; i++) setTimeout(() => this.spawnOne(target), i*250);
            }
            spawnOne(center) {
                const start = center.clone().add(new THREE.Vector3((Math.random()-0.5)*15, 0, (Math.random()-0.5)*15));
                const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.6);
                this.fireworks.push({
                    phase: 'rise', pos: start, vel: new THREE.Vector3(0, 0.8+Math.random()*0.4, 0),
                    destY: 30+Math.random()*20, color: color, particles: null, trail: this.createTrail(start, color)
                });
            }
            createTrail(pos, color) {
                const m = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({color:color}));
                m.position.copy(pos); this.scene.add(m); return m;
            }
            explode(fw) {
                this.scene.remove(fw.trail); fw.phase = 'explode';
                const count = 100; const pos = []; const vels = [];
                for(let i=0; i<count; i++) {
                    pos.push(fw.pos.x, fw.pos.y, fw.pos.z);
                    const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1); const s = 0.5+Math.random()*0.5;
                    vels.push(Math.sin(phi)*Math.cos(theta)*s, Math.sin(phi)*Math.sin(theta)*s, Math.cos(phi)*s);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({
                    color: fw.color, size: CONFIG.fireworkSize, map: this.texture,
                    transparent: true, opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false
                });
                fw.particles = new THREE.Points(geo, mat);
                fw.particles.userData = { vels: vels, life: 1.0 };
                this.scene.add(fw.particles);
            }
            update() {
                for(let i=this.fireworks.length-1; i>=0; i--) {
                    const fw = this.fireworks[i];
                    if(fw.phase === 'rise') {
                        fw.pos.add(fw.vel); fw.vel.y *= 0.98; fw.trail.position.copy(fw.pos);
                        if(fw.pos.y >= fw.destY || fw.vel.y < 0.1) this.explode(fw);
                    } else {
                        const pts = fw.particles; const p = pts.geometry.attributes.position.array; const v = pts.userData.vels;
                        pts.userData.life -= 0.008;
                        for(let k=0; k<p.length/3; k++) {
                            v[k*3]*=0.96; v[k*3+1]*=0.96; v[k*3+2]*=0.96; v[k*3+1]-=0.005;
                            p[k*3]+=v[k*3]; p[k*3+1]+=v[k*3+1]; p[k*3+2]+=v[k*3+2];
                        }
                        pts.geometry.attributes.position.needsUpdate = true;
                        pts.material.opacity = pts.userData.life;
                        if(pts.userData.life <= 0) {
                            this.scene.remove(pts); pts.geometry.dispose(); pts.material.dispose(); this.fireworks.splice(i, 1);
                        }
                    }
                }
            }
        }

        // ============================
        // 杂项
        // ============================
        let smokes = [];
        function spawnSmoke(pos) {
            const offset = new THREE.Vector3(0, 5, 0).applyQuaternion(train.group.quaternion);
            const m = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({color:0xaaaaaa, transparent:true, opacity:0.3}));
            m.position.copy(pos.clone().add(offset));
            scene.add(m); smokes.push({m, life:1.2});
        }
        function updateSmoke() {
            for(let i=smokes.length-1; i>=0; i--) {
                const s = smokes[i]; s.life -= 0.02; s.m.position.y += 0.1; s.m.scale.multiplyScalar(1.03); s.m.material.opacity = s.life*0.3;
                if(s.life<=0) { scene.remove(s.m); smokes.splice(i,1); }
            }
        }

        function createGround() {
            const geo = new THREE.CircleGeometry(120, 64);
            const mat = new THREE.MeshStandardMaterial({ color: CONFIG.groundColor, roughness: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2; mesh.receiveShadow = true;
            scene.add(mesh);
            const tGeo = new THREE.TorusGeometry(CONFIG.trainRadius, 0.4, 6, 120);
            const track = new THREE.Mesh(tGeo, new THREE.MeshStandardMaterial({color:0x000000}));
            track.rotation.x = Math.PI/2; track.position.y=0.1; scene.add(track);
        }

        function createTree() {
            const grp = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 3, 6, 8), new THREE.MeshStandardMaterial({color:0x3e2723}));
            trunk.position.y = 3; grp.add(trunk);
            const colors = [0x1b5e20, 0x2e7d32, 0x388e3c];
            for(let i=0; i<5; i++) {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(12-i*2, 7, 10), new THREE.MeshStandardMaterial({color:colors[i%3], flatShading:true}));
                cone.position.y = 6+i*4; cone.castShadow = true; grp.add(cone);
                for(let j=0; j<6; j++) {
                    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({
                        color: Math.random()>0.5?0xff0000:0xffd700,
                        emissive: Math.random()>0.5?0x330000:0x333300 // 自发光
                    }));
                    const a=(j/6)*Math.PI*2; const r=(12-i*2)*0.5;
                    ball.position.set(Math.cos(a)*r, 6+i*4-3, Math.sin(a)*r); grp.add(ball);
                }
            }
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(2), new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffaa00, emissiveIntensity:0.5}));
            star.position.y=26; grp.add(star);
            scene.add(grp);
        }

        function onPointerDown(e) {
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            let hit = false;
            if(intersects.length>0) {
                let obj = intersects[0].object;
                while(obj) { 
                    if(obj.userData.isTrain) { train.toggle(); hit=true; break; } 
                    if(obj.userData.isGift) { obj.userData.vy=0.5; hit=true; break; }
                    obj = obj.parent; 
                }
            }
            if(!hit) {
                const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
                const t = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, t);
                if(t) fireworkMgr.launch(t);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if(train) train.update(delta);
            if(fireworkMgr) fireworkMgr.update();
            if(snowSystem) snowSystem.update();
            if(gifts.length>0) {
                gifts.forEach(g => {
                    if(g.userData.vy!==0 || g.position.y>g.userData.y0) {
                        g.position.y += g.userData.vy; g.userData.vy -= 0.02;
                        if(g.position.y <= g.userData.y0) { g.position.y = g.userData.y0; g.userData.vy=0; }
                    }
                });
            }
            updateSmoke();
            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
