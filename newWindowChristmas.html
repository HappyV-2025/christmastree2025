
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Window View</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: "Microsoft YaHei", sans-serif;
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }
        
        #ui-layer {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            color: #fff; z-index: 10;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            text-align: center;
            width: 100%;
        }
        
        .title {
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 5px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .tips {
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            backdrop-filter: blur(4px);
        }

        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="title">MERRY CHRISTMAS</div>
        <div class="tips">âœ¨ ç‚¹å‡»å¤œç©ºç»½æ”¾çƒŸèŠ± | ğŸ„ ç‚¹å‡»åœ£è¯æ ‘åˆ‡æ¢ç¯å…‰</div>
    </div>
    
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            colors: {
                skyTop: 0x0a1a3a,      // æ·±è“å¤œç©º
                skyBottom: 0x4a6a8a,   // åœ°å¹³çº¿å¾®å…‰
                indoorLight: 0xffaa44, // å®¤å†…æš–å…‰ (å£ç‚‰æ„Ÿ)
                outdoorLight: 0x88ccff,// å®¤å¤–å†·æœˆå…‰
                windowFrame: 0x3e2723, // æ·±æœ¨è‰²çª—æ¡†
            },
            fireworks: {
                gravity: 0.008,        // çƒŸèŠ±ä¸‹è½é‡åŠ›
                drag: 0.96,            // ç©ºæ°”é˜»åŠ›
                count: 150             // çˆ†ç‚¸ç²’å­æ•°
            }
        };

        let scene, camera, renderer;
        let fireworkSystem, snowSystem;
        let treeGroup, treeLightPoints;
        let raycaster, mouse;
        const clock = new THREE.Clock();

        // çº¹ç†ç¼“å­˜
        const textures = {};

        function init() {
            // 1. åˆå§‹åŒ–åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x051020, 0.012); // è¿œå¤„é›¾æ°”

            // 2. ç›¸æœº (ç”± resize æ§åˆ¶)
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);

            // 3. æ¸²æŸ“å™¨ (é’ˆå¯¹ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼Œä¸å¼€å¯æ˜‚è´µçš„åå¤„ç†ï¼Œç”¨è´´å›¾æ¨¡æ‹Ÿå‘å…‰)
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // å¼€å¯ç‰©ç†å…‰ç…§ä¿®æ­£
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. ç”Ÿæˆèµ„æº
            textures.glow = createGlowTexture();
            textures.star = createStarTexture();

            // 5. æ„å»ºä¸–ç•Œ
            setupLighting();
            createEnvironment(); // å¤©ç©ºã€åœ°é¢ã€è¿œå¤„å»ºç­‘
            createRoomAndWindow(); // å®¤å†…ç»“æ„
            createChristmasTree(); // æ ‘
            
            // 6. ç³»ç»Ÿ
            snowSystem = new SnowSystem(scene);
            fireworkSystem = new FireworkSystem(scene);

            // 7. äº¤äº’
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('mousemove', onMouseMove);
            
            onResize(); // åˆå§‹é€‚é…
            animate();
        }

        // --- å…‰ç…§ç³»ç»Ÿ (å†·æš–å¯¹æ¯”) ---
        function setupLighting() {
            // 1. å®¤å†…æš–å…‰ (ç…§äº®æ ‘å’Œçª—æ¡†å†…éƒ¨)
            const indoorPoint = new THREE.PointLight(CONFIG.colors.indoorLight, 5, 15);
            indoorPoint.position.set(2, 3, 4); // ä½äºå®¤å†…å³ä¸Šæ–¹
            indoorPoint.castShadow = true;
            indoorPoint.shadow.bias = -0.001;
            scene.add(indoorPoint);

            // 2. å®¤å¤–æœˆå…‰ (ç…§äº®é›ªåœ°å’Œçª—å¤–)
            const moonLight = new THREE.DirectionalLight(CONFIG.colors.outdoorLight, 1.5);
            moonLight.position.set(-10, 20, -20);
            moonLight.castShadow = true;
            moonLight.shadow.camera.left = -20;
            moonLight.shadow.camera.right = 20;
            moonLight.shadow.camera.top = 20;
            moonLight.shadow.camera.bottom = -20;
            scene.add(moonLight);

            // 3. è¡¥å…‰ (åŠçƒå…‰ï¼šå¤©ç©ºè“ + åœ°é¢åå°„ç™½)
            const hemiLight = new THREE.HemisphereLight(CONFIG.colors.skyTop, 0x222222, 0.4);
            scene.add(hemiLight);
        }

        // --- ç¯å¢ƒæ„å»º ---
        function createEnvironment() {
            // 1. åŠ¨æ€æ¸å˜å¤©ç©ºçƒ
            const skyGeo = new THREE.SphereGeometry(200, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                side: THREE.BackSide,
                uniforms: {
                    topColor: { value: new THREE.Color(CONFIG.colors.skyTop) },
                    bottomColor: { value: new THREE.Color(CONFIG.colors.skyBottom) },
                    offset: { value: 10 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize( vWorldPosition + offset ).y;
                        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
                    }
                `
            });
            scene.add(new THREE.Mesh(skyGeo, skyMat));

            // 2. å®¤å¤–é›ªåœ° (ä½é¢æ•°èµ·ä¼åœ°å½¢)
            const groundGeo = new THREE.PlaneGeometry(100, 100, 40, 40);
            const pos = groundGeo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                pos.setZ(i, Math.random() * 1.5); // Zè½´æ˜¯é«˜åº¦ï¼ˆæ—‹è½¬åï¼‰
            }
            groundGeo.computeVertexNormals();
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0xeef5ff, 
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -8, -30); // æ”¾åœ¨çª—æˆ·ä¸‹æ–¹å¾ˆè¿œï¼Œåˆ¶é€ äºŒæ¥¼æ„Ÿ
            ground.receiveShadow = true;
            scene.add(ground);

            // 3. è¿œå¤„åŸå¸‚å…‰å½± (InstancedMeshä¼˜åŒ–æ€§èƒ½)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0x111111 }); // é»‘è‰²å‰ªå½±
            const winMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); // äº®çª—æˆ·
            
            // ç®€å•çš„èƒŒæ™¯æˆ¿å­
            const houseGroup = new THREE.Group();
            for(let i=0; i<30; i++) {
                const w = 4 + Math.random() * 5;
                const h = 5 + Math.random() * 10;
                const d = 4 + Math.random() * 5;
                const x = (Math.random() - 0.5) * 80;
                const z = -20 - Math.random() * 40;
                
                const house = new THREE.Mesh(boxGeo, boxMat);
                house.position.set(x, -8 + h/2, z);
                house.scale.set(w, h, d);
                houseGroup.add(house);

                // éšæœºäº®ç‚¹ (çª—æˆ·)
                if(Math.random() > 0.4) {
                    const win = new THREE.Mesh(boxGeo, winMat);
                    win.position.set(x, -8 + h * 0.7, z + d/2 + 0.1);
                    win.scale.set(0.5, 0.8, 0.1);
                    houseGroup.add(win);
                }
            }
            scene.add(houseGroup);
        }

        // --- æˆ¿é—´ä¸çª—æˆ· ---
        function createRoomAndWindow() {
            const roomGroup = new THREE.Group();
            
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x221105, roughness: 1.0 }); // æš—å¢™
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.windowFrame, roughness: 0.6 }); // çª—æ¡†

            // å¢™ä½“ (æŒ–ç©ºçš„çª—æˆ·)
            // ä¸Š
            const topWall = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 1), wallMat);
            topWall.position.set(0, 5, 0); roomGroup.add(topWall);
            // ä¸‹ (å¢™è£™)
            const botWall = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 1), wallMat);
            botWall.position.set(0, -5, 0); roomGroup.add(botWall);
            // å·¦
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(6, 14, 1), wallMat);
            leftWall.position.set(-7, 0, 0); roomGroup.add(leftWall);
            // å³
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(6, 14, 1), wallMat);
            rightWall.position.set(7, 0, 0); roomGroup.add(rightWall);

            // çª—å° (å®½åšä¸€ç‚¹ï¼Œå¯ä»¥æ”¾ä¸œè¥¿)
            const sill = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.5, 2.5), frameMat);
            sill.position.set(0, -3.2, 0.5); 
            sill.receiveShadow = true;
            roomGroup.add(sill);

            // çª—æ¡†æ ¼æ …
            const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 0.5), frameMat);
            roomGroup.add(vBar);
            const hBar = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 0.5), frameMat);
            hBar.position.y = 1; // ç¨å¾®åä¸Šä¸€ç‚¹
            roomGroup.add(hBar);

            // ç»ç’ƒ (é«˜äº®åå°„ï¼Œä½†ä¸é˜»æŒ¡è§†çº¿)
            const glassGeo = new THREE.PlaneGeometry(8, 6);
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0xaaccff,
                transparent: true,
                opacity: 0.15,
                metalness: 0.9,
                roughness: 0.0,
                side: THREE.DoubleSide
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.z = -0.1;
            roomGroup.add(glass);

            scene.add(roomGroup);
        }

        // --- åœ£è¯æ ‘ (é«˜ç²¾åº¦) ---
        function createChristmasTree() {
            treeGroup = new THREE.Group();
            // æ”¾åœ¨çª—æˆ·å³ä¾§ï¼Œå®¤å†…åœ°æ¿ä¸Š
            treeGroup.position.set(2.5, -3.0, 3.5); 
            treeGroup.rotation.y = -0.3;

            // 1. æ ‘å¶ (å¤šå±‚ä¸è§„åˆ™åœ†é”¥)
            const leafMat = new THREE.MeshStandardMaterial({ 
                color: 0x053305, // æ·±ç»¿
                roughness: 0.8,
                flatShading: true // ä½å¤šè¾¹å½¢é£æ ¼ï¼Œå¢å¼ºå…‰å½±æ„Ÿ
            });

            const layers = 7;
            for(let i=0; i<layers; i++) {
                const ratio = i / layers;
                const r = 1.8 * (1 - ratio) + 0.2;
                const h = 1.2;
                const y = i * 0.8;
                
                const cone = new THREE.Mesh(new THREE.ConeGeometry(r, h, 12), leafMat);
                cone.position.y = y + 0.6;
                cone.scale.set(1, 1, 1);
                cone.castShadow = true;
                
                // éšæœºæ‰°åŠ¨é¡¶ç‚¹ï¼Œè®©æ ‘çœ‹èµ·æ¥è‡ªç„¶è“¬æ¾
                const pos = cone.geometry.attributes.position;
                for(let k=0; k<pos.count; k++) {
                    pos.setY(k, pos.getY(k) - Math.random()*0.3);
                }
                cone.geometry.computeVertexNormals();
                
                treeGroup.add(cone);
                
                // æ¯å±‚åŠ è£…é¥°çƒ
                if(i < layers - 1) addBaubles(cone, r, h);
            }

            // 2. æ ‘å¹²
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8), new THREE.MeshStandardMaterial({color: 0x3e2723}));
            trunk.position.y = 0;
            treeGroup.add(trunk);

            // 3. æ ‘é¡¶æ˜Ÿ (è‡ªå‘å…‰)
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
            star.position.y = layers * 0.8 + 0.5;
            treeGroup.add(star);
            
            // æ˜Ÿæ˜Ÿå…‰æ™•
            const starGlow = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: textures.glow, 
                color: 0xffaa00, 
                blending: THREE.AdditiveBlending 
            }));
            starGlow.scale.set(2, 2, 1);
            star.add(starGlow);

            // 4. æ ‘ä¸‹çš„ç¤¼ç‰©
            addGifts(treeGroup);

            // 5. å½©ç¯ç³»ç»Ÿ
            setupTreeLights(layers);

            treeGroup.userData = { isTree: true };
            scene.add(treeGroup);
        }

        function addBaubles(parent, r, h) {
            const count = Math.floor(r * 6);
            const geo = new THREE.SphereGeometry(0.12, 8, 8);
            const colors = [0xff0000, 0xffd700, 0xc0c0c0, 0x0000ff];
            
            for(let i=0; i<count; i++) {
                const mat = new THREE.MeshStandardMaterial({
                    color: colors[Math.floor(Math.random()*colors.length)],
                    metalness: 0.7, roughness: 0.2
                });
                const mesh = new THREE.Mesh(geo, mat);
                const angle = Math.random() * Math.PI * 2;
                // æŒ‚åœ¨åœ†é”¥è¾¹ç¼˜
                mesh.position.set(Math.cos(angle)*r*0.85, -h*0.35, Math.sin(angle)*r*0.85);
                parent.add(mesh);
            }
        }

        function addGifts(group) {
            const colors = [0xd32f2f, 0x1976d2, 0xfbc02d];
            for(let i=0; i<5; i++) {
                const size = 0.4 + Math.random()*0.4;
                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshStandardMaterial({ color: colors[i%3] })
                );
                const angle = Math.random() * Math.PI; // åªåœ¨å‰åŠåœ†
                const dist = 1.0 + Math.random() * 1.0;
                box.position.set(Math.cos(angle)*dist, size/2, Math.sin(angle)*dist + 0.5);
                box.rotation.y = Math.random();
                box.castShadow = true;
                group.add(box);
            }
        }

        function setupTreeLights(height) {
            const count = 120;
            const pos = [];
            const colors = [];
            const colorPalette = [
                new THREE.Color(1, 0.1, 0.1), // çº¢
                new THREE.Color(1, 0.8, 0.1), // é‡‘
                new THREE.Color(0.1, 0.5, 1), // è“
                new THREE.Color(0.1, 1, 0.2), // ç»¿
            ];

            for(let i=0; i<count; i++) {
                const t = i/count; // 0 to 1
                const y = t * (height * 0.8) + 0.5;
                const r = (1 - t) * 1.6 + 0.2;
                const angle = t * 25.0; // èºæ—‹ä¸Šå‡
                
                pos.push(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                const c = colorPalette[i % 4];
                colors.push(c.r, c.g, c.b);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: 0.25, // ç¯æ³¡æ›´å¤§
                map: textures.glow,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // åŠ æ³•æ··åˆï¼Œå‘å…‰æ›´äº®
                depthWrite: false, // é¿å…é®æŒ¡é—®é¢˜
                transparent: true,
                opacity: 0.9
            });

            treeLightPoints = new THREE.Points(geo, mat);
            treeGroup.add(treeLightPoints);
        }

        // --- ç‰©ç†çƒŸèŠ±ç³»ç»Ÿ ---
        class FireworkSystem {
            constructor(scene) {
                this.scene = scene;
                this.activeFireworks = [];
                // é¢„åˆ›å»ºçˆ†ç‚¸éŸ³æ•ˆ(å¯é€‰ï¼Œè¿™é‡Œåªåšè§†è§‰)
            }

            launch(startPos, endPos) {
                // 1. å‘å°„é˜¶æ®µå¯¹è±¡
                const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.6);
                const rocketGeo = new THREE.BufferGeometry().setFromPoints([startPos, startPos]);
                const rocketMat = new THREE.LineBasicMaterial({ 
                    color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.8 
                });
                
                const rocket = {
                    phase: 'launch',
                    mesh: new THREE.Line(rocketGeo, rocketMat),
                    pos: startPos.clone(),
                    vel: endPos.clone().sub(startPos).normalize().multiplyScalar(0.6 + Math.random()*0.2), // é€Ÿåº¦
                    targetY: endPos.y,
                    color: color
                };
                
                this.scene.add(rocket.mesh);
                
                // å°¾ç„°ç²’å­ (ç®€å•Sprite)
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: textures.glow, color: 0xffaa55, blending: THREE.AdditiveBlending
                }));
                sprite.scale.set(1.5, 1.5, 1.5);
                rocket.head = sprite;
                this.scene.add(sprite);

                this.activeFireworks.push(rocket);
            }

            explode(pos, color) {
                // 2. çˆ†ç‚¸é˜¶æ®µ
                const pCount = CONFIG.fireworks.count;
                const geo = new THREE.BufferGeometry();
                const pPos = new Float32Array(pCount * 3);
                const pVel = []; // è‡ªå®šä¹‰é€Ÿåº¦æ•°ç»„
                
                for(let i=0; i<pCount; i++) {
                    pPos[i*3] = pos.x;
                    pPos[i*3+1] = pos.y;
                    pPos[i*3+2] = pos.z;
                    
                    // çƒå½¢éšæœºé€Ÿåº¦
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    const speed = 0.1 + Math.random() * 0.4;
                    
                    pVel.push({
                        x: Math.sin(phi) * Math.cos(theta) * speed,
                        y: Math.sin(phi) * Math.sin(theta) * speed,
                        z: Math.cos(phi) * speed
                    });
                }
                
                geo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                
                const mat = new THREE.PointsMaterial({
                    size: 0.8,
                    color: color,
                    map: textures.star, // æ˜Ÿæ˜Ÿå½¢çŠ¶
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 1.0
                });
                
                const points = new THREE.Points(geo, mat);
                this.scene.add(points);
                
                // çˆ†ç‚¸ä¸­å¿ƒé—ªå…‰
                const flash = new THREE.PointLight(color, 10, 30);
                flash.position.copy(pos);
                this.scene.add(flash);
                setTimeout(() => this.scene.remove(flash), 100); // é—ªä¸€ä¸‹å°±æ²¡

                return {
                    phase: 'explode',
                    mesh: points,
                    vels: pVel,
                    life: 1.0
                };
            }

            update() {
                for(let i=this.activeFireworks.length-1; i>=0; i--) {
                    const fw = this.activeFireworks[i];
                    
                    if(fw.phase === 'launch') {
                        // æ›´æ–°ä½ç½®
                        fw.pos.add(fw.vel);
                        fw.head.position.copy(fw.pos);
                        
                        // æ›´æ–°å°¾è¿¹çº¿æ¡
                        const positions = fw.mesh.geometry.attributes.position.array;
                        // ç®€å•çš„æ‹–å°¾æ•ˆæœï¼šèµ·ç‚¹æ…¢æ…¢è·Ÿè¿›
                        positions[0] += (positions[3] - positions[0]) * 0.15;
                        positions[1] += (positions[4] - positions[1]) * 0.15;
                        positions[2] += (positions[5] - positions[2]) * 0.15;
                        positions[3] = fw.pos.x;
                        positions[4] = fw.pos.y;
                        positions[5] = fw.pos.z;
                        fw.mesh.geometry.attributes.position.needsUpdate = true;

                        // åˆ°è¾¾é«˜åº¦
                        if(fw.vel.y < 0.1 || fw.pos.y >= fw.targetY) {
                            // ç§»é™¤å‘å°„ä½“
                            this.scene.remove(fw.mesh);
                            this.scene.remove(fw.head);
                            fw.mesh.geometry.dispose();
                            
                            // äº§ç”Ÿçˆ†ç‚¸
                            this.activeFireworks[i] = this.explode(fw.pos, fw.color);
                        } else {
                            // æ¨¡æ‹Ÿé‡åŠ›å‡é€Ÿ
                            fw.vel.y *= 0.98;
                        }
                    } 
                    else if (fw.phase === 'explode') {
                        fw.life -= 0.015; // å¯¿å‘½è¡°å‡
                        
                        if(fw.life <= 0) {
                            this.scene.remove(fw.mesh);
                            fw.mesh.geometry.dispose();
                            fw.mesh.material.dispose();
                            this.activeFireworks.splice(i, 1);
                            continue;
                        }
                        
                        const positions = fw.mesh.geometry.attributes.position.array;
                        for(let k=0; k<fw.vels.length; k++) {
                            const v = fw.vels[k];
                            // ç‰©ç†æ›´æ–°
                            v.x *= CONFIG.fireworks.drag;
                            v.y *= CONFIG.fireworks.drag;
                            v.z *= CONFIG.fireworks.drag;
                            v.y -= CONFIG.fireworks.gravity; // é‡åŠ›ä¸‹è½
                            
                            positions[k*3] += v.x;
                            positions[k*3+1] += v.y;
                            positions[k*3+2] += v.z;
                        }
                        fw.mesh.geometry.attributes.position.needsUpdate = true;
                        fw.mesh.material.opacity = fw.life;
                        fw.mesh.material.size = fw.life * 1.5; // æ…¢æ…¢å˜å°
                    }
                }
            }
        }

        // --- é›ªèŠ±ç³»ç»Ÿ ---
        class SnowSystem {
            constructor(scene) {
                const count = 1500;
                const geo = new THREE.BufferGeometry();
                const pos = [];
                const vels = []; // æ¯ä¸ªé›ªèŠ±çš„ç‹¬ç‰¹é€Ÿåº¦
                for(let i=0; i<count; i++) {
                    pos.push(
                        (Math.random()-0.5) * 80,
                        Math.random() * 50,
                        (Math.random()-0.5) * 40 - 20 // ä¹Ÿæ˜¯ä¸»è¦åœ¨çª—å¤–
                    );
                    vels.push((Math.random() * 0.05) + 0.02);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.userData = { vels: vels };
                
                const mat = new THREE.PointsMaterial({
                    color: 0xffffff, size: 0.3, 
                    map: textures.glow, transparent: true, opacity: 0.8,
                    depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.mesh = new THREE.Points(geo, mat);
                scene.add(this.mesh);
            }
            update(time) {
                const pos = this.mesh.geometry.attributes.position.array;
                const vels = this.mesh.geometry.userData.vels;
                
                for(let i=0; i<vels.length; i++) {
                    const idx = i*3;
                    // ä¸‹è½
                    pos[idx+1] -= vels[i];
                    // å·¦å³é£˜è¡
                    pos[idx] += Math.sin(time + pos[idx+1]*0.1) * 0.02;
                    
                    // é‡ç½®
                    if(pos[idx+1] < -10) {
                        pos[idx+1] = 40;
                        pos[idx] = (Math.random()-0.5) * 80;
                    }
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        // --- è¾…åŠ©å‡½æ•°: ç¨‹åºåŒ–çº¹ç† ---
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        
        function createStarTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            // ç”»ä¸ªç®€å•çš„åå­—æ˜Ÿ
            ctx.moveTo(32, 0); ctx.lineTo(32, 64);
            ctx.moveTo(0, 32); ctx.lineTo(64, 32);
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            // ä¸­å¿ƒäº®æ–‘
            ctx.beginPath(); ctx.arc(32,32,8,0,Math.PI*2); ctx.fill();
            return new THREE.CanvasTexture(c);
        }

        // --- äº‹ä»¶å¤„ç† ---
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // å“åº”å¼è§†è§’è°ƒæ•´
            if(window.innerWidth < window.innerHeight) {
                // æ‰‹æœºç«–å±ï¼šç¦»è¿œä¸€ç‚¹ï¼Œçœ‹åˆ°æ›´å¤šå†…å®¹
                camera.position.set(0, 0, 12);
            } else {
                // ç”µè„‘æ¨ªå±
                camera.position.set(0, 0, 8);
            }
            camera.lookAt(0, 0, -10);
        }
        
        function onMouseMove(e) {
            // è§†å·®å¾®åŠ¨
            const x = (e.clientX / window.innerWidth - 0.5) * 0.5;
            const y = (e.clientY / window.innerHeight - 0.5) * 0.5;
            camera.position.x += (x - camera.position.x) * 0.05;
            camera.position.y += (-y - camera.position.y) * 0.05;
            camera.lookAt(0, 0, -10);
        }

        function onPointerDown(e) {
            e.preventDefault();
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // 1. åœ£è¯æ ‘äº’åŠ¨
            const intersects = raycaster.intersectObjects(treeGroup.children);
            if(intersects.length > 0) {
                // åˆ‡æ¢ç¯å…‰é¢œè‰²æ¨¡å¼
                if(treeLightPoints) {
                    const colors = treeLightPoints.geometry.attributes.color;
                    for(let i=0; i<colors.count; i++) {
                        colors.setXYZ(i, Math.random(), Math.random(), Math.random());
                    }
                    colors.needsUpdate = true;
                    // é—ªä¸€ä¸‹
                    treeLightPoints.material.size = 0.5;
                    setTimeout(()=> treeLightPoints.material.size = 0.25, 200);
                }
                return;
            }

            // 2. ç‡ƒæ”¾çƒŸèŠ± (æŠ•å°„åˆ°è¿œå¤„å¤©ç©ºå¹³é¢)
            // å‡è®¾çƒŸèŠ±ç‚¸ç‚¹å¹³é¢åœ¨ Z = -30 å·¦å³
            const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = (-30 - camera.position.z) / dir.z;
            const targetPos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // ç¨å¾®éšæœºåŒ–é«˜åº¦
            targetPos.y = Math.max(-5, targetPos.y); 
            
            // è®¡ç®—å‘å°„èµ·ç‚¹ (ä»å±å¹•åº•éƒ¨å‡èµ·)
            const startPos = targetPos.clone();
            startPos.y = -20;
            
            fireworkSystem.launch(startPos, targetPos);
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            
            fireworkSystem.update();
            snowSystem.update(t);
            
            // åœ£è¯æ ‘å½©ç¯å‘¼å¸æ•ˆæœ
            if(treeLightPoints) {
                const intensity = 0.8 + Math.sin(t * 3) * 0.2;
                treeLightPoints.material.opacity = intensity;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
